<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李三岁他很皮</title>
  
  <subtitle>学习干嘛 愣着啊</subtitle>
  <link href="https://wheliosc.github.io/atom.xml" rel="self"/>
  
  <link href="https://wheliosc.github.io/"/>
  <updated>2021-08-30T06:12:16.537Z</updated>
  <id>https://wheliosc.github.io/</id>
  
  <author>
    <name>lihui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LAMP</title>
    <link href="https://wheliosc.github.io/LAMP"/>
    <id>https://wheliosc.github.io/LAMP</id>
    <published>2021-08-30T06:15:21.584Z</published>
    <updated>2021-08-30T06:12:16.537Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><h3 id="安装Apache-1"><a href="#安装Apache-1" class="headerlink" title="安装Apache"></a>安装Apache</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure><h3 id="设置全局Server-Name消除警告"><a href="#设置全局Server-Name消除警告" class="headerlink" title="设置全局Server Name消除警告"></a>设置全局Server Name消除警告</h3><p>使用下面的语句检查配置时会有警告信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apache2ctl configtest</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure><p>在文件的最后一行添加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerName server_domain_or_public_IP</span><br></pre></td></tr></table></figure></p><p>测试是否还有警告信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apache2ctl configtest</span><br></pre></td></tr></table></figure></p><p>重启Apache使修改生效：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure></p><h3 id="调整防火墙"><a href="#调整防火墙" class="headerlink" title="调整防火墙"></a>调整防火墙</h3><p>确保ufw有Apache的应用配置文件，能够看到Apache, Apache Full, Apache Secure：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app list</span><br></pre></td></tr></table></figure><p>如果查看Apache Full的应用配置文件，应该看到它允许到80和443端口流量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app info &quot;Apache Full&quot;</span><br></pre></td></tr></table></figure><p>允许进入流量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow in &quot;Apache Full&quot;</span><br></pre></td></tr></table></figure><p>测试，如果可以看到默认页面则成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your_server_IP_address</span><br></pre></td></tr></table></figure><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure><p>安装完成后，运行一个简单的安全脚本，它将删除一些危险的默认值并锁定对数据库系统的访问，运行以下命令启动交互式脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>登录数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><h3 id="安装PHP-1"><a href="#安装PHP-1" class="headerlink" title="安装PHP"></a>安装PHP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php libapache2-mod-php php-mcrypt php-mysql</span><br></pre></td></tr></table></figure><p>(可选)改变客户端从服务器查找文件顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apache2/mods-enabled/dir.conf</span><br></pre></td></tr></table></figure><p>原：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">    DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">    DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>重启Apache服务生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure><p>使用下面的命令可以查看Apache状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status apache2 </span><br></pre></td></tr></table></figure><p>安装额外模块：<br>分页查看PHP模块和库的可用选项，使用箭头键向上和向下滚动，按q退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search php- | less</span><br></pre></td></tr></table></figure><p>查看某个包的长描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache show package_name</span><br></pre></td></tr></table></figure><p>安装某个(些)包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install package_name package_name2 package_name3 ...</span><br></pre></td></tr></table></figure><h3 id="测试PHP处理"><a href="#测试PHP处理" class="headerlink" title="测试PHP处理"></a>测试PHP处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /var/www/html/info.php</span><br></pre></td></tr></table></figure><p>在文件中写一段PHP代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your_server_IP_address/info.php</span><br></pre></td></tr></table></figure><p>删除测试文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/www/html/info.php</span><br></pre></td></tr></table></figure><h2 id="使用Let加密保护Apache"><a href="#使用Let加密保护Apache" class="headerlink" title="使用Let加密保护Apache"></a>使用Let加密保护Apache</h2><h3 id="安装Let的加密客户端"><a href="#安装Let的加密客户端" class="headerlink" title="安装Let的加密客户端"></a>安装Let的加密客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install python-certbot-apache</span><br></pre></td></tr></table></figure><h3 id="设置SSL证书"><a href="#设置SSL证书" class="headerlink" title="设置SSL证书"></a>设置SSL证书</h3><p>对于单个域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --apache -d example.com</span><br></pre></td></tr></table></figure><p>对于多个域，第一个参数为基本域，后面的为子域名或者别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --apache -d example.com -d www.example.com</span><br></pre></td></tr></table></figure><p>生成的证书文件位置<code>/etc/letsencrypt/live</code>。链接验证SSL证书的状态（不要忘记将example.com替换为您的基本域）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.ssllabs.com/ssltest/analyze.html?d=example.com&amp;latest</span><br></pre></td></tr></table></figure><h3 id="自动续订"><a href="#自动续订" class="headerlink" title="自动续订"></a>自动续订</h3><p>加密证书只有90天有效期，之后需要续订。下面是自动续订</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot renew --dry-run</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-16-04">How To Install Linux, Apache, MySQL, PHP (LAMP) stack on Ubuntu 16.04</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-ubuntu-16-04">How To Secure Apache with Let’s Encrypt on Ubuntu 16.04</a></p>]]></content>
    
    
    <summary type="html">Linux + Apache + Mysql + PHP</summary>
    
    
    
    
    <category term="Linux" scheme="https://wheliosc.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>机器学习与数据挖掘</title>
    <link href="https://wheliosc.github.io/mldm.html"/>
    <id>https://wheliosc.github.io/mldm.html</id>
    <published>2020-12-19T13:03:16.535Z</published>
    <updated>2021-08-30T08:41:15.804Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="0-什么是数据挖掘"><a href="#0-什么是数据挖掘" class="headerlink" title="0. 什么是数据挖掘"></a>0. 什么是数据挖掘</h2><p>数据挖掘是从大量数据中挖掘出有趣模式和知识的过程或方法，其中涉及机器学习、统计数据和数据库系统交叉处的方法。</p><h2 id="1-数据中的知识发现包括哪几个步骤"><a href="#1-数据中的知识发现包括哪几个步骤" class="headerlink" title="1. 数据中的知识发现包括哪几个步骤"></a>1. 数据中的知识发现包括哪几个步骤</h2><ul><li>business understanding（业务理解）</li><li>data understanding（数据理解）</li><li>data preparation（数据准备）</li><li>modeling（建模）</li><li>evaluation（评估）</li><li>development（部署）</li></ul><h2 id="2-数据挖掘的应用"><a href="#2-数据挖掘的应用" class="headerlink" title="2. 数据挖掘的应用"></a>2. 数据挖掘的应用</h2><p>商务智能、Web搜索、生物信息学、卫生保健信息学、金融、数字图书馆和数字政府等。</p><h1 id="第二章-学习的可行性"><a href="#第二章-学习的可行性" class="headerlink" title="第二章 学习的可行性"></a>第二章 学习的可行性</h1><h2 id="1-Hoeffding’s-Inequality（霍夫汀不等式）"><a href="#1-Hoeffding’s-Inequality（霍夫汀不等式）" class="headerlink" title="1. Hoeffding’s Inequality（霍夫汀不等式）"></a>1. Hoeffding’s Inequality（霍夫汀不等式）</h2><p>$P(| v- \mu | &gt; \epsilon) \leq 2 e^{-2 \epsilon^2 N}$</p><p>霍夫丁不等式说明，抽样比例$v$与总体比例$\mu$的差距大于某个边距值$\epsilon$的概率，小于等于一个由$\epsilon$和样本大小$N$得到的关系式的值。</p><h2 id="2-用霍夫汀不等式说明学习的可行性"><a href="#2-用霍夫汀不等式说明学习的可行性" class="headerlink" title="2. 用霍夫汀不等式说明学习的可行性"></a>2. 用霍夫汀不等式说明学习的可行性</h2><p>在统计学中我们通过霍夫丁不等式来限定抽样集与总体集中的频率与概率关系。通过将其推广到机器学习中，可以得到类似的单个hypothesis的$E_{in}$与$E_{out}$差距限定不等式。然而当考虑到一组hypothesis数量多的假设集时，即使对单个hypothesis遇到bad data使其$E_{in}$与$E_{out}$差别比较大的概率十分低，但总体而言其中有一个或几个hypothesis遇到bad data使其$E_{in}$与$E_{out}$差别较大。我们将假设集中假设的数量$M$通过union bound引入不等式中，最终得到$P_D(BAD D) \leq 2M e^{-2 \epsilon^2 N}$。在<strong>有限的</strong>假设数量时，只要样本数量$N$足够，我们依然能让这组data保证取到的hypothesis的$E_{in}$与$E_{out}$差距不大，从而可以挑选$E_{in}$最小的hypothesis，也即$E_{out}$最小的hypothesis，作为结果。</p><h1 id="第三章-数据和数据预处理"><a href="#第三章-数据和数据预处理" class="headerlink" title="第三章 数据和数据预处理"></a>第三章 数据和数据预处理</h1><h2 id="1-属性类型和可进行的操作"><a href="#1-属性类型和可进行的操作" class="headerlink" title="1. 属性类型和可进行的操作"></a>1. 属性类型和可进行的操作</h2><div class="table-container"><table><thead><tr><th>属性类型</th><th>描述</th><th>操作</th><th>举例</th></tr></thead><tbody><tr><td>标称属性（nominal）</td><td>仅仅是不同的名字，用于区分属性（$=, \neq$）</td><td>众数，熵，列联相关，$\chi^2$检验</td><td>邮政编码，员工ID，性别</td></tr><tr><td>序数属性（ordinal）</td><td>序数属性的值可以确定对象的序（$&lt;, &gt;$）</td><td>中值，百分位</td><td>矿石硬度（好，较好，最好）</td></tr><tr><td>区间属性（interval）</td><td>值之间的差是有意义的（$+, -$）</td><td>均值，标准差，皮尔逊相关</td><td>日历日期，摄氏温度</td></tr><tr><td>比率属性（ratio）</td><td>差和比率都有意义（$\times, \div$）</td><td>几何平均，调和平均，百分比变差</td><td>质量，长度，绝对温度</td></tr></tbody></table></div><p>标称属性和序数属性统称为分类的或定性的属性，区间属性和比率属性统称为定量的或数值属性。</p><h2 id="2-非对称属性"><a href="#2-非对称属性" class="headerlink" title="2. 非对称属性"></a>2. 非对称属性</h2><p>属性只有两个类别或状态，用0和1编码。如果他的两种状态具有同等的价值并且有相同的权重，则称为对称的二元属性，比如男女性别。如果其状态的结果不是同样重要的，其中更关注1编码的结果（通常是稀疏的），称其为非对称的二元属性，比如covid-19核酸检测的阴阳性结果。</p><h2 id="3-相似性和相异性度量"><a href="#3-相似性和相异性度量" class="headerlink" title="3. 相似性和相异性度量"></a>3. 相似性和相异性度量</h2><h3 id="3-1-数据对象之间的相异度"><a href="#3-1-数据对象之间的相异度" class="headerlink" title="3.1 数据对象之间的相异度"></a>3.1 数据对象之间的相异度</h3><ul><li>欧几里得距离$d=\sqrt {\Sigma_{k=1}^{n}(p_k-q_k)^2}$。</li></ul><ul><li>闵可夫斯基距离$d=\lgroup \Sigma_{k=1}^{n}|(p_k-q_k)|^r\rgroup^{\frac{1}{r}}$是欧氏距离的推广。当$r=1$时，称为曼哈顿距离（$L_1$范数）；当$r=2$时，称为欧几里得距离（$L_2$范数）；当$r=\infty$时，称为切比雪夫距离（上确界距离，$L_{max}$范数，$L_\infty$范数），它是对象属性间的最大距离。</li></ul><ul><li>马氏距离$d_m(x) = \sqrt{(x-\mu) \Sigma^{-1} (x-\mu)^T}$，其中$x$是一个均值为$\mu$的协方差矩阵为$\Sigma$的多变量矢量。对两个服从统一分布并且协方差矩阵为$\Sigma$的变量（样本）$p$和$q$来说，其差异程度可以由马氏距离表示为$d_m(p,q)= \sqrt{(p-q) \Sigma^{-1} (p-q)^T}$。马氏距离排除了变量之间的相关性的干扰，且尺度无关（不受量纲影响）。</li></ul><h3 id="3-2-二元数据的相似性度量"><a href="#3-2-二元数据的相似性度量" class="headerlink" title="3.2 二元数据的相似性度量"></a>3.2 二元数据的相似性度量</h3><ul><li>简单匹配系数（SMC）：$SMC = \frac{f_{11}+f_{00}}{f_{00}+f_{10}+f_{01}+f_{11}}$</li></ul><ul><li>Jaccard系数：$J = \frac{f_{11}}{f_{10}+f_{01}+f_{11}}$</li></ul><ul><li>广义Jaccard系数（Tinamoto系数）：$EJ(p,q) = \frac{p \cdot q}{\parallel p \parallel ^2 + \parallel q \parallel ^2 - p \cdot q}$</li></ul><ul><li>余弦相似度：$cos(x,y) = \frac{x \cdot y}{\parallel p \parallel \times \parallel q \parallel}$</li></ul><ul><li>相关系数：$r(X, Y)=\frac{\operatorname{Cov}(X, Y)}{\sqrt{\operatorname{Var}[X] \operatorname{Var}[Y]}}$或$r(X, Y)=\frac{\operatorname{Cov}(X, Y)}{\sigma_X \sigma_Y}$。</li></ul><h3 id="3-3-组合异种属性的相似度"><a href="#3-3-组合异种属性的相似度" class="headerlink" title="3.3 组合异种属性的相似度"></a>3.3 组合异种属性的相似度</h3><ul><li>在第$k$个属性上，计算相似度$s_k(p,q)$，在区间$[0,1]$中。</li></ul><ul><li>对于第$k$个属性，定义一个指示变量$\delta_k$，如果第$k$个属性是非对称属性，并且两个对象在该属性的值都是0，或者如果有一个对象的第$k$个属性具有缺失值，则$\delta_k = 0$，否则$\delta_k = 1$。</li></ul><ul><li>总相似度为$similarity(p,q) = \frac{\Sigma_{k=1}^{n}\delta_k s_k (p,q)}{\Sigma_{k=1}^{n}\delta_k}$。</li></ul><ul><li>当某些属性更重要时，可以使用不同权值对不同属性的相似度进行加权，则上式变为$similarity(p,q) = \frac{\Sigma_{k=1}^{n} w_k \delta_k s_k (p,q)}{\Sigma_{k=1}^{n}\delta_k}$。</li></ul><h2 id="4-数据预处理"><a href="#4-数据预处理" class="headerlink" title="4. 数据预处理"></a>4. 数据预处理</h2><p>主要任务：数据清理（data cleaning）、数据集成（data integration）、数据规约（data reduction）、数据变换（data transformation）、数据离散化（data discretization）。</p><h3 id="4-1-数据清理"><a href="#4-1-数据清理" class="headerlink" title="4.1 数据清理"></a>4.1 数据清理</h3><h4 id="4-1-1-填充缺失值（missing-data）"><a href="#4-1-1-填充缺失值（missing-data）" class="headerlink" title="4.1.1 填充缺失值（missing data）"></a>4.1.1 填充缺失值（missing data）</h4><ul><li>忽略元组</li><li>人工填写缺失值</li><li>使用一个全局常量填充缺失值</li><li>使用属性的中心度量（如均值和中位数）填充缺失值</li><li>使用与给定元组属同一类的所有样本的属性均值或中位数填充缺失值</li><li>使用最可能的值填充缺失值</li></ul><h4 id="4-1-2-光滑噪声（noise）"><a href="#4-1-2-光滑噪声（noise）" class="headerlink" title="4.1.2 光滑噪声（noise）"></a>4.1.2 光滑噪声（noise）</h4><ul><li><p>分箱（binning）</p><ul><li>等宽分箱：将变量的取值范围分为$k$个等宽的区间，每个区间当作一个分箱。</li><li>等频（深）分箱：分为$k$个区间，每个区间中的样本数大体相同。</li><li>分箱之后，可以使用箱均值平滑，箱中位数平滑，箱边界平滑（箱中的每一个值取离它最近的边界值，即最大值或最小值，与最小值的差小则取最小值，与最大值的差小则取最大值）。</li></ul></li><li><p>回归（regression）</p><ul><li>用一个函数拟合数据来光滑数据</li></ul></li></ul><h4 id="4-1-3-识别离群点（outlier）"><a href="#4-1-3-识别离群点（outlier）" class="headerlink" title="4.1.3 识别离群点（outlier）"></a>4.1.3 识别离群点（outlier）</h4><ul><li><p>聚类（cluster）</p><ul><li>落在簇之外的值为离群点</li></ul></li><li><p>曲线拟合</p></li><li>给定模型上的假设检验</li></ul><h4 id="4-1-4-纠正数据中的不一致"><a href="#4-1-4-纠正数据中的不一致" class="headerlink" title="4.1.4 纠正数据中的不一致"></a>4.1.4 纠正数据中的不一致</h4><h3 id="4-2-数据集成"><a href="#4-2-数据集成" class="headerlink" title="4.2 数据集成"></a>4.2 数据集成</h3><p>数据集成将多个数据源的数据合并，存放在一个一致的数据存储中，如数据仓库中。</p><h4 id="4-2-1-实体识别问题"><a href="#4-2-1-实体识别问题" class="headerlink" title="4.2.1 实体识别问题"></a>4.2.1 实体识别问题</h4><p>数据分析者或计算机如何才能确信一个数据库中的某个属性与另一个数据库中的某个属性指的是相同的属性。</p><h4 id="4-2-2-冗余和相关分析"><a href="#4-2-2-冗余和相关分析" class="headerlink" title="4.2.2 冗余和相关分析"></a>4.2.2 冗余和相关分析</h4><p>一个属性如果可以由另一个或另一组属性导出，则这个属性可能就是冗余的。有些冗余可以被相关分析检测到。对于分类的属性，使用$\chi ^2$（卡方）检验。对于数值属性（numerical），使用相关系数和协方差。</p><ul><li><p>$\chi ^2检验$</p><ul><li>假设对两个属性$A$和$B$，$A$有$c$个不同的值，$B$有$r$个不同的值，可以得到一个$c \times r$的列联表。令$(A_i,B_j)$表示属性$A$取值$a_i$、属性$B$取值$b_j$的联合事件，$\chi ^2$值可以通过公式计算</li><li>$\chi ^2 = \Sigma_{i=1}^{c} \Sigma_{j=1}^{r} \frac{(o_{ij} - e_{ij})^2}{e_{ij}}$。其中，$o_{ij}$是联合事件$(A_i,B_j)$的观测频度（即实际计数），$e_{ij}$是$(A_i,B_j)$的期望频度。</li><li>$e_{ij}$的计算公式为$e_{ij} = \frac{count(A=a_i) \times count(B=b_j)}{n}$。其中，$n$是元组的个数，$count(A=a_i)$是$A$上具有值$a_i$的元组个数，$count(B=b_j)$是$B$上具有值$b_i$的元组个数。</li><li>对卡方值贡献最大的单元是实际计数和期望计数很不相同的单元。</li><li>卡方检验假设$A$和$B$是独立的，检测基于显著水平，具有自由度$(c-1) \times (r-1)$。</li></ul></li><li><p>协方差</p><ul><li>$cov(A,B) = E((A-\overline{A})(B-\overline{B})) = \frac{\Sigma_{i=1}^{n} (a_i - \overline{A}) ((b_i - \overline{B})}{n} = E(A \cdot B) - \overline{A} \overline{B}$</li></ul></li><li><p>相关系数（皮尔森相关系数）</p><ul><li>公式为$r_{A,B} = \frac{\Sigma_{i=1}^{n} (a_i - \overline{A}) ((b_i - \overline{B})}{n \sigma_A \sigma_B}=\frac{\Sigma_{i=1}^{n} (a_i b_i) - n \overline{A} \overline{B}}{n \sigma_A \sigma_B}$</li><li>通过协方差的定义，相关系数公式还可以写为$r_{A,B}=\frac{\operatorname{Cov}(A, B)}{\sigma_A \sigma_B}$</li><li>$r_{A,B} \in [-1,+1]$。如果$r_{A,B}&gt;0$，则$A$和$B$是正相关的，该值越大，相关性越强。如果$r_{A,B}=0$，则$A$和$B$是不相关的。</li><li>独立可推出不相关，但不相关并不能推出独立。不相关是指两个随机变量没有近似的线性关系，而独立是指两个变量没有任何关系。</li></ul></li></ul><h3 id="4-3-数据归约"><a href="#4-3-数据归约" class="headerlink" title="4.3 数据归约"></a>4.3 数据归约</h3><p>数据归约可以得到数据集的简约表示，它小得多，在规约后的数据集上挖掘将产生相同或几近相同的分析结果。</p><p>可以使用的策略：数据聚合（data aggregation）、数据压缩（data compression）、数量规约（numerosity reduction）、维归约（dimensionality reduction）、离散化和概念层次生成（Discretization and concept hierarchy generation）等。</p><h4 id="4-3-1-数据聚合"><a href="#4-3-1-数据聚合" class="headerlink" title="4.3.1 数据聚合"></a>4.3.1 数据聚合</h4><p>把两个或者多个属性组合成单个属性。</p><h4 id="4-3-2-数据压缩"><a href="#4-3-2-数据压缩" class="headerlink" title="4.3.2 数据压缩"></a>4.3.2 数据压缩</h4><p>使用变换得到原数据的规约表示或压缩表示。如果原数据可以从压缩后的数据中重构而不损失信息则称该数据归约是无损的，如果只能近似的重构原数据，则该数据归约称为有损的。</p><h4 id="4-3-3-数量规约"><a href="#4-3-3-数量规约" class="headerlink" title="4.3.3 数量规约"></a>4.3.3 数量规约</h4><p>用替代的、较小的数据表示替换原数据，分为参数化方法和非参数化方法。参数方法使用模型估计数据，因此只需要存放模型参数（离群点可能也需要存放），回归模型就是一个例子。非参数化方法包括直方图（histograms）、聚类（clustering）、抽样（sampling）等。</p><h4 id="4-3-4-维归约"><a href="#4-3-4-维归约" class="headerlink" title="4.3.4 维归约"></a>4.3.4 维归约</h4><h3 id="4-4-数据变换与数据离散化"><a href="#4-4-数据变换与数据离散化" class="headerlink" title="4.4 数据变换与数据离散化"></a>4.4 数据变换与数据离散化</h3><p>数据变换策略包括：光滑（smoothing）、属性构造、聚集、规范化、离散化等。数据预处理任务之间存在着重叠，因此这一部分只讨论规范化和离散化。</p><h4 id="4-4-1-规范化"><a href="#4-4-1-规范化" class="headerlink" title="4.4.1 规范化"></a>4.4.1 规范化</h4><p>规范化可以避免对度量单位选择的依赖性。对于基于距离的方法，规范化可以帮助防止具有较大初始值域的属性和具有较小初始值域的属性相比权重过大。</p><ul><li><p>最小-最大规范化</p><ul><li>假设$min_A$和$max_A$是属性$A$的最小值和最大值，要将属性$A$规范化到区间$[ new _ min_A, new _ max_A]$中，$a_i$的规范后结果为</li><li>$a_i \prime = \frac{a_i - min_A}{max_A - min_A} \times (new _ max_A - new _ min_A) + new _ min_A$</li></ul></li><li><p>$z-score$规范化</p><ul><li>$a_i \prime = \frac{a_i - \overline{A}}{\sigma_A}$</li></ul></li><li><p>小数定标规范化</p><ul><li>$a_i \prime = \frac{a_i}{10^j}$，其中$j$是使得$max(|a_i \prime |)&lt;1$的最小整数。</li></ul></li></ul><h4 id="4-4-2-离散化"><a href="#4-4-2-离散化" class="headerlink" title="4.4.2 离散化"></a>4.4.2 离散化</h4><p>对数值数据进行离散化，根据不同的标准可以划分为监督的和非监督的、自顶向下的和自底向上的（分裂的和合并的）。</p><p>常用的方法有：</p><ul><li>直方图分析（自顶向下的，分裂的，非监督的）</li><li>聚类分析（自顶向下的或自底向上的、分裂的或合并的，非监督的）</li><li>基于熵的离散化（自顶向下的，分裂的，监督的）</li><li>通过$\chi ^2$分析合并区间（<strong>自底向上的</strong>，合并的，监督的）</li><li>自然分割（自顶向下的，分裂的，非监督的）<ul><li>3-4-5规则可以用于将数值数据划分成相对一致、“自然的”区间。一般地，该规则根据最重要的数字上（比如数字的最高位）的值区域，递归地、逐层地将给定的数据区域划分为3、4 或5 个等长的区间。</li><li>以最高位数字举例来说，如果在所有数字的最高位覆盖3, 6, 7或9个不同的值，则将数据分成3段；如果在所有数字的最高位覆盖2, 4, 8个不同的值，则将数据分成4段；如果在所有数字的最高位覆盖1, 5, 10个不同的值，则将数据分成5段。</li></ul></li></ul><h1 id="第四章-决策树学习"><a href="#第四章-决策树学习" class="headerlink" title="第四章 决策树学习"></a>第四章 决策树学习</h1><h2 id="1-决策树学习的基本思想"><a href="#1-决策树学习的基本思想" class="headerlink" title="1. 决策树学习的基本思想"></a>1. 决策树学习的基本思想</h2><p>决策树是一个树结构，其每一个非叶节点表示一个属性上的测试，每个分支代表该测试的一个输出，每个叶节点存放一个类别。决策树学习的基本思想是对所有的属性进行评估，选择一个最好的属性作为树的根节点，然后为该属性的每个可能值创建划分节点，并将数据集按取值划分到不同的节点上，然后用与每个子结点相关联的训练实例重复整个过程，以选择树中该点处要测试的最佳属性。</p><h2 id="2-如何选择最佳划分"><a href="#2-如何选择最佳划分" class="headerlink" title="2. 如何选择最佳划分"></a>2. 如何选择最佳划分</h2><p>为了决定一个最佳划分，需要对节点进行不纯性度量，理想的情况是每个分区应当是纯的（落在一个给定分区的所有元组都属于相同的类）。</p><p>不纯性度量包括基尼（Gini Index）指数、熵（Entropy）和分类错误率（Misclassification error）等。</p><ul><li><p>基尼指数</p><ul><li>一个节点的基尼指数定义为$Gini(node) = 1 - \Sigma_{i=1}^{n} p_i^2$，其中$p_i$是$node$中元组属于$Class_i$类的概率。</li><li>如果将一个节点$D$分裂成了$k$个部分（子节点），对这个划分来说，$D$的基尼指数为$Gini_{split}(D) = \Sigma_{i=1}^{k} \frac{n_i}{n}Gini(i)$，其中$n_i$是属于某一个子节点的元组的个数，$n$是属于节点$D$的元组数。</li><li>对于离散属性来说，选择分裂后的基尼指数小于未分裂的基尼指数且基尼指数最小的划分。</li><li>对于连续属性来说，对属性的可能取值进行排序，然后将每对相邻值的中点作为可能的分裂点，如果是二元划分，则选择产生最小基尼指数的点作为该属性的分裂点。对于分裂点$split _ point$来说，它产生的两个数据子集是$\leq split _ point$和$&gt; split _ point$。</li><li>基尼指数应用于CART（Classification and Regression Trees）算法中。</li></ul></li><li><p>熵</p><ul><li>$Entropy(node) = - \Sigma_{i=1}^{n} p_i log_2(p_i)$，其中$p_i$是$node$中元组属于$Class_i$类的概率。</li><li>熵越大表示区分类别需要的信息越多，则节点内的纯度越低。</li><li>信息增益：$Gain_{split}(A) = Entropy(node) - (\Sigma_{i=1}^k \frac{n_i}{n} Entropy(i))$，表示将一个节点按属性$A$分为$k$个部分后得到的信息增益，选择具有最大信息增益的属性进行划分。信息增益应用于ID3算法中。（倾向于产生大量的分区，使每一个值有一个分区，这样每一个分区都是纯的，但这种划分没用。）</li><li>信息增益率：$GainRate(A) = \frac{Gain(A)}{SplitInfo_A(D)}$，其中$SplitInfo_A(D) = -\Sigma_{i=1}^k \frac{n_i}{n} log_2(\frac{n_i}{n})$。信息增益率应用于C4.5算法中。</li></ul></li><li><p>分类错误率</p><ul><li>$Error = 1 - max(p_i)$，其中$p_i$是$node$中元组属于$Class_i$类的概率。</li></ul></li></ul><h2 id="3-过拟合和欠拟合"><a href="#3-过拟合和欠拟合" class="headerlink" title="3. 过拟合和欠拟合"></a>3. 过拟合和欠拟合</h2><ul><li><p>过拟合</p><ul><li>过拟合是指模型把数据学习的太彻底，以至于把噪声或没有代表性的数据的特征也学习到了，这样就会导致在后期测试的时候不能够很好的识别数据，即不能正确的分类，模型的泛化能力差。</li><li>引起过拟合的原因包括数据集中有噪声数据或训练样例太少以至于不能产生目标函数的有代表性的采样。</li><li>解决决策树学习中过拟合的方法：预剪枝（及早停止树增长）和后剪枝（允许树过度拟合数据，之后对树进行修剪）。</li></ul></li><li><p>欠拟合</p><ul><li>欠拟合是指模型的拟合程度不高，模型没有很好地捕捉到数据特征，不能够很好地拟合数据。</li></ul></li></ul><h2 id="4-缺失值对决策树的影响"><a href="#4-缺失值对决策树的影响" class="headerlink" title="4. 缺失值对决策树的影响"></a>4. 缺失值对决策树的影响</h2><p>决策树对缺失值不敏感。</p><ul><li>删除有缺失值的数据，或者不考虑有缺失值的属性来生成决策树。</li><li>默认将含有缺失值的实例划分到某一子树。</li></ul><h2 id="5-混淆矩阵（confusion-matrix）"><a href="#5-混淆矩阵（confusion-matrix）" class="headerlink" title="5. 混淆矩阵（confusion matrix）"></a>5. 混淆矩阵（confusion matrix）</h2><p>简记Actual Class为AC，Predicted Class为PC</p><ul><li>TP: (true positive)  AC=yes, PC=yes</li><li>FN: (false negative) AC=yes, PC=no</li><li>FP: (fasle positive) AC=no, PC=yes</li><li>TN: (true negative)  AC=no, PC=no</li></ul><p>准确率：$Accuracy = \frac{TP+TN}{TP+FN+FP+TN}$</p><p>精确率：$Precision = \frac{TP}{TP+FP}$</p><p>召回率：$Recall = \frac{TP}{TP+FN}$</p><p>$F_1$分数：$F_1 = 2 \times \frac{Precision \times Recall}{Precision + Recall}$</p><h2 id="6-评估分类器性能的方法"><a href="#6-评估分类器性能的方法" class="headerlink" title="6. 评估分类器性能的方法"></a>6. 评估分类器性能的方法</h2><ul><li>保持方法（holdout），将数据集按比例划分为不相交的训练集和验证集</li><li>随机二次抽样（random subsampling），多次重复保持方法</li><li>交叉验证（cross validation）<ul><li>$k$折交叉验证，把数据集分为大小相同的$k$份，在每次运行时，选择其中的一份作为验证集，而其余的全作为训练集，该过程重复$k$次，使得每份数据都用于验证恰好一次。</li><li>多次$k$折交叉验证，将$k$折交叉验证重复多次，比如十次十折交叉验证。</li><li>留一法（leave-one-out），令$k$为数据集的大小，验证集中只有一个记录。优点是使用尽可能多的训练数据并且有效的覆盖了整个数据集；缺点是整个过程重复数据集大小次数，计算开销大，而且由于验证集中只有一个记录，所以性能估计的方差较大。</li></ul></li><li>分层抽样（stratified sampling）</li><li>自助法（bootstrap）</li></ul><p>ROC曲线，横坐标为假阳率$FPR = \frac{FP}{N}$，纵坐标为真阳率$TPR = \frac{TP}{P}$。AUC面积是ROC曲线下的面积，ROC曲线一般位于$y=x$之上，所以AUC取值一般在$0.5 \sim 1$之间，值越大说明模型的性能越好。</p><h1 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h1><h2 id="1-神经网络如何学习"><a href="#1-神经网络如何学习" class="headerlink" title="1. 神经网络如何学习"></a>1. 神经网络如何学习</h2><p>神经网络通过调整权值进行学习，从而能够正确的对训练数据进行分类，然后在测试阶段对未知数据进行分类。</p><p>特点：</p><ul><li>神经网络需要很长时间的训练。</li><li>神经网络对噪声数据和不完整数据有很高的容忍度。</li><li>神经网络的可解释性较差。</li></ul><h2 id="2-梯度下降算法"><a href="#2-梯度下降算法" class="headerlink" title="2. 梯度下降算法"></a>2. 梯度下降算法</h2><hr><ul><li>初始化每个$w_i$为某个小的随机值</li><li>遇到终止条件之前做以下操作<ul><li>初始化每个$\Delta w_i$为0</li><li>对于每个训练样例$(\vec{x}, t)$，做<ul><li>把实例$\vec{x}$输入到此单元，计算输出$o$</li><li>对于线性单元的每个权$w_i$做：$\Delta w_i \leftarrow \Delta w_i + \eta(t-o) x_i$</li></ul></li><li>对于线性单元的每个权$w_i$，做$w_i \leftarrow w_i + \Delta w_i$</li></ul></li></ul><hr><p>批量梯度下降（BGD）：在每一次迭代时计算完所有的样本后进行梯度的更新。</p><p>随机梯度下降（SGD）：在每一次迭代时每计算完一个样本后都进行梯度的更新。</p><h2 id="3-反向传播算法（BP算法）"><a href="#3-反向传播算法（BP算法）" class="headerlink" title="3. 反向传播算法（BP算法）"></a>3. 反向传播算法（BP算法）</h2><p>逐层求出目标函数对各神经元权值的偏导数，构成目标函数对权值向量的梯度，作为修改权值的依据，网络的学习在权值修改过程中完成。误差达到所期望值时，网络学习结束。</p><h1 id="第六章-贝叶斯分类方法"><a href="#第六章-贝叶斯分类方法" class="headerlink" title="第六章 贝叶斯分类方法"></a>第六章 贝叶斯分类方法</h1><h2 id="1-根据贝叶斯理论，如何计算一个假设h成立的后验概率？"><a href="#1-根据贝叶斯理论，如何计算一个假设h成立的后验概率？" class="headerlink" title="1. 根据贝叶斯理论，如何计算一个假设h成立的后验概率？"></a>1. 根据贝叶斯理论，如何计算一个假设h成立的后验概率？</h2><p>$P(h|D) = \frac{P(D|h)P(h)}{P(D)}$</p><ul><li>$P(h)$和$P(D)$是先验概率， $P(h)$表示假设 $h$是一个正确假设的概率，$P(D)$表示在没有确定某一假设成立时$D$的概率。</li><li>$P(D|h)表示假设$h$成立的情况下，观察到数据$D$的概率。</li><li>$P(h|D)$是要求的后验概率，即给定数据集$D$上，$h$成立的概率。</li></ul><h2 id="2-极大后验假设和极大似然假设"><a href="#2-极大后验假设和极大似然假设" class="headerlink" title="2. 极大后验假设和极大似然假设"></a>2. 极大后验假设和极大似然假设</h2><ul><li><p>极大后验假设（MAP）</p><ul><li>在假设集$H$中寻找给定数据集$D$时，最可能的假设$h$，这样具有最大可能性的假设称为极大后验假设，$h_{MAP} = \underset{h \in H}{\arg \max } P(D \mid h) P(h)$。</li></ul></li><li><p>极大似然假设（ML）</p><ul><li>假定$H$中每个假设具有相同的先验概率，使$P(D \mid h)$最大的假设称为极大似然假设，$h_{ML} = \underset{h \in H}{\arg \max } P(D \mid h)$。</li></ul></li></ul><h2 id="3-最小描述长度的基本思想"><a href="#3-最小描述长度的基本思想" class="headerlink" title="3. 最小描述长度的基本思想"></a>3. 最小描述长度的基本思想</h2><p>为随机传送的消息设计一个编码，其中遇到消息$i$的概率为$p_i$，为了传输随机消息所需的传送位数最小，需要为可能性较大的消息赋予较短的编码。用最小描述长度解释极大后验假设就是使假设描述长度和给定假设下数据描述长度之和最小化的假设。$h_{max} = \underset{h \in H}{\arg \min } L_{C_H}(h) L_{C_{D \mid h}}(h)$，其中$C_H$和$C_{D \mid h}$是$H$的最优编码和给定$h$时$D$的最优编码。</p><h2 id="4-贝叶斯最优分类器"><a href="#4-贝叶斯最优分类器" class="headerlink" title="4. 贝叶斯最优分类器"></a>4. 贝叶斯最优分类器</h2><p>新实例的最可能分类可通过合并所有假设的预测得到，用后验概率加权。如果新实例的可能分类可取集合$V$中的任一值$v_j$，那么概率$P(v_j \mid D)$表示新实例的正确分类为$v_j$的概率：$P(v_j \mid D) = \Sigma_{h_i \in H} P(v_j \mid h_i)P(h_i \mid D)$。新实例的最优分类为使$P(v_j \mid D)$最大的$v_j$值，即$\underset{v_j \in V}{\arg \max } \Sigma_{h_i \in H} P(v_j \mid h_i)P(h_i \mid D)$。</p><p>贝叶斯最优分类器开销很大，需要计算每个假设的后验概率，一个可替代的、非最优的方法是Gibbs算法：按照当前的后验概率分布使用一随机抽取的假设。Gibbs算法的误分类率的期望值最多为贝叶斯最优分类器的两倍。</p><h2 id="5-朴素贝叶斯分类器"><a href="#5-朴素贝叶斯分类器" class="headerlink" title="5. 朴素贝叶斯分类器"></a>5. 朴素贝叶斯分类器</h2><p>贝叶斯方法的新实例的分类目标是在给定描述实例的属性值$<a_1,a_2,...,a_n>$下，得到最可能的目标值$v_{MAP} = \underset{v_j \in V}{\arg \max } P(v_j \mid a_1,a_2,…,a_n)$，利用贝叶斯公式可以重写为$v_{MAP} = \underset{v_j \in V}{\arg \max } \frac{P(a_1,a_2,…,a_n \mid v_j)P(v_j)}{P(a_1,a_2,…,a_n)}=\underset{v_j \in V}{\arg \max } P(a_1,a_2,…,a_n \mid v_j)P(v_j)$。</p><p>朴素贝叶斯方法就是假设给定目标值时属性值之间相互条件独立，即$P(a_1,a_2,…,a_n \mid v_j) = \prod_{i=1}^n P(a_i \mid v_j)$。朴素贝叶斯使用的方法即为$v_{NB} = \underset{v_j \in V}{\arg \max } \prod_{i=1}^n P(a_i \mid v_j) P(v_j)$。</p><h2 id="6-贝叶斯信念网络的预测与诊断"><a href="#6-贝叶斯信念网络的预测与诊断" class="headerlink" title="6. 贝叶斯信念网络的预测与诊断"></a>6. 贝叶斯信念网络的预测与诊断</h2><h2 id="7-偏差-方差分析"><a href="#7-偏差-方差分析" class="headerlink" title="7. 偏差-方差分析"></a>7. 偏差-方差分析</h2><h1 id="第七章-基于实例的学习"><a href="#第七章-基于实例的学习" class="headerlink" title="第七章 基于实例的学习"></a>第七章 基于实例的学习</h1><h2 id="1-k近邻学习算法"><a href="#1-k近邻学习算法" class="headerlink" title="1. k近邻学习算法"></a>1. k近邻学习算法</h2><p>假定所有的实例对应于n维空间$R^n$中的点，一个实例的最近邻是根据标准欧式距离定义的。在最近邻学习中，目标函数值可以是离散值也可以是实值。</p><hr><p>训练算法：</p><ul><li>对于每个训练样例$<x,f(x)>$，把这个样例加入列表$training _ examples$</li></ul><p>分类算法：</p><ul><li>给定一个要分类的查询实例$x_q$<ul><li>在$training _ examples$中选出最靠近$x_q$的$k$个实例，并用$x_1,x_2,…,x_k$表示</li><li>返回$\hat{f}(x_q) \leftarrow \underset{v \in V}{\arg \max } \Sigma_{i=1}^{k} \delta(v,f(x_i))$</li></ul></li></ul><p>其中，如果a=b，那么$\delta(a,b) = 1$，否则$\delta(a,b) = 0$。在实值目标函数中将公式变为$\hat{f}(x_q) \leftarrow \frac{\Sigma_{i=1}^{k} f(x_i)}{k}$。</p><hr><p>距离加权最近邻算法：将较大的权值赋给较近的近邻。</p><ul><li>$\hat{f}(x_q) \leftarrow \underset{v \in V}{\arg \max } \Sigma_{i=1}^{k} w_i \delta(v,f(x_i))$</li><li>$\hat{f}(x_q) \leftarrow \frac{\Sigma_{i=1}^{k} w_i f(x_i)}{\Sigma_{i=1}^{k} w_i}$</li></ul><h2 id="2-k近邻学习时为什么距离要归一化"><a href="#2-k近邻学习时为什么距离要归一化" class="headerlink" title="2. k近邻学习时为什么距离要归一化"></a>2. k近邻学习时为什么距离要归一化</h2><p>如果各个维度的量纲差距很大，那么在计算距离时模长大的维度会支配模长小的维度，造成距离失去意义。</p><h2 id="3-局部加权线性回归"><a href="#3-局部加权线性回归" class="headerlink" title="3. 局部加权线性回归"></a>3. 局部加权线性回归</h2><p>给定一个新的查询实例$x_q$，局部加权回归的一般做法是建立一个逼近$\hat{f}$，使$\hat{f}$拟合环绕$x_q$的邻域内的训练样例。然后用这个逼近来计算$\hat{f} (x_q)$的值，也就是为查询实例估计的目标值输出。</p><ul><li>误差函数为$E(x_{q}) = \frac{1}{2} \sum (f(x)-\hat{f}(x))^{2} K(d(x_{q}, x))$，其中$x$是$x_q$的$k$个近邻，$K(d(x_{q}, x))$是权值，是关于相距$x_q$距离的某个递减函数$K$。</li><li>训练法则为$\Delta w_{i}=\eta \sum K(d(x_{q}, x))(f(x)-\hat{f}(x)) a_{j}(x)$，其中$x$是$x_q$的$k$个近邻，$a_j(x)$是$x$的第$j$个属性。</li></ul><h2 id="4-基于案例的推理（CBR）与k-NN的异同"><a href="#4-基于案例的推理（CBR）与k-NN的异同" class="headerlink" title="4. 基于案例的推理（CBR）与k-NN的异同"></a>4. 基于案例的推理（CBR）与k-NN的异同</h2><p>同：</p><ul><li>都是懒惰学习的方法，把在训练数据之外的泛化推迟到遇到一个新的查询实例进行。</li><li>通过分析相似的实例来分类新的查询实例，忽略与查询极其不同的实例。</li></ul><p>异：</p><ul><li>CBR不把实例表示为n维空间中的实数点，而是采用更丰富的符号描述。</li><li>CBR检索相似实例的方法更加复杂。</li><li>CBR合并多个检索到的案例的过程与k-NN有很大的不同，它依赖于知识推理而不是统计方法。</li></ul><h2 id="5-懒惰学习与积极学习的区别"><a href="#5-懒惰学习与积极学习的区别" class="headerlink" title="5. 懒惰学习与积极学习的区别"></a>5. 懒惰学习与积极学习的区别</h2><p>懒惰（消极）学习：延迟了如何从训练数据中泛化的决策，直到遇到一个新的查询实例时才进行泛化。懒惰学习<strong>可以</strong>通过很多局部逼近的组合表示目标函数（局部逼近或全局逼近）。懒惰学习在训练时需要较少的计算，但在预测新查询的目标值时需要较多的计算时间。</p><p>积极学习：在见到新的查询之前就做好了泛化的工作。积极学习<strong>必须</strong>在训练时提交单个的全局逼近（必须全局逼近）。积极学习在训练时需要较多的时间，在预测新查询的目标值时需要较少的时间。</p><h1 id="第八章-集成学习"><a href="#第八章-集成学习" class="headerlink" title="第八章 集成学习"></a>第八章 集成学习</h1><h2 id="1-集成学习的定义"><a href="#1-集成学习的定义" class="headerlink" title="1. 集成学习的定义"></a>1. 集成学习的定义</h2><p>集成学习是指将许多弱学习器组合起来以获得一个强学习器的技术。</p><h2 id="2-集成学习的两个主要问题"><a href="#2-集成学习的两个主要问题" class="headerlink" title="2. 集成学习的两个主要问题"></a>2. 集成学习的两个主要问题</h2><ul><li>如何产生基学习器（基学习器要尽量准确并且多样）</li><li>如何合并基学习器<ul><li>加权投票（Weighted voteing）</li><li>加权平均（Weighted averaging）</li><li>学习组合器（learning combiner）<ul><li>Stacking(Wolpert)</li><li>RegionBoost(Maclin)</li></ul></li></ul></li></ul><p>同质（homogeneous）集成：所有的个体学习器都是同一个种类的。</p><p>异质（heterogeneous）集成：所有的个体学习器不全是一个种类的。</p><h2 id="3-Stacking基本思想和伪代码"><a href="#3-Stacking基本思想和伪代码" class="headerlink" title="3. Stacking基本思想和伪代码"></a>3. Stacking基本思想和伪代码</h2><p>Stacking算法分为两层，第一层是用不同的算法（因此Stacking一般是异质集成）形成多个弱分类器，然后将其输出用于训练第二层的元分类器，使用元分类器对第一层分类器进行组合。</p><p>伪代码</p><hr><p><strong>Input:</strong></p><p>DataSet $D = {(x_1,y_1),(x_2,y_2),…,(x_m,y_m)}$</p><p>First-level learning algorithm $L_1, L_2,…,L_T$</p><p>second-level learning algorithm $L$</p><p><strong>Process:</strong></p><p>for $t = 1,…,T$:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;$h_t = L_t(D)$ &nbsp;&nbsp;%在数据集D上使用不同的学习算法训练第一层的分类器</p><p>end;</p><p>$D \prime = \emptyset$&nbsp;&nbsp;%创建一个新的数据集用来训练元分类器</p><p>for $i=1,…,m$:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;for $t = 1,…,T$:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$z_{it}=h_t(x_i)$&nbsp;&nbsp;%用$h_t$对实例$x_i$进行分类</p><p>&nbsp;&nbsp;&nbsp;&nbsp;end;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;$D \prime = D \prime \bigcup \lbrace ((z_{i1},z_{i2},…,z_{it}),y_i) \rbrace$</p><p>end;</p><p>$h \prime = L(D \prime)$ &nbsp;&nbsp;%在数据集$D \prime$上使用算法$L$训练元分类器$h \prime$</p><p><strong>Output:</strong></p><p>$H(x) = h \prime (h_1(x), h_2(x), …, h_T(x))$</p><hr><h2 id="4-Bagging基本思想和伪代码"><a href="#4-Bagging基本思想和伪代码" class="headerlink" title="4. Bagging基本思想和伪代码"></a>4. Bagging基本思想和伪代码</h2><p>对训练样本随机抽样，让基学习器在不同的训练集进行训练而得到不同的弱分类器，最后通过投票的方式或平均的方式进行集成。（同质集成）</p><p>伪代码</p><hr><p>Getting $L$ samples by bootstrap sampling</p><p>From whice we derive:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;$L$ classifiers $\in \lbrace -1, 1 \rbrace:c^1,c^2,…,c^L$ or </p><p>&nbsp;&nbsp;&nbsp;&nbsp;$L$ Estimated probabilites $\in \lbrack -1, 1 \rbrack:p^1,p^2,…,p^L$</p><p>The aggregate classifier becomes</p><p>$c_{bag} = sign(\frac{1}{L} \Sigma_{b=1}^L c^b(x))$ or $c_{bag} = \frac{1}{L} \Sigma_{b=1}^L p^b(x)$</p><hr><h2 id="5-Boosting基本思想和伪代码"><a href="#5-Boosting基本思想和伪代码" class="headerlink" title="5. Boosting基本思想和伪代码"></a>5. Boosting基本思想和伪代码</h2><p>首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2，如此重复进行，直到弱学习器数达到事先指定的数目T。对于训练好的弱分类器，如果是分类任务按照权重进行投票，而对于回归任务进行加权，得到最终的强学习器。（同质集成）</p><p>伪代码</p><hr><p><strong>Input:</strong></p><p>Instance distribution $D$</p><p>Base learning algorithm $L$</p><p>Number of learning round $T$</p><p><strong>Process:</strong></p><p>$D_1 = D$ &nbsp;&nbsp;%初始化分布</p><p>for $t=1,2,…,T$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;$h_t=L(D_t)$  &nbsp;&nbsp;%在分布$D_t$上训练弱分类器$h_t$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;$\epsilon_{t}=\operatorname{Pr}_{x \sim D_{t}, y} I\left[h_{t}(x) \neq y\right]$ &nbsp;&nbsp;%计算$h_t$的错误</p><p>&nbsp;&nbsp;&nbsp;&nbsp;$D_{t+1}=Adjust _ Distribution\left(D_{t}, \epsilon_{t}\right)$ &nbsp;&nbsp;%调整分布，对分类错误的数据加大权重</p><p>end;</p><p><strong>Output:</strong></p><p>$H(x)= Combine _ Outputs \left(\left\{h_{t}(x)\right\}\right)$</p><hr><h2 id="6-为什么集成学习有效"><a href="#6-为什么集成学习有效" class="headerlink" title="6. 为什么集成学习有效"></a>6. 为什么集成学习有效</h2><ul><li><p>统计上：当假设空间对于可用数据量来说太大时，数据上有许多相同精度的假设，学习算法只能够选择其中一个，这样有可能导致所选假设在未见数据上的准确性很差，把多个可能假设集合起来可以降低这种风险。</p></li><li><p>计算上：许多学习算法是通过执行某种形式的局部搜索来工作的，这些搜索可能会陷入局部最优。通过从多个不同的起始点运行局部搜索构造的集成比任何单个分类器都能更好的逼近真实的目标函数。</p></li><li><p>表示上：在大多数机器学习的应用场合中实际目标假设并不在假设空间之中，如果假设空间在某种集成运算下不封闭，那么我们通过把假设空间中的一系列假设集成起来就有可能表示出不在假设空间中的目标假设。</p></li></ul><h1 id="第九章-分类技术"><a href="#第九章-分类技术" class="headerlink" title="第九章 分类技术"></a>第九章 分类技术</h1><h2 id="1-基于规则的分类器"><a href="#1-基于规则的分类器" class="headerlink" title="1. 基于规则的分类器"></a>1. 基于规则的分类器</h2><p>基于规则的分类器是使用一组“if…then…”规则来对记录进行分类的技术。规则的左边称为规则前件或前提，规则右边称为规则后件。一般用覆盖率（coverage）和准确率（accuracy）度量规则的质量。</p><h3 id="1-1-规则质量评估"><a href="#1-1-规则质量评估" class="headerlink" title="1.1 规则质量评估"></a>1.1 规则质量评估</h3><ul><li>覆盖率：$coverage = \frac{|A|}{|D|}$，即满足规则前件的记录所占的比例。</li><li>准确率：$accuracy = \frac{|A \bigcap y|}{|A|}$，即同时满足规则前件和后件的记录在满足规则前件的记录中所占的比例。</li></ul><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><p>像决策树一样具有高度的表达能力；易于解释，易于生成；可以快速分类新实例，性能可与决策树相媲美。</p><h3 id="1-3-需要解决的问题"><a href="#1-3-需要解决的问题" class="headerlink" title="1.3 需要解决的问题"></a>1.3 需要解决的问题</h3><ul><li><p>一个记录可能触发多条规则（不满足互斥规则）</p><ul><li>对于有序规则集：基于规则的排序方案、基于类的排序方案</li><li>对于无序规则集：采用投票的方式</li></ul></li><li><p>一条记录可能不会触发任何规则（不满足穷举规则）</p><ul><li>使用缺省类（通常被指定为没有被现存规则覆盖的训练记录的多数类）</li></ul></li></ul><h3 id="1-4-规则建立的方法"><a href="#1-4-规则建立的方法" class="headerlink" title="1.4 规则建立的方法"></a>1.4 规则建立的方法</h3><p>规则的建立可以使用直接方法和间接方法。直接方法直接从数据中提取分类规则，如RIPPER，CN2；间接方法从其他分类模型（如决策树和神经网络）中提取分类规则，如C4.5rules。</p><h2 id="2-顺序覆盖算法"><a href="#2-顺序覆盖算法" class="headerlink" title="2. 顺序覆盖算法"></a>2. 顺序覆盖算法</h2><p>直接从数据中提取规则，规则基于某种评估度量以贪心的方式增长。该算法从包含多个类的数据集中一次提取一个类的规则。</p><p>算法开始时决策表（规则集）为空，接下来用Learn-One-Rule函数提取类C的覆盖当前训练记录集的最佳规则。如果一个规则覆盖大多数的类C训练记录，没有或仅覆盖极少的其他类训练记录（这样的规则具有高准确率，不必是高覆盖率的，因为每个类可以有多个规则），那么该规则是可取的。一旦找到这样的规则，就删掉它所覆盖的训练记录，并把新规则追加到决策表中。重复这个过程，直至满足终止条件。</p><h2 id="3-支持向量机"><a href="#3-支持向量机" class="headerlink" title="3. 支持向量机"></a>3. 支持向量机</h2><h1 id="第十章-聚类分析"><a href="#第十章-聚类分析" class="headerlink" title="第十章 聚类分析"></a>第十章 聚类分析</h1><h2 id="1-聚类的定义"><a href="#1-聚类的定义" class="headerlink" title="1. 聚类的定义"></a>1. 聚类的定义</h2><p>聚类分析，简称聚类，是一个把数据对象划分成子集的过程。每个子集是一个簇，使得簇中的对象彼此相似，但与其他簇中的对象不相似。（非监督的）</p><h2 id="2-聚类（clustering）的类型"><a href="#2-聚类（clustering）的类型" class="headerlink" title="2. 聚类（clustering）的类型"></a>2. 聚类（clustering）的类型</h2><ul><li><p>层次的与划分的</p><ul><li>层次聚类：允许簇有子簇</li><li>划分聚类：简单的将数据对象划分为不重叠的子集（簇）</li></ul></li><li><p>互斥的、重叠的与模糊的</p><ul><li>互斥的：每个对象都指派到单个簇</li><li>重叠的：一个对象同时属于不同的簇</li><li>模糊聚类：每个对象以一个0（绝对不属于）和1（绝对属于）之间的隶属权值属于每个簇</li></ul></li><li><p>完全的与部分的</p><ul><li>完全聚类：将每个对象都指派到一个簇</li><li>部分聚类：一些噪声、离群点等不被指派到任何一个簇</li></ul></li></ul><h2 id="3-簇（cluster）的类型"><a href="#3-簇（cluster）的类型" class="headerlink" title="3. 簇（cluster）的类型"></a>3. 簇（cluster）的类型</h2><ul><li>明显分离的。每个点到同簇中任意点的距离比到不同簇中所有点的距离更近。</li><li>基于中心的。每个点到其簇中心的距离比到任何其他簇中心的距离更近。</li><li>基于邻近的。每个点到该簇中至少一个点的距离比到不同簇中任意点的距离更近。</li><li>基于密度的。簇是被低密度区域分开的高密度区域。</li><li>概念簇。簇中的点具有由整个点集导出的某种一般共同性质。</li></ul><h2 id="4-层次聚类"><a href="#4-层次聚类" class="headerlink" title="4. 层次聚类"></a>4. 层次聚类</h2><h3 id="4-1-层次聚类的两种主要类型"><a href="#4-1-层次聚类的两种主要类型" class="headerlink" title="4.1 层次聚类的两种主要类型"></a>4.1 层次聚类的两种主要类型</h3><ul><li>凝聚的：从点作为个体簇开始，每一步合并两个最接近的簇。需要定义簇的邻近性的概念。</li><li>分裂的：从包含所有点的某个簇开始，每一步分裂一个簇，直到只剩下单点簇。需要确定每一步分裂哪个簇，以及如何分裂。</li></ul><h3 id="4-2-定义簇之间的邻近性"><a href="#4-2-定义簇之间的邻近性" class="headerlink" title="4.2 定义簇之间的邻近性"></a>4.2 定义簇之间的邻近性</h3><ul><li>单链（MIN）：两个簇的邻近度定义为两个不同簇中任意两点之间的最短距离（最大相似度）。</li></ul><ul><li>全链（MAX）：两个簇的邻近度定义为两个不同簇中任意两点之间的最长距离（最小相似度）。</li></ul><ul><li><p>组平均：两个簇的邻近度定义为不同簇的所有点对邻近度的平均值。</p><ul><li>$proximity(C_i,C_j)=\frac{\Sigma_{x \in C_i y \in C_j} proximity(x,y)}{m_i \times m_j}$</li></ul></li><li><p>Ward方法：两个簇合并时导致的平方误差的增量。</p><ul><li>$\Delta(A, B)=\sum_{i \in A \cup B}\left|\vec{x}_{i}-\vec{m}_{A \cup B}\right|^{2}-\sum_{i \in A}\left|\vec{x}_{i}-\vec{m}_{A}\right|^{2}-\sum_{i \in B}\left|\vec{x}_{i}-\vec{m}_{B}\right|^{2}$ $=\frac{n_{A} n_{B}}{n_{A}+n_{B}}\left|\vec{m}_{A}-\vec{m}_{B}\right|^{2}$</li></ul></li></ul><p>单链擅长处理非椭圆形的簇，但对噪声和离群点很敏感。全链对噪声和离群点不太敏感，但是它可能使大的簇破裂，并偏好球形。</p><h3 id="4-3-层次聚类的缺点"><a href="#4-3-层次聚类的缺点" class="headerlink" title="4.3 层次聚类的缺点"></a>4.3 层次聚类的缺点</h3><ul><li>一旦决定合并两个簇，就不能撤销</li><li>没有直接最小化目标函数</li><li>不同的方案存在以下一个或多个问题<ul><li>对噪声和异常值的敏感性</li><li>难以处理不同大小的簇和凸形状</li><li>破坏大型的簇</li></ul></li></ul><h2 id="5-k均值和k中心点算法"><a href="#5-k均值和k中心点算法" class="headerlink" title="5. k均值和k中心点算法"></a>5. k均值和k中心点算法</h2><h3 id="5-1-k-means算法"><a href="#5-1-k-means算法" class="headerlink" title="5.1 k-means算法"></a>5.1 k-means算法</h3><p>首先，选择k个初始质心，其中k是用户指定的参数，即所期望的簇的个数。每个点指派到最近的质心，而指派到一个质心的点集为一个簇。然后，根据指派到簇的点，更新每个簇的质心。重复指派和更新步骤，直到质心不再发生变化。</p><hr><p>选择k个点作为初始质心</p><p><strong>repeat</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;将每个点指派到最近的质心，形成k个簇</p><p>&nbsp;&nbsp;&nbsp;&nbsp;重新计算每个簇的质心</p><p><strong>until</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;质心不再发生变化</p><hr><p>考虑邻近度度量为欧几里得距离的数据，使用误差的平方和（SSE）作为度量聚类质量的目标函数。假设簇划分为$C_1,C_2,…,C_k$，则目标函数为$SSE=\sum_{i=1}^{k} \sum_{x \in C_{i}} d i s t^{2}\left(c_{i}, x\right)$，其中$c_i$表示第$i$个簇的质心（均值），计算公式为$c_i=\frac{1}{m_i} \sum_{x \in C_i} x$，例如3个二维点$(1,1),(2,3),(6,2)$的质心是$((1+2+6)/3, (1+3+2)/3)=(3,2)$。公式中$x$是一个点，$C_i$是第$i$个簇，$c_i$是簇$C_i$的质心，$m_i$是第$i$个簇中点的个数。</p><p>k-means算法的结果依赖于初始簇中心的随机选择，实践中为了得到好的结果，通常以不同的初始簇中心多次运行k-means算法，然后选取具有最小SSE的簇集。</p><p>用后处理降低SSE：</p><p>总SSE只不过是每个簇SSE的和，通过在簇上进行诸如分裂和合并的操作，可以改变总SSE。</p><ul><li><p>通过增加簇的个数来降低总SSE的策略</p><ul><li>分裂一个簇，通常选择具有最大SSE的簇</li><li>引进一个新的质心，通常选择离所有簇质心最远的点</li></ul></li><li><p>通过减少簇的个数来降低总SSE的策略</p><ul><li>拆散一个簇，删除簇的对应质心</li><li>合并两个簇，通常选择质心最接近的两个簇</li></ul></li></ul><p>k-means算法的缺点：</p><ul><li>通常停止在局部最优</li><li>并不适合所有的数据类型（仅限于具有中心概念的数据）</li><li>不能处理非球形簇、不同尺寸和不同密度的簇</li><li>不能处理噪声和离群点</li></ul><h3 id="5-2-k-medoids算法"><a href="#5-2-k-medoids算法" class="headerlink" title="5.2 k-medoids算法"></a>5.2 k-medoids算法</h3><p>k-means算法的改进，降低它对离群点的敏感性。不采用簇中对象的均值作为参照点，而是挑选实际对象来代表簇，每个簇使用一个代表对象，其余的每个对象被分配到与其最为相似的代表性对象所在的簇中。</p><p>该算法的一个实现是围绕中心点（PAM）算法。随机选择代表对象，然后考虑用一个非代表对象替换一个代表对象是否能够提高聚类质量。尝试所有可能的替换，直到结果聚类的质量不可能被任何替换提高。</p><h2 id="6-DBSCAN算法"><a href="#6-DBSCAN算法" class="headerlink" title="6. DBSCAN算法"></a>6. DBSCAN算法</h2><p>DBSCAN is a <strong>D</strong>ensity <strong>B</strong>ased <strong>S</strong>patial <strong>C</strong>lustering of <strong>A</strong>pplications with <strong>N</strong>oise.具有噪声应用的基于密度的空间聚类。</p><p>根据基于中心的密度进行点分类：</p><ul><li>核心点（core point）：这些点在基于密度的簇内部。点的邻域由距离函数和用户指定的距离参数 $Eps$ 决定。核心点的定义是，如果该点的给定邻域内的点的个数超过给定的阈值 $MinPts$ , 其中 $MinPts$ 也是一个用户指定的参数。</li><li>边界点（border point）：边界点不是核心点，但它落在某个核心点的邻域内。边界点可能落在多个核心点的邻域内。</li><li>噪声点（noise point）：噪声点是既非核心点也非边界点的任何点。</li></ul><hr><p><strong>repeat:</strong></p><p>从数据库中抽出一个未处理的点；</p><p>IF 抽出的点是核心点 THEN 找出所有从该点 _密度可达_ 的对象，形成一个簇；</p><p>ELSE 抽出的点是边缘点(非核心对象)，跳出本次循环，寻找下一个点；</p><p>UNTIL 所有的点都被处理。</p><hr><p>优点：</p><ul><li>可以对抗噪声</li><li>能够处理任意形状和大小的簇</li></ul><p>缺点：</p><ul><li>密度变化太大时不能处理</li><li>对于高维数据也不能很好的工作</li></ul><h2 id="7-聚类评估"><a href="#7-聚类评估" class="headerlink" title="7. 聚类评估"></a>7. 聚类评估</h2><p>用于评估簇的各方面的评估度量或指标一般分成如下三类：</p><ul><li>非监督的。聚类结构的优良性度量，不考虑外部信息。例如，SSE。簇的有效性的非监督度量常常可以进一步分成两类: 簇的凝聚性（cluster cohesion）度量，确定簇中对象如何密切相关；簇的分离性（cluster separation）度量确定某个簇不同于其他簇的地方。非监督度量通常称为内部指标（internal index)，因为它们仅使用出现在数据集中的信息。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-协方差矩阵的计算"><a href="#1-协方差矩阵的计算" class="headerlink" title="1. 协方差矩阵的计算"></a>1. 协方差矩阵的计算</h2><p>对于一组数据，比如$x_1(1,2), x_2(2,6), x_3(4,2), x_4(5,2)$，因为数据是二维的（即两列），所以协方差矩阵是一个$2 \times 2$的矩阵。协方差矩阵的元素$(i,j)=$（第$i$维的所有元素-第$i$维的均值） $\cdot$ （第$j$维的所有元素-第$j$维的均值）$/$ 行数$-1$（即样本数$-1$）。</p><ul><li>协方差矩阵是一个对称矩阵</li><li>对角线元素$(i,i)$为第$i$维数据的方差</li><li>非对角线元素$(i,j)$为第$i$维和第$j$维的协方差</li></ul><h2 id="2-标准差"><a href="#2-标准差" class="headerlink" title="2. 标准差"></a>2. 标准差</h2><p>总体标准差：$\sigma = \sqrt{\frac{\Sigma_{i=1}^{n}(x_i-\overline{x})^2}{n}}$</p><p>样本标准差：$\sigma = \sqrt{\frac{\Sigma_{i=1}^{n}(x_i-\overline{x})^2}{n-1}}$</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/inabaraku/article/details/51862151?utm_source=blogxgwz4">由霍夫丁不等式论证机器学习的可行性</a></p>]]></content>
    
    
    <summary type="html">机器学习与数据挖掘复习</summary>
    
    
    
    
    <category term="数据挖掘" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目部署到服务器</title>
    <link href="https://wheliosc.github.io/springboot-deploy"/>
    <id>https://wheliosc.github.io/springboot-deploy</id>
    <published>2020-04-14T09:33:22.507Z</published>
    <updated>2021-08-30T07:26:25.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>在本地，使用Maven在命令行输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p>如果使用IDEA的话，点击右侧的Maven选项卡，选择execute maven goal，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean package</span><br></pre></td></tr></table></figure><p>它自己前面有固定的mvn，所以命令还是一样的，省去输入mvn而已。</p><h4 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h4><p>运行jar包，肯定要求服务器端有java环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 版本自己选择</span><br><span class="line">$ apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><h4 id="上传jar包"><a href="#上传jar包" class="headerlink" title="上传jar包"></a>上传jar包</h4><p>和Vue项目部署到服务器上中上传文件的方式相同，使用scp命令或者xftp软件。</p><h4 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nohup java -jar test.jar &gt;temp.txt &amp;</span><br><span class="line"></span><br><span class="line"># 这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。</span><br><span class="line"></span><br><span class="line">要杀死这个进程</span><br><span class="line"></span><br><span class="line"># 查看对应端口的进程号</span><br><span class="line">lsof -i:(port)</span><br><span class="line"># 杀死进程</span><br><span class="line">kill -9 (pid)</span><br></pre></td></tr></table></figure><p>这样SpringBoot项目就可以在指定的端口跑起来了。</p>]]></content>
    
    
    <summary type="html">将springboot项目部署到服务器</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://wheliosc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目部署到服务器上</title>
    <link href="https://wheliosc.github.io/vue-nginx-deploy"/>
    <id>https://wheliosc.github.io/vue-nginx-deploy</id>
    <published>2020-04-13T07:58:56.891Z</published>
    <updated>2021-08-30T07:57:20.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 安装nginx</span><br><span class="line">sudo apt install nginx</span><br><span class="line"></span><br><span class="line"># 启动nginx服务，此时访问服务器网址可以看到nginx的欢迎页</span><br><span class="line"># 如果是云服务器，需要打开http和https的端口</span><br><span class="line">service nginx restart</span><br><span class="line"></span><br><span class="line"># 查看当前nginx的版本</span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><h4 id="修改Nginx配置文件"><a href="#修改Nginx配置文件" class="headerlink" title="修改Nginx配置文件"></a>修改Nginx配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf </span><br></pre></td></tr></table></figure><p>在 <code>http&#123;&#125;</code> 中配置一个<code>server&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;                                  # 项目跑在哪个端口</span><br><span class="line">    server_name 118.178.187.5;                    # 当前服务器ip</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /home/dist/;                       # dist文件的位置(这是直接放在home目录下) </span><br><span class="line">         try_files $uri $uri/ /index.html;        # 重定向,内部文件的指向(照写)</span><br><span class="line">    &#125;</span><br><span class="line">    location /api &#123;                               # 当请求跨域时配置端口转发</span><br><span class="line">        proxy_pass http://118.178.187.5:8848/api; # 转发地址，意思是当访问8080端口时，会转发到8848端口</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试配置文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></p><p>重新加载<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></p><h4 id="Vue项目打包"><a href="#Vue项目打包" class="headerlink" title="Vue项目打包"></a>Vue项目打包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在项目文件夹中会生成dist文件夹</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>使用scp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 上传文件</span><br><span class="line">scp local_file remote_username@remote_ip:remote_folder  # 上传到指定文件夹，文件名不变</span><br><span class="line">scp local_file remote_username@remote_ip:remote_file    # 指定了文件名</span><br><span class="line"></span><br><span class="line"># 上传文件夹</span><br><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r dist root@118.178.187.5:/home/dist</span><br></pre></td></tr></table></figure><p>也可以使用xftp软件。</p><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>访问<code>ip:port</code>，应该成功访问页面。</p>]]></content>
    
    
    <summary type="html">将Vue项目部署到服务器，使用Nginx，包括Nginx的配置和本地与服务器间文件的传输</summary>
    
    
    
    
    <category term="Vue" scheme="https://wheliosc.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目开发</title>
    <link href="https://wheliosc.github.io/springboot"/>
    <id>https://wheliosc.github.io/springboot</id>
    <published>2020-04-10T01:03:44.125Z</published>
    <updated>2021-08-30T07:56:47.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h3 id="使用IDEA创建一个SpringBoot项目"><a href="#使用IDEA创建一个SpringBoot项目" class="headerlink" title="使用IDEA创建一个SpringBoot项目"></a>使用IDEA创建一个SpringBoot项目</h3><ol><li><p>File-&gt;New-&gt;Project<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/SpringBoot%E5%88%9B%E5%BB%BA1.png" alt=""></p></li><li><p>选择Spring Initializr，Project SDK自己选择，Service URL选择Default即可，点击Next<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/SpringBoot%E5%88%9B%E5%BB%BA2.png" alt=""></p></li><li><p>Artifact修改为自己的项目名即可，Type选择Maven project，Packing为项目最后的打包方式，有jar和war两种选择，示例选择jar包<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/SpringBoot%E5%88%9B%E5%BB%BA3.png" alt=""></p></li><li><p>Web中勾选Spring Web，Template Engines中勾选Thymeleaf，SQL中勾选JDBC API, MyBatis Framework, MySQL Driver<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/SpringBoot%E5%88%9B%E5%BB%BA4.png" alt=""></p></li><li><p>选择项目的路径，点击Finish<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/SpringBoot%E5%88%9B%E5%BB%BA5.png" alt=""></p></li><li><p>刚创建好的项目结构<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/SpringBoot%E5%88%9B%E5%BB%BA6.png" alt=""></p></li></ol><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><ol><li><p>点击IDEA右侧的Database按钮<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="数据库连接"></p></li><li><p>点击“+”号，选择Data Source，选择MySQL<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%932.png" alt="数据库连接2"></p></li><li><p>填写MySQL的用户名和密码，以及要连接的数据库名，点击测试连接<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%933.png" alt="数据库连接3"></p></li></ol><h3 id="SpringBoot的文件说明"><a href="#SpringBoot的文件说明" class="headerlink" title="SpringBoot的文件说明"></a>SpringBoot的文件说明</h3><ol><li><p>pom.xml主要描述了项目的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，是项目级别的配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 项目的一些信息，初始化时自动生成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dashang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dashang-backstage<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dashang-backstage<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>dashang project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打包方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里面添加依赖，每一个dependency都是一个依赖，meven仓库https://mvnrepository.com/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties配置文件，可以重命名为application.yml，使用YAML编写配置文件。如果使用yml文件，注意键冒号后面要一个空格再写值。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 数据库配置</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/dashang?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">1217</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">## mybatis</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.dashang.model</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li><li><p>Application类，一定要放在最外层，是项目的启动类，会自动扫描加载和它同级及同级子目录下的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DashangBackstageApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DashangBackstageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @SpringBootApplication是</span></span><br><span class="line"><span class="comment">    @SpringBootConfiguration</span></span><br><span class="line"><span class="comment">    @EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">    @ComponentScan </span></span><br><span class="line"><span class="comment">的复合注解 */</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="SpringBoot的项目结构"><a href="#SpringBoot的项目结构" class="headerlink" title="SpringBoot的项目结构"></a>SpringBoot的项目结构</h3><p>以一个实际项目为例：</p><p><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/springboot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="SpringBoot项目结构"></p><ul><li>controller层。控制器层，导入service层，调用service方法，controller通过接收前端传过来的参数进行业务操作，在返回一个指定的路径或者数据表。</li><li>mapper层，或者dao层。对数据库进行持久化操作，它的方法是针对数据库操作的，基本用到的就是增删改查。它只是个接口，只有方法名字，具体实现在mapper.xml中。</li><li>model层，或者bean层、entity层。存放的是实体类，属性值与数据库中的属性值保持一致，实现setter和getter方法。</li><li>service层。存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类，提供controller层调用的方法。可以在service包下新建serviceImpl包，放接口的实现类，service包中放service接口。</li><li>resource文件夹下的mapper文件夹中的mapper.xml文件，用来写SQL语句的。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在自定义的xml文件中书写sql语句，每个书写sql语句的xml文件必须有一个mapper根标签</span></span><br><span class="line"><span class="comment">     namespace: 给当前xml文件起别名 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.dashang.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mapper中有四个基本标签：select, update, delete, insert</span></span><br><span class="line"><span class="comment">         每一条语句都有一个id，用于唯一标识一条语句，不可重复 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 获取所有的用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;UserDomain&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM userinfo</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 登录验证 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM user</span><br><span class="line">        WHERE user_name=#&#123;userName&#125; and password=#&#123;password&#125; and user_type=#&#123;userType&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="SpringBoot运行的流程"><a href="#SpringBoot运行的流程" class="headerlink" title="SpringBoot运行的流程"></a>SpringBoot运行的流程</h3><ol><li>由前端发起请求</li><li>根据路径，SpringBoot会加载相应的Controller进行拦截</li><li>跳转到相应的Service处理层</li><li>跳转到ServiceImplement(service实现类)</li><li>在执行serviceimplement时会加载Dao层，操作数据库</li><li>执行会跳转到mapper层，然后Mapper会继续找对应的mapper.xml配置文件</li><li>之后便会跳转到第4步继续执行，执行完毕后会将结果返回给第1步的请求</li></ol><h3 id="遇到的错误及解决方案"><a href="#遇到的错误及解决方案" class="headerlink" title="遇到的错误及解决方案"></a>遇到的错误及解决方案</h3><ol><li><p>配置Maven的国内源以加速下载。<br>右键项目中的pom.xml文件，选择‘maven’，选择‘create settings.xml’或者‘open settings.xml’，然后粘贴以下内容<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/maven%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F.png" alt="Maven的国内源"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun spring<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-spring-plugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun spring-plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-apache-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun apache-snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/apache-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-google<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun google<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/google<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-gradle-plugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun gradle-plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/gradle-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-jcenter<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun jcenter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/jcenter<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-grails-core<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun grails-core<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/grails-core<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-mapr-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun mapr-public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/mapr-public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>连接数据库时，测试连接时报错<code>Server returns invalid timezone. Go to &#39;Advanced&#39; tab and set &#39;serverTimezone&#39; property manually.</code><br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF1.png" alt="数据库连接错误1"></p></li><li><p>测试连接时遇到缺失驱动文件的问题。<br>提示Download missing driver files。正常情况下点击Download后IDEA会自动下载缺失的文件，但是因为网络原因，可能还会碰到下载失败的情况。<br>点击Go to Driver<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF2.png" alt="数据库连接错误2"><br>点击“+”号，选择Custom JARs<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF2.1.png" alt="数据库连接错误2.1"><br>然后在<code>.m2\repository\mysql\mysql-connector-java</code>下找到某一版本的mysql-connector，选中jar包导入即可，然后重新测试。如果这个路径下没有文件，那么去maven仓库中搜索<code>mysql-connector-java</code>，然后选择<code>MySQL Connector/J</code>，选择一个版本，在pom.xml中添加依赖，然后刷新重新加载一下包。</p></li><li><p>运行时jdbc驱动错误的问题。<br><code>Loading class &#39;com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is &#39;com.mysql.cj.jdbc.Driver&#39;.</code><br>配置文件中将<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code><br>改为<code>spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</code><br>com.mysql.jdbc.Driver 是 mysql-connector-java 5中的，<br>com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6中的。<br>此外，还需要在数据库URL中设置时区，即在URL后添加<code>&amp;serverTimezone=Asia/Shanghai</code>，如果设定serverTimezone=UTC，会比中国时间早8个小时，如果在中国，可以选择Asia/Shanghai或者Asia/Hongkong。</p></li></ol>]]></content>
    
    
    <summary type="html">SpringBoot与MyBatis相结合进行项目后台的开发，在此过程中遇到的一些问题和过程记录</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://wheliosc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04安装tensorflow</title>
    <link href="https://wheliosc.github.io/ubuntu-install-tensorflow"/>
    <id>https://wheliosc.github.io/ubuntu-install-tensorflow</id>
    <published>2020-03-30T10:04:08.854Z</published>
    <updated>2021-08-30T07:57:11.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h4 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h4><ul><li><p>官网下载<code>https://www.anaconda.com/distribution/</code></p></li><li><p>在下载目录下执行<code>bash Anaconda3-2020.02-Linux-x86_64.sh</code>（根据自己的下载修改名字）</p></li><li><p>执行 <code>export PATH=~/anaconda3/bin:$PATH</code> 和 <code>source ~/.bashrc</code> 将conda添加到环境变量中。</p></li><li><p>测试安装是否成功<code>conda info</code><br>安装完成后,这个Anaconda默认的python，在系统之外虚拟出来一个使用python的环境，叫做base。在这个环境下面安装的库，不会与系统自带的python以及库冲突。</p></li><li><p>添加镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清华源（清华镜像好像不支持conda包了，可以先使用默认源）</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/fastai/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中科大</span></span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认源</span></span><br><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure></li></ul><h4 id="安装Tensorflow"><a href="#安装Tensorflow" class="headerlink" title="安装Tensorflow"></a>安装Tensorflow</h4><ul><li>首先，创建一个新的环境<code>conda create -n tf python=3.6</code>（tf是环境名，自定义；python的版本自己指定）</li><li>激活环境<code>conda activate tf</code>（停用当前环境<code>conda deactivate</code>，移除环境<code>conda remove -n tf --all</code>，展示当前存在的所有环境<code>conda-env list</code>）</li><li>安装tensorflow<code>conda install tensorflow</code></li></ul>]]></content>
    
    
    <summary type="html">Ubuntu18.04上使用Anaconda安装tensorflow</summary>
    
    
    
    
    <category term="Ubuntu18.04" scheme="https://wheliosc.github.io/tags/Ubuntu18-04/"/>
    
    <category term="tensorflow" scheme="https://wheliosc.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>软件测试与质量保证</title>
    <link href="https://wheliosc.github.io/software-testing"/>
    <id>https://wheliosc.github.io/software-testing</id>
    <published>2019-06-19T08:45:19.297Z</published>
    <updated>2021-08-30T07:56:40.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="测试概述"><a href="#测试概述" class="headerlink" title="测试概述"></a>测试概述</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>错误（Error）：产生错误结果的人为行为。A human action that produces an incorrect result.</p><p>缺陷（fault）：计算机程序中不正确的步骤、过程或数据定义。缺陷是错误（Error）的结果/表现。</p><p>失效（failure）：系统或组件不能在规定的性能要求内执行其所需的功能。缺陷执行时会发生失效。</p><blockquote><p> The term failure refers to a behavioral deviation from the user requirement or the product specification; fault refers to an underlying condition within a software that causes certain failure(s) to occur; while error refers to a missing or incorrect human action resulting in certain fault(s) being injected into a software.The term “defect” generally refers to some problem with the software, either with its external behavior or with its internal characteristics.</p></blockquote><p>错误（Error）、缺陷（fault）和失效（failure）统称为defect（或者说是bug）。</p><h3 id="质量控制与质量保证"><a href="#质量控制与质量保证" class="headerlink" title="质量控制与质量保证"></a>质量控制与质量保证</h3><p>质量控制（Quality Control）：旨在评估开发或制造产品质量的一系列活动。“扣留”任何不符合条件的产品。</p><p>质量保证（Quality Assurance）：通过在整个开发和制造过程/阶段中执行的各种活动，最大限度地降低保证质量的成本。</p><ul><li>Preventing the causes of errors</li><li>Detecting faults</li><li>Correcting failures</li></ul><p>QA和QC服务于不同的对象，QC的活动是QA的活动的一部分。</p><h3 id="QA的构成与活动"><a href="#QA的构成与活动" class="headerlink" title="QA的构成与活动"></a>QA的构成与活动</h3><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/QA%E6%9E%84%E6%88%90%E4%B8%8E%E6%B4%BB%E5%8A%A8.png" alt="QA的构成与活动"></p><h3 id="质量成本构成"><a href="#质量成本构成" class="headerlink" title="质量成本构成"></a>质量成本构成</h3><ul><li><p>Costs of Control</p><ul><li>Prevention costs</li><li>Appraisal costs（评估成本）</li></ul></li><li><p>Costs of Failure</p><ul><li>Internal failure costs</li><li>external failure costs</li></ul></li></ul><h3 id="软件测试的目的与原则"><a href="#软件测试的目的与原则" class="headerlink" title="软件测试的目的与原则"></a>软件测试的目的与原则</h3><p>软件测试在软件质量保证活动中起着核心作用。通过运行软件系统或执行其指定的功能，测试人员可以确定观察到的系统行为是否符合其规范或要求。如果两者之间存在差异，可以采取后续行动来定位和消除软件代码中的相关问题，这也可能包括修改软件设计。</p><p>因此，通过测试来检测和消除缺陷有助于减少交付软件产品中的缺陷数量，从而帮助实现质量目标。即使没有观察到任何差异，也可以将特定实例累积为证据，以证明软件按指定方式运行。因此，测试是确保和证明软件质量最常用的手段。</p><ul><li>所有测试都应该可以追溯到客户要求。</li><li>测试应该在测试开始之前很久就要计划好。</li><li>Pareto原则（80％的错误可能在20％的代码中找到）适用于软件测试。</li><li>测试应该从小开始，然后进展到大。</li><li>彻底的测试是不可能的。</li><li>为了最有效，测试应由独立的第三方进行。</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>软件测试的本质是为要测试的项目确定一组测试用例。</p><p>测试用例是描述输入、操作或事件以及预期响应的文档，用于确定应用程序的功能是否正常工作。</p><p>测试用例应包含诸如测试用例标识符、测试用例名称、目标、测试条件/设置、输入数据要求、步骤和预期结果等详细信息。</p><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/V%E6%A8%A1%E5%9E%8B.png" alt="V模型"></p><h2 id="功能性测试"><a href="#功能性测试" class="headerlink" title="功能性测试"></a>功能性测试</h2><h3 id="边界值测试"><a href="#边界值测试" class="headerlink" title="边界值测试"></a>边界值测试</h3><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><p>关注输入域，不适合强类型语言。</p><p>基于“单缺陷”假设，即：失效（failure）极少是由两个（或多个）缺陷的同时发生引起的。</p><p>具体方法：对于多个输入，假设一个变量是导致failure的，其他变量取固定值（5种情况：最大值max、最小值min、中间值mid、比最大值小一点max-、比最小值大一点min+）。</p><p>假设一个程序有n个输入，则测试用例数：$5 \times n - (n-1) = 4n + 1$，其中$n-1$为重复用例数。</p><h4 id="健壮性测试"><a href="#健壮性测试" class="headerlink" title="健壮性测试"></a>健壮性测试</h4><p>健壮性测试是边界值分析的一种简单拓展，除了变量的五个边界值分析取值，还要增加略超过最大值（max+）和略小于最小值（min-）的取值，即每个变量取7个值。</p><p>健壮性测试的主要价值在于强制注意异常处理。</p><h4 id="最坏情况测试"><a href="#最坏情况测试" class="headerlink" title="最坏情况测试"></a>最坏情况测试</h4><p>多缺陷假设，即假设失效（failure）是由多个变量引起的。取可能值的笛卡尔乘积，n变量最坏情况测试下的测试用例数为$5^{n}$，在健壮最坏情况测试下的测试用例数为$7^{n}$。</p><h4 id="边界值分析的局限性"><a href="#边界值分析的局限性" class="headerlink" title="边界值分析的局限性"></a>边界值分析的局限性</h4><p>如果被测程序是多个<strong>独立变量</strong>的函数，这些变量受<strong>物理量</strong>的限制，则很适合边界值分析。</p><p>物理变量比如温度、压力、空气速度、迎角、负载等，物理边界很重要；与之相对的是逻辑变量，比如说PIN和电话号码等。</p><h3 id="等价类测试"><a href="#等价类测试" class="headerlink" title="等价类测试"></a>等价类测试</h3><p>使用等价类作为功能性测试的基础有两个动机：进行完备的测试，同时希望避免冗余。</p><p>等价类构成一个集合的分区，该集合是相互不相交的子集的集合，这些子集的并集是整个集合。</p><p>单缺陷假设和多缺陷假设产生弱等价类测试和强等价类测试之分，针对是否进行无效数据的处理产生健壮与一般等价类测试之分。</p><ul><li>弱一般等价类测试：单缺陷假设，不考虑异常区域</li><li>强一般等价类测试：多缺陷假设，不考虑异常区域</li><li>弱健壮等价类测试：单缺陷假设，要考虑异常区域</li><li>强健壮等价类测试：多缺陷假设，要考虑异常区域</li></ul><h4 id="强等价类与弱等价类"><a href="#强等价类与弱等价类" class="headerlink" title="强等价类与弱等价类"></a>强等价类与弱等价类</h4><p>弱等价类：每个等价类都覆盖一次即可，测试用例数与输入变量的最多的划分一致，如第一个输入划分了3个等价类，第二个输入划分了4个等价类，则测试用例数为4个。</p><p>强等价类：每一个输入的等价类都要进行组合，如第一个输入划分了3个等价类，第二个输入划分了4个等价类，则测试用例数为$3 \times 4 = 12$个。</p><h3 id="基于决策表的测试"><a href="#基于决策表的测试" class="headerlink" title="基于决策表的测试"></a>基于决策表的测试</h3><p>在所有功能性测试的方法中，基于决策表的测试方法是最严格的，因为决策表具有逻辑严格性。</p><p>决策表分为条件桩，条件条目，行动桩，行动条目四部分。</p><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E8%A1%A8.png" alt="三角形问题的决策表"></p><h2 id="结构性测试"><a href="#结构性测试" class="headerlink" title="结构性测试"></a>结构性测试</h2><p>也叫做白盒测试、透明盒测试。基于被测程序的源代码，而不是基于定义。</p><h3 id="路径测试"><a href="#路径测试" class="headerlink" title="路径测试"></a>路径测试</h3><h4 id="程序图"><a href="#程序图" class="headerlink" title="程序图"></a>程序图</h4><p>给定采用命令式程序设计语言编写的一段程序，其程序图是一种有向图，图中的节点表示语句片段，边表示控制流。对于给定的程序，可以使用多种不同的程序图，所有这些程序图都可以简化为唯一的DD-路径图。</p><h4 id="DD-路径"><a href="#DD-路径" class="headerlink" title="DD-路径"></a>DD-路径</h4><p>DD-路径（decision-to-decision）是从程序图中获得的链，其中链是初始节点和终端节点不同的路径，并且每个节点的内度为1，外度为1。初始节点与链中的其他节点2-连接（单向可达），不会存在1-连接或3-连接。</p><p>相关定义：</p><ul><li>内度（入度）：将该节点作为终止节点的不同边的条数。</li><li>外度（出度）：将该节点作为开始节点的不同边的条数。</li><li>路径：有向路径是一系列边，使得对于该序列中的所有相邻边对偶$e_i, e_j$来说，第一条边的终止节点是第二条边的开始节点。</li><li>半路径：有向半路径是一系列边，使得对于该序列中至少有一个相邻边对偶$e_i, e_j$来说，第一条边的开始节点是第二条边的开始节点，或第一条边的终止节点是第二条边的终止节点。</li><li>0-连接：对于有向图中的两个节点$n_i,n_j$，当且仅当$n_i$和$n_j$之间没有路径。</li><li>1-连接：对于有向图中的两个节点$n_i,n_j$，当且仅当$n_i$和$n_j$之间有一条半路径，但是没有路径。</li><li>2-连接：对于有向图中的两个节点$n_i,n_j$，当且仅当$n_i$和$n_j$之间有一条路径。</li><li>3-连接：对于有向图中的两个节点$n_i,n_j$，当且仅当从$n_i$到$n_j$有一条路径，并且从$n_j$到$n_i$有一条路径。</li></ul><h4 id="DD-路径图"><a href="#DD-路径图" class="headerlink" title="DD-路径图"></a>DD-路径图</h4><p>给定采用命令式程序设计语言编写的一段程序，其DD-路径图是有向图，图中的节点表示程序图的DD-路径，边表示连接DD-路径之间的控制流。</p><h4 id="测试覆盖指标"><a href="#测试覆盖指标" class="headerlink" title="测试覆盖指标"></a>测试覆盖指标</h4><ul><li>语句覆盖：选择足够多的测试数据，使被测程序中<strong>每个语句至少执行一次</strong></li><li>判定覆盖：不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次，也就是<strong>每个判定的每个分支都至少执行一次</strong></li><li>条件覆盖：不仅每个语句至少执行一次，而且使<strong>判定表达式</strong>中的<strong>每个条件都取到各种可能的结果</strong></li><li>判定/条件覆盖：选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</li><li>条件组合覆盖：条件组合覆盖是更强的逻辑覆盖标准，它要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次，但不一定每条路径都执行到</li><li>路径覆盖：使程序的每条可能路径都至少执行一次（如果程序图中有环，则要求每个环至少经过一次）。路径覆盖是覆盖率最高的一种覆盖技术。</li></ul><p>条件覆盖通常比判定覆盖强，因为它使判定达式中每个条件都取到了两个不同的结果，判定覆盖却只关心整个判定表达式的值。但是，也可能有相反的情况。</p><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E6%8C%87%E6%A0%87.png" alt="测试覆盖指标"></p><h4 id="基路径测试"><a href="#基路径测试" class="headerlink" title="基路径测试"></a>基路径测试</h4><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><h3 id="基于分解的集成"><a href="#基于分解的集成" class="headerlink" title="基于分解的集成"></a>基于分解的集成</h3><p>给定分解树所需集成测试会话数： 会话 = 节点 - 叶子节点 + 边。</p><h4 id="大棒集成（Big-Bang）"><a href="#大棒集成（Big-Bang）" class="headerlink" title="大棒集成（Big Bang）"></a>大棒集成（Big Bang）</h4><p>所有组件一次组装和测试。缺点是当发现失效时，没有多少线索能够用来帮助确定缺陷的位置。</p><h4 id="自顶向下集成"><a href="#自顶向下集成" class="headerlink" title="自顶向下集成"></a>自顶向下集成</h4><p>自顶向下集成从主程序（树根）开始。所有被主程序调用的下层单元都作为“桩”出现，桩就是模拟被调用单元的一次性代码。</p><p>提供了主程序的所有桩后，可开始测试主程序，就像它是一个独立单元一样。（这是第一个会话，主程序+桩）。在确信主程序逻辑正确之后，将逐渐采用实际代码取代这些桩。</p><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B.png" alt="自顶向下"><br>在最上层，要开发第一层分解中四个组件的桩，共有四个集成过程，在每个过程中，每次用一个已完成的子程序去替代一个桩，直到完整测试整个系统。自顶向下集成采用功能分解树的广度优先遍历策略。</p><p>优点：测试用例可以根据系统的功能（功能需求）来定义。结构技术也可用于顶层的单元。<br>缺点：编写桩可能很困难，尤其是在参数传递很复杂的情况下，桩必须允许测试所有可能的条件。桩模块数 = 节点数 - 1。</p><h4 id="自底向上集成"><a href="#自底向上集成" class="headerlink" title="自底向上集成"></a>自底向上集成</h4><p>自底向上的集成策略首先侧重于测试最低级别的单元（即分解树叶的单元）。从分解树的叶开始，并用特别编写的驱动器测试。大多数系统在接近叶时都有相当高的扇出数，因此在自底向上集成顺序中，不需要同样数量的驱动器，不过代价是驱动器模块都比较复杂。</p><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B.png" alt="自底向上"></p><p>驱动器数 = 节点数 - 叶子节点数。</p><h4 id="三明治集成"><a href="#三明治集成" class="headerlink" title="三明治集成"></a>三明治集成</h4><p>三明治集成是自顶向下和自底向上集成的组合。如果通过分解树考虑三明治集成，则只需要在子树上真正进行大爆炸集成。桩和驱动器的开发工作都比较小，不过代价是作为大爆炸集成的后果，在一定程度上增加了定位缺陷的难度。</p><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/%E4%B8%89%E6%98%8E%E6%B2%BB.png" alt="三明治"></p><h3 id="基于调用图的集成"><a href="#基于调用图的集成" class="headerlink" title="基于调用图的集成"></a>基于调用图的集成</h3><p>基本思想是用调用图代替分解树。</p><p>调用图是一个定向标记的图，其中节点表示功能单元，边表示调用事件或特定的资源请求。</p><h4 id="成对集成"><a href="#成对集成" class="headerlink" title="成对集成"></a>成对集成</h4><p>对调用图的每条边有一个集成测试会话。</p><h4 id="相邻集成"><a href="#相邻集成" class="headerlink" title="相邻集成"></a>相邻集成</h4><p>图中节点的邻居是边从给定节点引出的节点集合。在有向图中，节点邻居包括所有直接前驱结点和所有直接后继节点。</p><p>内部节点 = 节点 - （源节点 + 汇节点）<br>邻居 = 内部节点 + 源节点<br>综合上面的公式得到：邻居 = 节点 - 汇节点</p><ul><li>汇节点：出度为0的节点</li><li>源节点：入度为0的节点</li></ul><h3 id="基于路径的集成"><a href="#基于路径的集成" class="headerlink" title="基于路径的集成"></a>基于路径的集成</h3><h4 id="MM-路径"><a href="#MM-路径" class="headerlink" title="MM-路径"></a>MM-路径</h4><p>MM-路径是穿插出现模块执行路径和消息的序列。MM-路径永远不是可行执行路径，并且这些路径要跨越单元边界。节点表示模块执行路径，边表示消息。对于传统（过程）软件，MM-路径永远从主程序中开始，在主程序中结束。</p><p>相关定义：</p><ul><li>程序源节点：程序执行开始或重新开始处的语句片段。</li><li>程序汇节点：程序执行结束处的语句片段。</li><li>模块执行路径：以源节点开始、以汇节点结束的一系列语句，中间没有插入汇节点。</li><li>消息：一种程序设计语言机制，通过这种机制一个单元将控制转移给另一个单元。</li></ul><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="线程（Thread）级别"><a href="#线程（Thread）级别" class="headerlink" title="线程（Thread）级别"></a>线程（Thread）级别</h3><ul><li>单元级线程被理解为指令的执行时间路径或流程图上的某个路径。</li><li>集成级线程是实现某些原子函数的mm路径序列。表示为模块执行和消息的序列。</li><li>系统级线程是原子系统函数（ASF）的序列。</li></ul><p>原子系统功能是一种在系统层可以观察得到的端口输入与输出事件的行动。</p><p>线程提供了三个测试级别的统一视图：</p><ul><li>单元测试测试单个功能</li><li>集成测试检查单元之间的交互</li><li>系统测试检查ASF之间的交互。</li></ul><h2 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a>质量保证</h2><h3 id="评审（Review）"><a href="#评审（Review）" class="headerlink" title="评审（Review）"></a>评审（Review）</h3><p>对产品或项目状态进行评估，以确定与计划结果的差异并提出改进建议。</p><h4 id="管理评审（Management-Review）"><a href="#管理评审（Management-Review）" class="headerlink" title="管理评审（Management Review）"></a>管理评审（Management Review）</h4><p>“管理评审的目的是<strong>监测进度，确定计划和进度的状态，确认需求及其系统分配，或评估用于实现适用性的管理方法的有效性</strong>”。</p><p>它们支持有关软件项目期间所需更改和纠正措施的决策。管理评审确定计划、进度和要求的充分性，并监控其进度或不一致性。这些评审可以对产品进行，例如<strong>审计报告、进度报告、V&amp;V报告和许多类型的计划</strong>，包括风险管理、项目管理、软件配置管理、软件安全和风险评估等。</p><h4 id="技术评审（Technical-Review）"><a href="#技术评审（Technical-Review）" class="headerlink" title="技术评审（Technical Review）"></a>技术评审（Technical Review）</h4><p>“技术评审的目的是<strong>评估软件产品，以确定其是否适合预期用途。目的是识别与批准的规范和标准的差异。结果应向管理层提供证据，确认（或不确认）产品符合规范、符合标准，并控制变更</strong>”。</p><p>在技术评审中必须建立特定的角色：决策者、评审负责人、记录员和技术人员，以支持评审活动。技术审查要求强制投入：</p><ul><li>目标陈述</li><li>特定的软件产品</li><li>具体项目管理计划</li><li>与此产品关联的问题列表</li><li>技术评审程序</li></ul><p>小组遵循审查程序。技术合格的人员提供产品概述，并在一个或多个会议期间进行检查。技术评审应在评审中列出的所有活动完成后完成。</p><h4 id="审查（Inspection）"><a href="#审查（Inspection）" class="headerlink" title="审查（Inspection）"></a>审查（Inspection）</h4><p>目的：检测和识别软件产品异常</p><p>与评审的两个重要区别：</p><ol><li>对审查组成员担任管理职务的个人，不得参加审查。</li><li>审查由一名接受审查技术培训的公正的协助者领导。</li></ol><p>审查总是涉及到中间产品或最终产品的作者，而其他的评审可能不会。</p><p>审查会议通常持续几个小时，而技术评审通常范围更广，时间更长。</p><p>审查退出标准：</p><ol><li>不接受或最轻微的返工</li><li>接受返工验证</li><li>复验</li></ol><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/%E5%AE%A1%E6%9F%A5%E8%BF%87%E7%A8%8B.png" alt="审查过程"></p><h4 id="走查（Walkthrough）"><a href="#走查（Walkthrough）" class="headerlink" title="走查（Walkthrough）"></a>走查（Walkthrough）</h4><p>目的：</p><ul><li>评估软件产品</li><li>有时用于教育观众</li></ul><p>主要目标：</p><ul><li>发现异常</li><li>改进软件产品</li><li>考虑替代实施</li><li>评估是否符合标准和规范</li></ul><p>走查与审查类似，但通常不太正式。</p><h3 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h3><p>SQA计划包括主要测试计划和评审计划，主要测试计划包括单元测试计划、集成测试计划、系统测试计划和验收测试计划，评审计划包括审查和走查。</p><h3 id="制定测试计划的步骤"><a href="#制定测试计划的步骤" class="headerlink" title="制定测试计划的步骤"></a>制定测试计划的步骤</h3><ul><li>确定测试需求 </li><li>评估风险 </li><li>制定测试策略</li><li>明确测试中的关键活动(WBS)</li><li>估计测试成本和工作量</li><li>定义角色和确定资源 </li><li>确定进度, 创建时间表 </li><li>生成测试计划 </li></ul><h3 id="质量度量指标"><a href="#质量度量指标" class="headerlink" title="质量度量指标"></a>质量度量指标</h3><p>缺陷密度-&gt;缺陷个数：优先级（严重性）<br>缺陷趋势-&gt;缺陷个数：时间<br>缺陷龄期-&gt;缺陷存在周期</p><h2 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h2><h3 id="CMMI的五个级别"><a href="#CMMI的五个级别" class="headerlink" title="CMMI的五个级别"></a>CMMI的五个级别</h3><p><img src="https://github-1259166513.cos.ap-beijing.myqcloud.com/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/CMMI.jpg" alt="CMMI"></p>]]></content>
    
    
    <summary type="html">结构性测试、功能性测试、集成测试、系统测试方法与质量保证</summary>
    
    
    
    
    <category term="软件测试" scheme="https://wheliosc.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL语言与Oracle数据库</title>
    <link href="https://wheliosc.github.io/sql-oracle-database"/>
    <id>https://wheliosc.github.io/sql-oracle-database</id>
    <published>2019-04-21T06:41:27.553Z</published>
    <updated>2021-08-30T07:56:07.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="SQL语言包括的内容"><a href="#SQL语言包括的内容" class="headerlink" title="SQL语言包括的内容"></a>SQL语言包括的内容</h2><ul><li>DDL，数据库定义语言：定义关系模式、删除关系、建立索引以及修改关系模式。</li><li>DML，数据库操纵语言：查询（select）、插入（insert）、删除（delete）与修改（update）。</li><li>嵌入式DML。嵌入在Pascal、C等宿主语言中。</li><li>视图定义。</li><li>权限管理。（grant、revoke、deny等）。</li><li>完整性约束。</li><li>事务控制。（commit、rollback、savepoint）。</li></ul><h2 id="数据库提交事务的几种情况"><a href="#数据库提交事务的几种情况" class="headerlink" title="数据库提交事务的几种情况"></a>数据库提交事务的几种情况</h2><ul><li>一条显式的COMMIT或者Rollback命令</li><li>一条DDL或者DCL语句</li><li>非正常退出sql plus，或者使用exit或quit退出sql plus</li><li>系统崩溃</li></ul><p>后三条为隐式提交。</p><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">    col_name data_type [<span class="keyword">column</span> level <span class="keyword">constraint</span>],</span><br><span class="line">    col_name data_type [<span class="keyword">column</span> level <span class="keyword">constraint</span>],</span><br><span class="line">    ...,</span><br><span class="line">    [<span class="keyword">table</span> level <span class="keyword">constraint</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>完整性约束条件：</p><ul><li>非空，<code>not null</code>。</li><li>主键，<code>primary key</code>。</li><li>参照完整性约束（外键），<code>foreign key</code>。</li><li>唯一性约束，<code>unique</code>。</li><li>检查约束，<code>check</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表级约束实例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    testColOne varchar2(<span class="number">10</span>),</span><br><span class="line">    testColTwo number(<span class="number">4</span>),</span><br><span class="line">    testColThree <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">check</span>(testColThree <span class="keyword">in</span> (<span class="string">&#x27;好&#x27;</span>,<span class="string">&#x27;坏&#x27;</span>)),</span><br><span class="line">    <span class="keyword">primary</span> key (testColOne, testColTwo),</span><br><span class="line">    <span class="keyword">foreign</span> key (testColThree) <span class="keyword">references</span> test2(testCol)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name [<span class="keyword">where</span> <span class="keyword">condition</span>]</span><br><span class="line"><span class="comment">-- 或者使用truncate</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure><ul><li>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。</li><li>DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li><li>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</li><li>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</li><li>TRUNCATE TABLE 不能用于参与了索引视图的表。</li><li>对用TRUNCATE TABLE删除数据的表上增加数据时，要使用UPDATE STATISTICS来维护索引信息。</li><li>如果有ROLLBACK语句，DELETE操作将被撤销，但TRUNCATE不会撤销。</li></ul><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> col_name data_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列的数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name modify col_name data_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除完整性约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> constraint_name(col_name);</span><br></pre></td></tr></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.插入的数据数与表列数相同且数据类型相同</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span>(v1, v2, v3, v4);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.在特定列上插入数据并且其他列允许空值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(col1, col2, col3) <span class="keyword">values</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.从一个表中查询数据插入到另一个表中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="operator">&lt;</span><span class="keyword">distinct</span><span class="operator">|</span><span class="keyword">all</span><span class="operator">&gt;</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">values</span>(col1, col2, col3)</span><br><span class="line"><span class="keyword">select</span> col1, col2, col3 <span class="keyword">from</span> table_name2 <span class="keyword">where</span> conditions;</span><br></pre></td></tr></table></figure><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update table_name</span><br><span class="line"><span class="keyword">set</span> col_name <span class="operator">=</span> 值或者查询语句结果</span><br><span class="line"><span class="keyword">where</span> conditions;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于文本过滤的查询中包含&#x27;_&#x27;或者&#x27;%&#x27;的情况</span></span><br><span class="line"><span class="comment">-- 例：查询以&quot;DB_&quot;开头，且倒数第3个字符为i的课程的详细情况。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> cname <span class="keyword">like</span> <span class="string">&#x27;DB\_%i__&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 集合查询 union [all]、minus、intersect</span></span><br></pre></td></tr></table></figure><p>相关子查询和不相关子查询：</p><ul><li>不相关子查询。子查询的查询条件不依赖于父查询。处理方式：<strong>由里向外逐层处理</strong>。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</li><li>相关子查询。子查询的查询条件依赖于父查询。处理方式：首<strong>先取外层查询</strong>中表的第一个元组，根据它<strong>与内层查询相关的属性值处理内层查询</strong>，若WHERE子句返回值为真，则取此元组放入结果表；然后再取外层表的下一个元组；重复这一过程，直至外层表全部检查完为止。</li></ul><h3 id="表间数据转换"><a href="#表间数据转换" class="headerlink" title="表间数据转换"></a>表间数据转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同时插入到多表 无条件</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">INTO</span> first_table_name</span><br><span class="line">    <span class="keyword">VALUES</span>(first_column_name,...last_column_name)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">INTO</span> last_table_name</span><br><span class="line">    <span class="keyword">VALUES</span>(first_column_name,...last_column_name)</span><br><span class="line"><span class="keyword">SELECT</span> statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时插入到多表 有条件</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="operator">&lt;</span><span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">FIRST</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHEN</span> first_condition <span class="keyword">THEN</span> <span class="keyword">INTO</span> first_table_name</span><br><span class="line">    <span class="keyword">VALUES</span>(first_column_name,...last_column_name)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">WHEN</span> last_condition <span class="keyword">THEN</span> <span class="keyword">INTO</span> last_table_name</span><br><span class="line">    <span class="keyword">VALUES</span>(first_column_name,...last_column_name)</span><br><span class="line">[<span class="keyword">ELSE</span> <span class="keyword">INTO</span> defaul_table_name</span><br><span class="line">    <span class="keyword">VALUES</span>(first_column_name,...last_column_name)]</span><br><span class="line"><span class="keyword">SELECT</span> statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表合并</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> main_table</span><br><span class="line"><span class="keyword">USING</span> change_table</span><br><span class="line"><span class="keyword">ON</span> (main_table.primary_key<span class="operator">=</span>change_table.primary_key)</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line">UPDATE</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">main_table.first_column<span class="operator">=</span>change_table.first_column</span><br><span class="line">...</span><br><span class="line">main_table.last_column<span class="operator">=</span>change_table.last_column</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">INSERT</span>(first_column,...last_column)</span><br><span class="line"><span class="keyword">VALUES</span>(change_table.first_column,...last_column);</span><br></pre></td></tr></table></figure><h2 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h2><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><ul><li>LOWER(列名|表达式)：将大写或大小写混合的字符转换成小写</li><li>UPPER(列名|表达式) ：将小写或大小写混合的字符转换成大写</li><li>INITCAP(列名|表达式) ：将每个单词的第一个字母转换成大写，其余的字母都转换成小写</li><li>CONCAT:连接两个值,等同于||<br>格式：CONCAT(column1|expression1,column2|expression2)</li><li>SUBSTR:返回第一个参数中从n1字符开始长度为n2的子串，如果n1是负值，表示从后向前数的abs(n1)位，如果n2省略,取n1之后的所有字符<br>格式：SUBSTR(column | expression,n1[,n2])</li><li>LENGTH:取字符长度<br>格式:LENGTH(column | expression)</li><li>INSTR:返回s1中，子串s2从n1开始，第n2次出现的位置。n1,n2默认值为1<br>格式:INSTR(s1,s2,[,n1],[n2])</li><li>LPAD:返回s1被s2从左面填充到n1长度。<br>格式：LPAD(s1,n1,s2)</li><li>RPAD:返回s1被s2从右面填充到n1长度。<br>格式：RPAD(s1,n1,s2)</li><li>REPLACE:把s1中的s2用s3替换。<br>格式:REPLACE(s1,s2,s3)</li></ul><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul><li>SYSDATE()：返回系统日期</li><li>MONTHS_BETWEEN(date1,date2)：返回两个日期间隔的月数</li><li>ADD_MONTHS(date1,n)：在指定日期基础上加上相应的月数</li><li>NEXT_DAY()：返回某一日期的下一个指定日期，例如：NEXT_DAY(‘02-2月-06’,’星期一’)</li><li>LAST_DAY：返回指定日期当月最后一天的日期，例如：LAST_DAY(‘02-2月-2006’)</li><li>ROUND(date[,’fmt’])将date按照fmt指定的格式进行四舍五入，fmt为可选项，如果没有指定fmt，则默认为DD’，将date四舍五入为最近的天。<br>  格式码：世纪CC,年YY，月MM,日DD，小时HH24，分MI，秒S<br>  例如：ROUND(hire_date, ‘MONTH’)</li><li>TRUNC(date[,’fmt’])将date按照fmt指定的格式进行截取，fmt为可选项，如果没有指定fmt，则默认为‘DD’，将date截取为最近的天。TRUNC(hire_date, ‘MONTH’)</li><li>EXTRACT：返回从日期类型中取出指定年、月、日，例如：EXTRACT (MONTH FROM HIRE_DATE)</li></ul><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><ul><li>ROUND(列名|表达式, n)：将列或表达式所表示的数值四舍五入到小数点后的第n位。</li><li>TRUNC(列名|表达式,n)：将列或表达式所表示的数值截取到小数点后的第n位。</li><li>MOD(m,n)：取m除以n后得到的余数。</li></ul><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><ul><li>TO_CHAR，TO_CHAR(date|number [,‘fmt’])把日期类型/数字类型的表达式或列转换为字符类型</li><li>TO_NUMBER(char[,’fmt’]) 把字符类型列或表达式转换为数字类型。<br>使用格式和TO_CHAR中转换成字符类型中的格式相同</li><li>TO_DATE(char[,‘fmt’]) 把字符类型列或表达式转换为日期类型。<br>格式和TO_CHAR中转换成字符类型中的格式相同。</li></ul><h4 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h4><ul><li>9：一位数字；</li><li>0：一位数字或前导零；</li><li>$：显示为美元符号；</li><li>L：显示按照区域设置的本地货币符号；</li><li>.：小数点;</li><li>,：千位分割符；</li></ul><h4 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h4><ul><li>YYYY：4位数字表示年份；</li><li>YY：2位数字表示年份，但是无世纪转换；</li><li>RR：2位数字表示年份，有世纪转换；</li><li>YEAR：年份的英文拼写；</li><li>MM：两位数字表示月份；</li><li>MONTH：月份英文拼写；</li><li>DY：星期的英文前三位字母；</li><li>DAY：星期的英文拼写；</li><li>D：数字表示一星期的第几天，星期天是一周的第一天。</li><li>DD：数字表示一个月中的第几天；</li><li>DDD：数字表示一年中的第几天。</li><li>AM 或PM：上下午表示；</li><li>HH 或HH12或HH24：数字表示小时。HH12代表12小时计时，HH24代表24小时计时；</li><li>MI：数字表示分钟；</li><li>SS：数字表示秒；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhoufangcheng04050227/p/7991759.html">SQL中Truncate的用法</a></p>]]></content>
    
    
    <summary type="html">SQL语句以及一些函数的详细用法</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://wheliosc.github.io/tags/oracle/"/>
    
    <category term="SQL" scheme="https://wheliosc.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计与Oracle存储结构</title>
    <link href="https://wheliosc.github.io/oracle-design-and-store"/>
    <id>https://wheliosc.github.io/oracle-design-and-store</id>
    <published>2019-04-21T05:41:52.833Z</published>
    <updated>2021-08-30T07:56:02.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="数据库的设计过程"><a href="#数据库的设计过程" class="headerlink" title="数据库的设计过程"></a>数据库的设计过程</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求分析的重点是调查、收集与分析用户在数据管理中的<strong>信息要求、处理要求、安全性与完整性要求</strong>。<br>分析和表达用户的需求的常用方法：自顶向下的结构化分析方法（Structured Analysis，简称SA方法）。SA方法从最上层的系统组织机构入手，采用逐层分解的方式分析系统，并用<strong>数据流图</strong>和<strong>数据字典</strong>描述系统。</p><h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><p>将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计。概念结构是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定。概念结构设计是整个数据库设计的关键。<br>设计概念结构的四类方法：</p><ul><li>自顶向下</li><li>自底向上</li><li>逐步扩张</li><li>混合策略（自顶向下和自底向上）</li></ul><h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>逻辑结构设计的步骤：</p><ul><li>将概念结构转化为一般的关系、网状、层次模型</li><li>将转化来的关系、网状、层次模型向特定DBMS支持下的数据模型转换</li><li>对数据模型进行优化</li><li>设计用户子模式</li></ul><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><p>数据库物理设计的步骤：</p><ul><li>确定数据库的物理结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li><li>如果评价结果满足原设计要求则可进入到物理实施阶段，否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。</li></ul><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>数据库实施的工作内容</p><ul><li>用DDL定义数据库结构</li><li>组织数据入库</li><li>编制与调试应用程序</li><li>数据库试运行</li></ul><h3 id="运行与维护"><a href="#运行与维护" class="headerlink" title="运行与维护"></a>运行与维护</h3><p>数据库试运行结果符合设计目标后，数据库就可以真正投入运行了。数据库投入运行标志着开发任务的基本完成和维护工作的开始。对数据库设计进行评价、调整、修改等维护工作是一个长期的任务，也是设计工作的继续和提高。</p><h2 id="Oracle存储结构"><a href="#Oracle存储结构" class="headerlink" title="Oracle存储结构"></a>Oracle存储结构</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>数据库（Database）由多个表空间（Tablespace）组成，表空间由段（Segment）组成,段由多个区（Extent）组成，区是磁盘上连续块（Block）的组。</p><ul><li>表空间（Tablespace），最高级的逻辑存储结构，数据库是由多个表空间组成的。</li><li>段（Segment），由多个区组成，这些区可以是连续的，也可以是不连续的。包括数据段、索引段、临时段和回滚段。</li><li>区（Extend），由连续的块组成，它是oracle在进行存储空间的分配和回收的最小单位。</li><li>块（Block），Oracle用来管理存储的最小单元，是数据库使用的最小I/O单元，也是最小的逻辑存储结构。<br><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g2a9786eptj30hj09lglu.jpg" alt="database-design-and-store"></li></ul><h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><p>Oracle数据库逻辑上由一个或多个表空间组成，每个表空间在物理上由一个或多个<strong>数据文件</strong>组成。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blogs.oracle.com/database4cn/oracle-v6">ORACLE数据库存储结构简介</a></p>]]></content>
    
    
    <summary type="html">数据库的设计过程与Oracle数据库的逻辑与物理存储结构</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://wheliosc.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle SQL练习题4</title>
    <link href="https://wheliosc.github.io/oracle-database-prictise-4"/>
    <id>https://wheliosc.github.io/oracle-database-prictise-4</id>
    <published>2019-04-10T08:20:50.482Z</published>
    <updated>2021-08-30T07:30:03.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.列出至少有一个雇员的所有部门</span></span><br><span class="line"><span class="keyword">select</span> deptno, dname, loc </span><br><span class="line"><span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">in</span> (<span class="keyword">select</span> deptno</span><br><span class="line">                  <span class="keyword">from</span> emp</span><br><span class="line">                  <span class="keyword">group</span> <span class="keyword">by</span> deptno);</span><br><span class="line">                  </span><br><span class="line"><span class="comment">-- 2.列出薪金比&quot;SMITH&quot;多的所有雇员</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> sal</span><br><span class="line">              <span class="keyword">from</span> emp</span><br><span class="line">              <span class="keyword">where</span> ename <span class="operator">=</span> <span class="string">&#x27;SMITH&#x27;</span>);</span><br><span class="line">              </span><br><span class="line"><span class="comment">-- 3.列出入职日期早于其直接上级的所有雇员</span></span><br><span class="line"><span class="keyword">select</span> e1.ename, e1.empno, e1.mgr, e1.hiredate, e2.hiredate mgrhiredate</span><br><span class="line"><span class="keyword">from</span> emp e1, emp e2</span><br><span class="line"><span class="keyword">where</span> e1.mgr <span class="operator">=</span> e2.empno <span class="keyword">and</span> e1.hiredate <span class="operator">&lt;</span> e2.hiredate;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.找员工姓名和直接上级的名字</span></span><br><span class="line"><span class="keyword">select</span> e1.ename, e2.ename mgrname</span><br><span class="line"><span class="keyword">from</span> emp e1 <span class="keyword">left</span> <span class="keyword">join</span> emp e2</span><br><span class="line"><span class="keyword">on</span> e1.mgr <span class="operator">=</span> e2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.显示部门名称和人数</span></span><br><span class="line"><span class="comment">-- 不能count(*),因为40号部门没人但也会是一条记录</span></span><br><span class="line"><span class="keyword">select</span> dname, <span class="built_in">count</span>(emp.empno)</span><br><span class="line"><span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptno <span class="operator">=</span> dept.deptno</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dname;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.显示每个部门的最高工资的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp e2 <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> e1.deptno <span class="operator">=</span> e2.deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.显示每个部门的工资前2名的员工</span></span><br><span class="line"><span class="keyword">select</span> deptno, ename, sal      </span><br><span class="line"><span class="keyword">from</span> emp e1     </span><br><span class="line"><span class="keyword">where</span>      </span><br><span class="line">   (  </span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)     </span><br><span class="line">    <span class="keyword">from</span> emp e2     </span><br><span class="line">    <span class="keyword">where</span> e2.deptno<span class="operator">=</span>e1.deptno <span class="keyword">and</span> e2.sal<span class="operator">&gt;</span>e1.sal  </span><br><span class="line">   ) <span class="operator">&lt;</span><span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8.显示出和员工号7369部门相同的员工姓名，工资</span></span><br><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="operator">=</span> (<span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> empno<span class="operator">=</span><span class="number">7369</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9.显示出和姓名中包含&quot;W&quot;的员工相同部门的员工姓名</span></span><br><span class="line"><span class="keyword">select</span> ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">in</span> (<span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;%W%&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10.显示出工资大于平均工资的员工姓名，工资</span></span><br><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11.显示出工资大于本部门平均工资的员工姓名，工资</span></span><br><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> e1.sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp e2 <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> e1.deptno <span class="operator">=</span> e2.deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 12.显示员工&quot;KING&quot;所管理的员工姓名</span></span><br><span class="line"><span class="keyword">select</span> ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> mgr <span class="operator">=</span> (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;KING&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 13.显示每位经理管理员工的最低工资，及最低工资者的姓名</span></span><br><span class="line"><span class="keyword">select</span> sal, ename, mgr</span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> e1.sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">min</span>(sal) <span class="keyword">from</span> emp e2 <span class="keyword">group</span> <span class="keyword">by</span> e2.mgr <span class="keyword">having</span> e1.mgr <span class="operator">=</span> e2.mgr);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 14.显示比工资最高的员工参加工作时间晚的员工姓名，参加工作时间</span></span><br><span class="line"><span class="keyword">select</span> ename, hiredate</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> hiredate <span class="operator">&gt;</span> (<span class="keyword">select</span> hiredate </span><br><span class="line">                   <span class="keyword">from</span> emp </span><br><span class="line">                   <span class="keyword">where</span> sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp));</span><br><span class="line">                   </span><br><span class="line"><span class="comment">-- 15.显示出平均工资最高的的部门平均工资及部门名称</span></span><br><span class="line"><span class="keyword">select</span> dname, <span class="built_in">avg</span>(sal) maxavgsal</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dname</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(sal) <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(avgsal)</span><br><span class="line">                    <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">max</span>(<span class="built_in">avg</span>(sal)) avgsal</span><br><span class="line">                          <span class="keyword">from</span> emp</span><br><span class="line">                          <span class="keyword">group</span> <span class="keyword">by</span> deptno));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 16.创建序列，起始位1，自增为1，最小值为1，最大值为9999</span></span><br><span class="line"><span class="keyword">create</span> sequence mysequence</span><br><span class="line">increment <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span></span><br><span class="line">minvalue <span class="number">1</span></span><br><span class="line">maxvalue <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 17.创建序列，起始值为50，每次增加5</span></span><br><span class="line"><span class="keyword">create</span> sequence mysequence2</span><br><span class="line">increment <span class="keyword">by</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 18.请分析按照以下要求都需要建立什么类型的字段?</span></span><br><span class="line"><span class="comment">–(1)最大2000个字节定长字符串                      -- char(2000)</span></span><br><span class="line"><span class="comment">–(2)如果输入‘张三’ 后添空格6个                   -- nchar</span></span><br><span class="line"><span class="comment">–(3)性别输入&#x27;男&#x27;或&#x27;女’                           -- char(2)e</span></span><br><span class="line"><span class="comment">–(4)最大4000个字节变长字符串                      -- varchar2(4000) 参数为字节数</span></span><br><span class="line"><span class="comment">–(5)如果在数据库中输入&#x27;张三&#x27;则显示数据&#x27;张三’      -- nvarchar2(10) unicode编码，参数为字符数</span></span><br><span class="line"><span class="comment">–(6)表示数字范围为- 10的125次方到10的126次方, 可</span></span><br><span class="line"><span class="comment">以表示小数也可以表示整数                            -- number</span></span><br><span class="line"><span class="comment">–(7)最大表示4位整数 -9999 到 9999                 -- number(4)</span></span><br><span class="line"><span class="comment">–(8)表示5位有效数字2位小数的一个小数-999.99</span></span><br><span class="line"><span class="comment">到999.99                                           -- number(5,2)</span></span><br><span class="line"><span class="comment">–(9)包含年月日和时分秒                             -- date</span></span><br><span class="line"><span class="comment">–(10)包含年月日和时分秒毫秒                       -- timestamp</span></span><br><span class="line"><span class="comment">–(11)二进制大对象图像/声音  */</span>                    <span class="comment">-- LONGRAW 或者 BLOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 19.请为工资大于10000的员工创建视图，要求显示员工的部门信息，职位信息，部门所在地.</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> highsal</span><br><span class="line"><span class="keyword">as</span> (<span class="keyword">select</span> deptno, dname, &quot;JOB&quot;, loc</span><br><span class="line">    <span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept</span><br><span class="line">    <span class="keyword">where</span> emp.sal <span class="operator">&gt;</span> <span class="number">10000</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 20.现在按照工资的降序排序，分页显示，其中一页数据为25条，请显示第3页数据。</span></span><br><span class="line"><span class="keyword">select</span> sal, rn</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> sal, rownum rn</span><br><span class="line">      <span class="keyword">from</span> emp </span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">where</span> rn <span class="keyword">between</span> <span class="number">50</span> <span class="keyword">and</span> <span class="number">75</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 21.创建视图，要求包含字段：部门名，部门平均工资</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> deptview</span><br><span class="line"><span class="keyword">as</span> (<span class="keyword">select</span> dname, <span class="built_in">avg</span>(sal)</span><br><span class="line">     <span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept</span><br><span class="line">     <span class="keyword">group</span> <span class="keyword">by</span> dname);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 22.针对21题创建的视图，执行insert,update,delete,语句能否成功，为什么？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 23.显示出员工工资排在第五到第十名的员工信息</span></span><br><span class="line"><span class="keyword">select</span> empno, ename, &quot;JOB&quot;, mgr, hiredate, sal, comm, deptno, rn</span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">select</span> empno, ename, &quot;JOB&quot;, mgr, hiredate, sal, comm, deptno, rownum rn</span><br><span class="line">      <span class="keyword">from</span> emp </span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> sal)</span><br><span class="line"><span class="keyword">where</span> rn <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 24.在表copy_dept中插入记录，其中部门号采用17题中创建的序列生成</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept</span><br><span class="line"><span class="keyword">values</span>(mysequence2.nextval, <span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;Dalian&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">oracle数据库的上机练习题4</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://wheliosc.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://wheliosc.github.io/sort-methods"/>
    <id>https://wheliosc.github.io/sort-methods</id>
    <published>2019-03-28T11:42:41.605Z</published>
    <updated>2021-08-30T07:29:09.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>存在多个具有相同排序码的记录，排序后这些记录的相对次序不变则称排序是稳定的。<br>🌰 待排序列： <font color="red">37</font> 12 98 <font color="blue">37</font> 69<br>若经过排序后，序列为 12 <font color="red">37</font> <font color="blue">37</font> 69 98，则该排序是稳定的；若序列为 12 <font color="blue">37</font> <font color="red">37</font> 69 98，则排序是不稳定的。</p><h2 id="排序算法的衡量标准"><a href="#排序算法的衡量标准" class="headerlink" title="排序算法的衡量标准"></a>排序算法的衡量标准</h2><ul><li>时间代价（记录的比较和移动次数）</li><li>空间代价</li><li>算法本身的复杂程度</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>思想：将一个记录插入到已排好序的有序表中，从而得到一个新的有序表。<br>步骤：假设待排序列为data。data[0]已经是有序的了；将data[1]插入到有序序列{data[0]}中；第p+1次排序时，将data[p+1]插入到有序序列{data[0],data[1],…,data[p]}中，先用临时变量temp存储data[p+1]的值，然后将data[p]和temp进行比较，如果后者比较小，则将data[p]移动到data[p+1]的位置，继续将data[p-1]与temp比较，如果后者小，则将data[p-1]移动到data[p]的位置，重复以上比较过程，直到找到temp的插入位置。“<strong>从后向前，边比边移。</strong>”<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//不减序排列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        T temp = data[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j--) &#123;</span><br><span class="line">            data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">        &#125;</span><br><span class="line">        data[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>稳定</li><li>空间代价$O(1)$</li><li>时间代价$O(n^2)$</li></ul><p>直接插入排序的两个性质：</p><ul><li>在最好情况（序列本身已是有序的）下时间代价为$O(n)$</li><li>对于短序列，直接插入排序比较有效</li></ul><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>思想：在插入第i个记录时，前面的记录已经是有序的了，可以用二分法查找第i个记录的正确位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertionSort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        T temp = data[i];</span><br><span class="line">        left = <span class="number">0</span>, right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[mid] &gt; temp)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)</span><br><span class="line">            data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">        data[left] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>折半插入排序的时间复杂度仍为$O(n^2)$</li><li>折半插入算法与直接插入算法的元素移动一样是顺序的，因此该方法也是<strong>稳定</strong>的。</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>直接插入排序只允许相邻的元素交换,希尔排序将原序列根据不同的步长(“间隙”)划分成许多小的序列,然后每一个小序列内进行直接插入排序,这样就允许了原序列的远程元素间的交换。逐步缩小步长,让其最终为1,最终序列有序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            T temp = data[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; data[j - gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">                data[j] = data[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序空间复杂度为$O(1)$</p><p>希尔排序时间复杂度与增量序列有关:</p><ul><li>当增量序列为$K=2^x$时,时间复杂度为$O(n^2)$</li></ul>]]></content>
    
    
    <summary type="html">插入排序、</summary>
    
    
    
    
    <category term="数据结构" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Oracle SQL练习题3</title>
    <link href="https://wheliosc.github.io/oracle-database-prictise-3"/>
    <id>https://wheliosc.github.io/oracle-database-prictise-3</id>
    <published>2019-03-27T07:31:26.266Z</published>
    <updated>2021-08-30T07:29:58.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.显示dname和loc中间用-分隔</span></span><br><span class="line"><span class="keyword">select</span> dname<span class="operator">||</span><span class="string">&#x27;-&#x27;</span><span class="operator">||</span>loc</span><br><span class="line"><span class="keyword">from</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.将部门名称左填充为10位</span></span><br><span class="line"><span class="keyword">select</span> lpad(dname, <span class="number">10</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.将员工名字的‘S’，替换为‘s’</span></span><br><span class="line"><span class="keyword">select</span> replace(ename, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.求员工名字的前三位</span></span><br><span class="line"><span class="keyword">select</span> substr(ename, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.查找员工名字中‘S’第一次出现的位置</span></span><br><span class="line"><span class="keyword">select</span> instr(ename, <span class="string">&#x27;S&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.查找员工名字中第二次出现‘T’的位置</span></span><br><span class="line"><span class="keyword">select</span> instr(ename, <span class="string">&#x27;T&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.查找员工名字的长度</span></span><br><span class="line"><span class="keyword">select</span> length(ename)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8.显示一年前的今天日期和一年以后今天的日期</span></span><br><span class="line"><span class="keyword">select</span> to_char(sysdate, <span class="string">&#x27;yyyy&#x27;</span>)<span class="number">-1</span><span class="operator">||</span>to_char(sysdate, <span class="string">&#x27;-mm-dd&#x27;</span>),</span><br><span class="line">        to_char(sysdate, <span class="string">&#x27;yyyy&#x27;</span>)<span class="operator">+</span><span class="number">1</span><span class="operator">||</span>to_char(sysdate, <span class="string">&#x27;-mm-dd&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9.显示本月第三天的日期</span></span><br><span class="line"><span class="keyword">select</span> to_char(sysdate, <span class="string">&#x27;yyyy-mm-&#x27;</span>)<span class="operator">||</span><span class="string">&#x27;03&#x27;</span></span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10.显示今天到&#x27;2012-12-12&#x27;相隔的月数</span></span><br><span class="line"><span class="keyword">select</span> months_between(sysdate, to_date(<span class="string">&#x27;2012-12-12&#x27;</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>))</span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11.显示员工工资的货币表示形式，比如RMB5,000</span></span><br><span class="line"><span class="keyword">select</span> to_char(sal, <span class="string">&#x27;L9999&#x27;</span>) salary</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 12.显示1949年10月1日的字符串格式,最后显示结果为1949年10月1日</span></span><br><span class="line"><span class="keyword">select</span> to_char(to_date(<span class="string">&#x27;1949-10-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>), <span class="string">&#x27;yyyy&quot;年&quot;mm&quot;月&quot;dd&quot;日&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">--13.按照如下要求显示数据：</span></span><br><span class="line"><span class="comment">--sal=800  显示低工资   </span></span><br><span class="line"><span class="comment">--     sal=3000  正常工资</span></span><br><span class="line"><span class="comment">--     sal=5000  高工资</span></span><br><span class="line"><span class="keyword">select</span> (</span><br><span class="line">  <span class="keyword">case</span> sal</span><br><span class="line">    <span class="keyword">when</span> <span class="number">800</span> <span class="keyword">then</span> <span class="string">&#x27;低工资&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">3000</span> <span class="keyword">then</span> <span class="string">&#x27;正常工资&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">5000</span> <span class="keyword">then</span> <span class="string">&#x27;高工资&#x27;</span></span><br><span class="line">  <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 14.显示以下字段及字符串的连接：&quot;The job id for &quot;，姓名(大写)，&quot; is &quot; ,工作(小写)  如：The job id for ALLEN is salesman</span></span><br><span class="line"><span class="comment">-- job为关键字，可以使用双引号表示它只是一个字段</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;The job id for &#x27;</span> <span class="operator">||</span> <span class="built_in">upper</span>(ename) <span class="operator">||</span> <span class="string">&#x27; is &#x27;</span> <span class="operator">||</span> <span class="built_in">lower</span>(&quot;JOB&quot;)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 15.显示出姓名中最后一个字母为&quot;N&quot;的员工姓名 (使用substr或者instr)</span></span><br><span class="line"><span class="keyword">select</span> ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> substr(ename, length(ename), <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 16.查询参加工作时间在每月15日之后的员工姓名，参加工作时间</span></span><br><span class="line"><span class="keyword">select</span> ename, hiredate</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> hiredate) <span class="operator">&gt;</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 17.用&quot;*&quot;的个数表示员工的工资中包含多少&quot;千&quot;，如3500，显示&#x27;***&#x27;,5600,显示&#x27;*****&#x27;</span></span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27; &#x27;</span>, trunc(sal<span class="operator">/</span><span class="number">1000</span>, <span class="number">0</span>)<span class="operator">+</span><span class="number">1</span>, <span class="string">&#x27;*&#x27;</span>), sal</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 18.显示员工名，参加工作时间，参加工作6个月后的第一个周一</span></span><br><span class="line"><span class="keyword">select</span> ename, hiredate, next_day(add_months(hiredate, <span class="number">6</span>),<span class="string">&#x27;星期一&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 19.显示员工姓名，月薪，年薪（13个月的月薪+10000元奖金+comm）要求别名为annual_salary,要求所有人的年薪都显示出来</span></span><br><span class="line"><span class="keyword">select</span> ename, sal, (<span class="number">13</span><span class="operator">*</span>sal<span class="operator">+</span><span class="number">10000</span><span class="operator">+</span>nvl(comm, <span class="number">0</span>)) annual_salary</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 20.创建一个缩进报告显示经理层次，从名字为 KING的雇员开始，显示雇员的名字、经理ID和部门ID。</span></span><br><span class="line"><span class="keyword">select</span> ename, mgr, deptno</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> ename<span class="operator">=</span><span class="string">&#x27;KING&#x27;</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> prior empno <span class="operator">=</span> mgr;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 21.产生一个公司组织图表显示经理层次。从最顶级的人开始，排除所有job为CLERK的人。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> &quot;JOB&quot; <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CLERK&#x27;</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> mgr <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> prior empno <span class="operator">=</span> mgr;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 22.用集合运算，列出不包含job为SALESMAN 的部门的部门号。</span></span><br><span class="line">(<span class="keyword">select</span> deptno <span class="keyword">from</span> emp)</span><br><span class="line">minus </span><br><span class="line">(<span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> &quot;JOB&quot; <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*23.写一个联合查询，列出下面的信息：</span></span><br><span class="line"><span class="comment">EMP表中所有雇员的名字和部门编号,不管他们是</span></span><br><span class="line"><span class="comment">否属于任何部门。</span></span><br><span class="line"><span class="comment">DEPT表中的所有部门编号和部门名称，不管他们</span></span><br><span class="line"><span class="comment">是否有员工。*/</span></span><br><span class="line"><span class="keyword">select</span> ename, deptno</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> dname, deptno</span><br><span class="line"><span class="keyword">from</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 24.用集合运算查询出职位为SALESMAN和部门编号为10的人员编号、姓名、职位，不排除重复结果。</span></span><br><span class="line">(<span class="keyword">select</span> empno, ename, &quot;JOB&quot; <span class="keyword">from</span> emp <span class="keyword">where</span> &quot;JOB&quot; <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span>)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> empno, ename, &quot;JOB&quot; <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 25.用集合查询出部门为10和20的所有人员编号、姓名、所在部门名称。</span></span><br><span class="line">(<span class="keyword">select</span> empno, ename, dname</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno <span class="operator">=</span> dept.deptno</span><br><span class="line"><span class="keyword">where</span> emp.deptno <span class="operator">=</span> <span class="number">10</span>) </span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line">(<span class="keyword">select</span> empno, ename, dname</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno <span class="operator">=</span> dept.deptno</span><br><span class="line"><span class="keyword">where</span> emp.deptno <span class="operator">=</span> <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 26.查询薪水多于他所在部门平均薪水的雇员名字，部门号。</span></span><br><span class="line"><span class="keyword">select</span> ename, deptno</span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp e2 <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> e1.deptno <span class="operator">=</span> e2.deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 27.查询员工姓名和直接上级的名字。</span></span><br><span class="line"><span class="keyword">select</span> e1.ename, e2.ename mgrname</span><br><span class="line"><span class="keyword">from</span> emp e1, emp e2</span><br><span class="line"><span class="keyword">where</span> e1.mgr <span class="operator">=</span> e2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 28.查询每个部门工资最高的员工姓名，工资。</span></span><br><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp e2 <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> e1.deptno <span class="operator">=</span> e2.deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 29.查询每个部门工资前两名高的员工姓名，工资，部门号</span></span><br><span class="line"><span class="keyword">select</span> deptno, ename, sal      </span><br><span class="line"><span class="keyword">from</span> emp e1     </span><br><span class="line"><span class="keyword">where</span>      </span><br><span class="line">   (  </span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)     </span><br><span class="line">    <span class="keyword">from</span> emp e2     </span><br><span class="line">    <span class="keyword">where</span> e2.deptno<span class="operator">=</span>e1.deptno <span class="keyword">and</span> e2.sal<span class="operator">&gt;</span>e1.sal  </span><br><span class="line">   ) <span class="operator">&lt;</span><span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> deptno, sal;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">oracle数据库的上机练习题3</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://wheliosc.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle SQL练习题2</title>
    <link href="https://wheliosc.github.io/oracle-database-prictise-2"/>
    <id>https://wheliosc.github.io/oracle-database-prictise-2</id>
    <published>2019-03-24T11:44:12.231Z</published>
    <updated>2021-08-30T07:29:53.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><p>操作scott账户下的emp、dept、salgrade表，完成如下操作：</p><ol><li>列出所有雇员的姓名及其直接上级的姓名</li><li>列出部门名称和这些部门的雇员,同时列出那些没有雇员的部门</li><li>显示所有部门在”NEW YORK”(dept表 loc字段)的员工姓名</li><li>显示员工”SMITH”的姓名，部门名称</li><li>显示员工姓名，部门名称，工资，工资级别(salgrade表 grade字段),要求工资级别大于4级</li><li>显示员工”KING”和”FORD”管理的员工姓名及其经理姓名</li><li>显示员工名，参加工作时间，经理名，参加工作时间：参加工作时间比他的经理早</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.列出所有雇员的姓名及其直接上级的姓名</span></span><br><span class="line"><span class="keyword">select</span> e1.ename, e2.ename superiorname</span><br><span class="line"><span class="keyword">from</span> emp e1 <span class="keyword">left</span> <span class="keyword">join</span> emp e2 </span><br><span class="line"><span class="keyword">on</span> e1.mgr <span class="operator">=</span> e2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.列出部门名称和这些部门的雇员,同时列出那些没有雇员的部门</span></span><br><span class="line"><span class="keyword">select</span> dept.dname, emp.ename</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">on</span> emp.deptno <span class="operator">=</span> dept.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.显示所有部门在&quot;NEW YORK&quot;(dept表 loc字段)的员工姓名</span></span><br><span class="line"><span class="keyword">select</span> emp.ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">in</span> (<span class="keyword">select</span> deptno</span><br><span class="line">                  <span class="keyword">from</span> dept</span><br><span class="line">                  <span class="keyword">where</span> loc <span class="operator">=</span> <span class="string">&#x27;NEW YORK&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.显示员工&quot;SMITH&quot;的姓名，部门名称</span></span><br><span class="line"><span class="keyword">select</span> emp.ename, dept.dname</span><br><span class="line"><span class="keyword">from</span> emp, dept</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">lower</span>(emp.ename) <span class="operator">=</span> <span class="string">&#x27;smith&#x27;</span> <span class="keyword">and</span> emp.deptno <span class="operator">=</span> dept.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.显示员工姓名，部门名称，工资，工资级别(salgrade表 grade字段),要求工资级别大于4级</span></span><br><span class="line"><span class="keyword">select</span> emp.ename, dept.dname, emp.sal, salgrade.grade</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno <span class="operator">=</span> dept.deptno, salgrade</span><br><span class="line"><span class="keyword">where</span> emp.sal <span class="keyword">between</span> salgrade.losal <span class="keyword">and</span> salgrade.hisal <span class="keyword">and</span> salgrade.grade<span class="operator">&gt;</span><span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.显示员工&quot;KING&quot;和&quot;FORD&quot;管理的员工姓名及其经理姓名</span></span><br><span class="line"><span class="keyword">select</span> e1.ename &quot;NAME&quot;, e2.ename substaffname, emp.ename managername</span><br><span class="line"><span class="keyword">from</span> (emp e1 <span class="keyword">left</span> <span class="keyword">join</span> emp e2 <span class="keyword">on</span> e1.empno <span class="operator">=</span> e2.mgr) <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> e1.mgr <span class="operator">=</span> emp.empno</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">lower</span>(e1.ename) <span class="operator">=</span> <span class="string">&#x27;king&#x27;</span> <span class="keyword">or</span> <span class="built_in">lower</span>(e1.ename) <span class="operator">=</span> <span class="string">&#x27;ford&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.显示员工名，参加工作时间，经理名，参加工作时间：参加工作时间比他的经理早</span></span><br><span class="line"><span class="keyword">select</span> e1.ename, e1.hiredate, e2.ename managername, e2.hiredate managerhiredate</span><br><span class="line"><span class="keyword">from</span> emp e1 <span class="keyword">left</span> <span class="keyword">join</span> emp e2 <span class="keyword">on</span> e1.mgr <span class="operator">=</span> e2.empno</span><br><span class="line"><span class="keyword">where</span> e1.hiredate <span class="operator">&lt;</span> e2.hiredate;</span><br></pre></td></tr></table></figure><ol><li>显示平均工资为&gt;2000的职位</li><li>计算工资在2000以上，各种职位的平均工资大于3000的职位及平均工资</li><li>找每个部门的最高和最低的工资</li><li>找每个部门中每种职位的最高和最低的工资</li><li>显示出工作名称(job)中包含”MAN”的员工平均工资，最高工资，最低工资及工资的和</li><li>显示出20号部门的员工人数</li><li>显示出平均工资大于2000的部门名称及平均工资</li><li>显示每个部门每种工作平均工资大于2500的部门及工作</li><li>显示出工作名称中包含”MAN”，并且平均工资大于1000的工作名称及平均工资</li><li>显示出平均工资最高的的部门平均工资</li><li>列出最低工资大于1500的各种工作</li><li>列出各部门的员工数量及平均工作年限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 8.显示平均工资为&gt;2000的职位</span></span><br><span class="line"><span class="keyword">select</span> &quot;JOB&quot;</span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> &quot;JOB&quot;</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(sal) <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9.计算工资在2000以上，各种职位的平均工资大于3000的职位及平均工资</span></span><br><span class="line"><span class="keyword">select</span> &quot;JOB&quot;, <span class="built_in">avg</span>(sal) avgsal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> &quot;JOB&quot;</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(sal) <span class="operator">&gt;</span> <span class="number">3000</span> <span class="keyword">and</span> <span class="built_in">min</span>(sal) <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10.找每个部门的最高和最低的工资</span></span><br><span class="line"><span class="keyword">select</span> deptno, <span class="built_in">max</span>(sal), <span class="built_in">min</span>(sal)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11.找每个部门中每种职位的最高和最低的工资</span></span><br><span class="line"><span class="keyword">select</span> deptno, &quot;JOB&quot;, <span class="built_in">max</span>(sal), <span class="built_in">min</span>(sal)</span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno, &quot;JOB&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 12.显示出工作名称(job)中包含&quot;MAN&quot;的员工平均工资，最高工资，最低工资及工资的和</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal) avgsal, <span class="built_in">max</span>(sal) maxsal, <span class="built_in">min</span>(sal) minsal, <span class="built_in">sum</span>(sal) sumsal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> &quot;JOB&quot; <span class="keyword">like</span> <span class="string">&#x27;%MAN%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 13.显示出20号部门的员工人数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 14.显示出平均工资大于2000的部门名称及平均工资</span></span><br><span class="line"><span class="keyword">select</span> d1.dname, d2.avgsal</span><br><span class="line"><span class="keyword">from</span> dept d1, (<span class="keyword">select</span> deptno, <span class="built_in">avg</span>(sal) avgsal</span><br><span class="line">               <span class="keyword">from</span> emp</span><br><span class="line">               <span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line">               <span class="keyword">having</span> <span class="built_in">avg</span>(sal) <span class="operator">&gt;</span> <span class="number">2000</span>) d2</span><br><span class="line"><span class="keyword">where</span> d1.deptno <span class="operator">=</span> d2.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 15.显示每个部门每种工作平均工资大于2500的部门及工作</span></span><br><span class="line"><span class="keyword">select</span> deptno, &quot;JOB&quot;</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno,&quot;JOB&quot;</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(sal)<span class="operator">&gt;</span><span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 16.显示出工作名称中包含&quot;MAN&quot;，并且平均工资大于1000的工作名称及平均工资</span></span><br><span class="line"><span class="keyword">select</span> &quot;JOB&quot;, <span class="built_in">avg</span>(sal) avgsal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> &quot;JOB&quot; <span class="keyword">like</span> <span class="string">&#x27;%MAN%&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> &quot;JOB&quot;</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(sal)<span class="operator">&gt;</span><span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 17.显示出平均工资最高的的部门平均工资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(avgsal)</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) avgsal</span><br><span class="line">      <span class="keyword">from</span> emp</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 18.列出最低工资大于1500的各种工作</span></span><br><span class="line"><span class="keyword">select</span> &quot;JOB&quot;</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> &quot;JOB&quot;</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span>(sal) <span class="operator">&gt;</span> <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 19.列出各部门的员工数量及平均工作年限</span></span><br><span class="line"><span class="keyword">select</span> deptno, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">avg</span>((sysdate<span class="operator">-</span>hiredate)<span class="operator">/</span><span class="number">365</span>)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure><ol><li>查询和ford相同部门的员工姓名和雇用日期</li><li>查询工资比公司平均工资高的员工的员工号，姓名和工资。</li><li>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</li><li>查询在CHICAGO工作的员工的员工号，job</li><li>查询管理者是king的员工姓名和工资</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 20.查询和ford相同部门的员工姓名和雇用日期</span></span><br><span class="line"><span class="keyword">select</span> ename, hiredate</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="operator">=</span> (<span class="keyword">select</span> deptno</span><br><span class="line">                <span class="keyword">from</span> emp</span><br><span class="line">                <span class="keyword">where</span> <span class="built_in">lower</span>(ename) <span class="operator">=</span> <span class="string">&#x27;ford&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 21.查询工资比公司平均工资高的员工的员工号，姓名和工资。</span></span><br><span class="line"><span class="keyword">select</span> empno, ename, sal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal)</span><br><span class="line">              <span class="keyword">from</span> emp);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 22.查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</span></span><br><span class="line"><span class="keyword">select</span> empno,ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">in</span> (<span class="keyword">select</span> deptno</span><br><span class="line">                  <span class="keyword">from</span> emp</span><br><span class="line">                  <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;%U%&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 23.查询在CHICAGO工作的员工的员工号，job</span></span><br><span class="line"><span class="keyword">select</span> empno,&quot;JOB&quot;</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">in</span> (<span class="keyword">select</span> deptno</span><br><span class="line">                  <span class="keyword">from</span> dept</span><br><span class="line">                  <span class="keyword">where</span> loc <span class="operator">=</span> <span class="string">&#x27;CHICAGO&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 24.查询管理者是king的员工姓名和工资</span></span><br><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> mgr <span class="operator">=</span> (<span class="keyword">select</span> empno</span><br><span class="line">              <span class="keyword">from</span> emp</span><br><span class="line">              <span class="keyword">where</span> <span class="built_in">lower</span>(ename) <span class="operator">=</span> <span class="string">&#x27;king&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">oracle数据库的上机练习题2</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://wheliosc.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>CSS-positioning</title>
    <link href="https://wheliosc.github.io/CSS-positioning"/>
    <id>https://wheliosc.github.io/CSS-positioning</id>
    <published>2019-03-16T11:57:24.916Z</published>
    <updated>2021-08-30T07:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="CSS框模型"><a href="#CSS框模型" class="headerlink" title="CSS框模型"></a>CSS框模型</h2><p><img src="https://ws1.sinaimg.cn/large/006xwwY9ly1g15r99wzgnj306m050mxc.jpg" alt="CSS框模型"></p><ul><li>element: 元素。实际内容，属性有width和height，改变padding和margin不会影响实际内容（元素）的大小，仅会改变元素框的大小。</li><li>padding: 内边距。内边距呈现了元素的背景。背景应用于由内容和内边距、边框组成的区域。</li><li>border: 边框。内边距的边缘是边框。</li><li>margin: 外边距。外边距默认是透明的，因此不会遮挡其后的任何元素。值可以为负数。</li></ul><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>按照上、右、下、左的顺序分别设置各边的内边距，或者使用单独的属性设置，各边均可以使用不同的单位或百分比值。<br>百分数值是相对于其父元素的<strong> width </strong>计算的（不是相对于高度height）。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0.25em</span> <span class="number">2ex</span> <span class="number">20%</span>;&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">2ex</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20%</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>每个边框有 3 个方面：宽度、样式，以及颜色。<br>样式是边框最重要的一个方面，因为如果没有样式（默认为none），将根本没有边框。如果边框样式为 none，即边框根本不存在，那么边框就不可能有宽度，因此边框宽度自动设置为 0。</p><table>  <thead>表格来自W3CSchool</thead>  <tbody><tr>    <th>属性</th>    <th>描述</th>  </tr>  <tr>    <td>border</td>    <td>简写属性，用于把针对四个边的属性设置在一个声明。</td>  </tr>  <tr>    <td>border-style</td>    <td>用于设置元素所有边框的样式，或者单独地为各边设置边框样式。</td>  </tr>  <tr>    <td>border-width</td>    <td>简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</td>  </tr>  <tr>    <td>border-color</td>    <td>简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。</td>  </tr>  <tr>    <td>border-bottom</td>    <td>简写属性，用于把下边框的所有属性设置到一个声明中。</td>  </tr>  <tr>    <td>border-bottom-color</td>    <td>设置元素的下边框的颜色。</td>  </tr>  <tr>    <td>border-bottom-style</td>    <td>设置元素的下边框的样式。</td>  </tr>  <tr>    <td>border-bottom-width</td>    <td>设置元素的下边框的宽度。</td>  </tr>  <tr>    <td>border-left</td>    <td>简写属性，用于把左边框的所有属性设置到一个声明中。</td>  </tr>  <tr>    <td>border-left-color</td>    <td>设置元素的左边框的颜色。</td>  </tr>  <tr>    <td>border-left-style</td>    <td>设置元素的左边框的样式。</td>  </tr>  <tr>    <td>border-left-width</td>    <td>设置元素的左边框的宽度。</td>  </tr>  <tr>    <td>border-right</td>    <td>简写属性，用于把右边框的所有属性设置到一个声明中。</td>  </tr>  <tr>    <td>border-right-color</td>    <td>设置元素的右边框的颜色。</td>  </tr>  <tr>    <td>border-right-style</td>    <td>设置元素的右边框的样式。</td>  </tr>  <tr>    <td>border-right-width</td>    <td>设置元素的右边框的宽度。</td>  </tr>  <tr>    <td>border-top</td>    <td>简写属性，用于把上边框的所有属性设置到一个声明中。</td>  </tr>  <tr>    <td>border-top-color</td>    <td>设置元素的上边框的颜色。</td>  </tr>  <tr>    <td>border-top-style</td>    <td>设置元素的上边框的样式。</td>  </tr>  <tr>    <td>border-top-width</td>    <td>设置元素的上边框的宽度。</td>  </tr></tbody></table><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>margin除了和padding一样可以使用不同单位和百分比之外，还可以使用auto自适应。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0.25em</span> <span class="number">2ex</span> <span class="number">20%</span>;&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">2ex</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">20%</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* 百分比同样是相对于父元素的 width */</span></span><br></pre></td></tr></table></figure></p><h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><p><a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp">外边距会合并的情况</a></p><h2 id="CSS-position属性"><a href="#CSS-position属性" class="headerlink" title="CSS position属性"></a>CSS position属性</h2><ul><li>static 是默认值。任意 position: static; 的元素不会被特殊的定位。一个 static 元素表示它没有被“positioned”，一个 position 属性被设置为其他值的元素表示它被“positioned”。</li><li>relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</li><li>fixed 元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。top 、 right 、 bottom 和 left 属性都可用。</li><li>absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.w3school.com.cn/css/css_positioning.asp">W3CSchool-css-positioning</a><br><a href="http://zh.learnlayout.com/position.html">学习CSS布局</a></p>]]></content>
    
    
    <summary type="html">CSS框模型和CSS布局元素定位</summary>
    
    
    
    
    <category term="CSS" scheme="https://wheliosc.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS-层叠样式表</title>
    <link href="https://wheliosc.github.io/CSS-basic"/>
    <id>https://wheliosc.github.io/CSS-basic</id>
    <published>2019-03-15T08:25:48.258Z</published>
    <updated>2021-08-30T07:42:12.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="CSS是什么"><a href="#CSS是什么" class="headerlink" title="CSS是什么"></a>CSS是什么</h2><p>CSS指层叠样式表(<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)，样式定义如何显示HTML元素，样式通常存储在样式表中。</p><h2 id="插入样式表的方法"><a href="#插入样式表的方法" class="headerlink" title="插入样式表的方法"></a>插入样式表的方法</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>在相关的标签内使用样式（style）属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 20px&quot;</span>&gt;</span>This is a paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br>当样式仅需要在一个元素上应用一次时。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>使用 <code>&lt;style&gt;</code> 标签在文档头部定义内部样式表<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  hr &#123;<span class="attribute">color</span>: sienna;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;images/back40.gif&quot;</span>);&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当单个文档需要特殊的样式时，就应该使用内部样式表。</p><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当样式需要应用于很多页面时。</p><p>📌 不要在属性值与单位之间留有空格。使用 “margin-left: 20px” 而不是 “margin-left: 20 px”。</p><h3 id="多重样式的优先级"><a href="#多重样式的优先级" class="headerlink" title="多重样式的优先级"></a>多重样式的优先级</h3><p><strong>内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器缺省配置</strong><br>🌰 外部样式表拥有针对 h3 选择器的三个属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">8px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>而内部样式表拥有针对 h3 选择器的两个属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: right; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line"><span class="attribute">text-align</span>: right; </span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br></pre></td></tr></table></figure></p><h2 id="选择器的分类"><a href="#选择器的分类" class="headerlink" title="选择器的分类"></a>选择器的分类</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>用于修饰同类HTML标签的共性风格。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 所有的<span class="selector-tag">li</span>标签通用</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><ul><li>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</li><li>id 选择器以 “#” 来定义。<br>📌 HTML页面，不能出现相同的id，哪怕他们不是一个类型。比如页面上有一个id为pp的p，一个id为pp的div，是非法的！<br>📌 id区分大小写。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#para</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para&quot;</span>&gt;</span>this is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>在CSS中，类选择器以一个点号(.)表示。<br>多个标签可以公用一个类；同一个标签可以使用多个类选择器，用空格隔开。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>: center;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.important</span> &#123;<span class="attribute">font-size</span>: <span class="number">20px</span>; <span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">This heading will be center-aligned</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">This paragraph will also be center-aligned.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center important&quot;</span>&gt;</span>this is an important part.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错误写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span> <span class="attr">class</span>=<span class="string">&quot;important&quot;</span>&gt;</span>this is an important part.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>类选择器结合标签选择器来使用，例如，p.important解释为：“其class属性值为important的所有段落。“</p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>后代选择器可以选择作为某元素后代的元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> <span class="selector-class">.classone</span> &#123;<span class="attribute">color</span>: blue;&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-id">#image1</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个规则会把作为h1元素后代的em元素的文本变为红色。其他em文本（如段落或块引用中的em）则不会被这个规则选中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">em</span>&gt;</span>important<span class="tag">&lt;/<span class="name">em</span>&gt;</span> heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">em</span>&gt;</span>important<span class="tag">&lt;/<span class="name">em</span>&gt;</span> paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>📌 空格表示的只是一种后代关系，并不一定指紧跟其后的元素(儿子)。比如上例中，h1中的所有em标签都会应用该样式，不论嵌套深度是多少。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">em</span>&gt;</span>important<span class="tag">&lt;/<span class="name">em</span>&gt;</span> heading<span class="tag">&lt;<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>如果不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，使用子元素选择器。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &gt; <span class="selector-tag">strong</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line">// 可以结合使用后代选择器和子元素选择器</span><br><span class="line"><span class="selector-tag">h1</span> <span class="selector-tag">b</span> &gt; <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// <span class="selector-tag">h2</span><span class="selector-class">.important</span> 和 <span class="selector-tag">h2</span> <span class="selector-class">.important</span> 不是一回事</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.important</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#normaltext</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择的元素要求同时满足两个条件：必须是h2标签，然后必须是important类。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- h2.important作用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;important&quot;</span>&gt;</span> Important content! <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>逗号隔开选择器，三种基本选择器都可以放进来。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义了一个并集选择器，带有p,h1,id=&quot;mytitle&quot;,class=&quot;one&quot;的标签都内容会显示红色*/</span></span><br><span class="line"><span class="selector-tag">p</span>,<span class="selector-tag">h1</span>,<span class="selector-id">#mytitle</span>,<span class="selector-class">.one</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><h2 id="超链接的样式"><a href="#超链接的样式" class="headerlink" title="超链接的样式"></a>超链接的样式</h2><p>链接的四种状态：</p><ul><li>a:link  普通的、未被访问的链接</li><li>a:visited  用户已访问的链接</li><li>a:hover  鼠标指针位于链接的上方</li><li>a:active  链接被点击的时刻</li></ul><p>当为链接的不同状态设置样式时，按照以下次序规则：</p><ul><li>a:hover 必须位于 a:link 和 a:visited 之后</li><li>a:active 必须位于 a:hover 之后</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-class">.one</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#ff0000</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-class">.one</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#0000ff</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-class">.one</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#ffcc00</span>;&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/index.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>这个链接改变颜色<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/DYD850804/article/details/80997251">CSS的四种基本选择器和四种高级选择器</a><br><a href="http://www.w3school.com.cn/css/index.asp">W3CSchool</a><br><a href="https://www.cnblogs.com/zxjwlh/p/6213239.html">CSS选择器优先级总结</a></p>]]></content>
    
    
    <summary type="html">HTML中插入CSS的方式，以及CSS选择器的分类，超链接的样式</summary>
    
    
    
    
    <category term="CSS" scheme="https://wheliosc.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Oracle SQL练习题1</title>
    <link href="https://wheliosc.github.io/oracle-database-prictise-1"/>
    <id>https://wheliosc.github.io/oracle-database-prictise-1</id>
    <published>2019-03-15T04:12:08.733Z</published>
    <updated>2021-08-30T07:30:07.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="SQL-DDL-amp-DML"><a href="#SQL-DDL-amp-DML" class="headerlink" title="SQL DDL&amp;DML"></a>SQL DDL&amp;DML</h2><p><strong>对表copy_emp进行：</strong><br>1）在表copy_emp中插入数据，要求sal字段插入空值，部门号50，参加工作时间为2000年1月1日，其他字段随意<br>2）在表copy_emp中插入数据，要求把emp表中部门号为10号部门的员工信息插入<br>3）修改copy_emp表中数据，要求10号部门所有员工涨20%的工资<br>4）修改copy_emp表中sal为空的记录，工资修改为平均工资<br>5）把工资为平均工资的员工，工资修改为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy_emp (</span><br><span class="line">empno number(<span class="number">4</span>),</span><br><span class="line">ename varchar2(<span class="number">20</span>),</span><br><span class="line">hiredate <span class="type">date</span> <span class="keyword">default</span> sysdate,</span><br><span class="line">deptno number(<span class="number">2</span>),</span><br><span class="line">sal number(<span class="number">8</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据 sal字段插入空值，部门号50，参加工作时间为2000年1月1日，其他字段随意</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> copy_emp <span class="keyword">values</span>(<span class="number">7555</span>, <span class="string">&#x27;Ahui&#x27;</span>, to_date(<span class="string">&#x27;2000-01-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>),<span class="number">50</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据，要求把emp表中部门号为10号部门的员工信息插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">into</span> copy_emp</span><br><span class="line"><span class="keyword">values</span>(empno, ename, hiredate, deptno, sal)</span><br><span class="line"><span class="keyword">select</span> empno, ename, hiredate, deptno, sal</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10号部门所有员工涨20%的工资</span></span><br><span class="line">update copy_emp</span><br><span class="line"><span class="keyword">set</span> sal <span class="operator">=</span> sal <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改copy_emp表中sal为空的记录，工资修改为平均工资</span></span><br><span class="line">update copy_emp </span><br><span class="line"><span class="keyword">set</span> sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> copy_emp)</span><br><span class="line"><span class="keyword">where</span> sal <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把工资为平均工资的员工，工资修改为空</span></span><br><span class="line">update copy_emp </span><br><span class="line"><span class="keyword">set</span> sal <span class="operator">=</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">where</span> sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> copy_emp);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除工资为空的员工信息</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> copy_emp <span class="keyword">where</span> sal <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><strong>对表class2和student2进行：</strong><br>1）添加三个班级信息为：<br>  1，JAVA1班，null<br>  2，JAVA2班，null<br>  3，JAVA3班，null<br>2）添加学生信息如下：‘A001’,‘张三’,‘男’,‘01-5月-05’,100,1<br>3）添加学生信息如下：’A002’,’MIKE’,’男’,’1905-05-06’,10<br>4）插入部分学生信息： ‘A003’,’JOHN’,’女’<br>5）将A001学生性别修改为’女‘<br>6）将A001学生信息修改如下：性别为男，生日设置为1980-04-01<br>7）将生日为空的学生班级修改为Java3班<br>8）请使用一条SQL语句，使用子查询，更新班级表中每个班级的人数字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student2 ( <span class="comment">--学生表</span></span><br><span class="line">xh <span class="type">char</span>(<span class="number">4</span>),<span class="comment">--学号</span></span><br><span class="line">xm varchar2(<span class="number">10</span>),<span class="comment">--姓名</span></span><br><span class="line">sex <span class="type">char</span>(<span class="number">2</span>),<span class="comment">--性别</span></span><br><span class="line">birthday <span class="type">date</span>,<span class="comment">--出生日期</span></span><br><span class="line">sal number(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">--奖学金</span></span><br><span class="line">studentcid number(<span class="number">2</span>) <span class="comment">--学生班级号</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> class2 ( <span class="comment">--班级表</span></span><br><span class="line">classid number(<span class="number">2</span>), <span class="comment">--班级编号</span></span><br><span class="line">cname varchar2(<span class="number">20</span>),<span class="comment">--班级名称</span></span><br><span class="line">ccount number(<span class="number">3</span>) <span class="comment">--班级人数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> class2(classid,cname) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;JAVA1班&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> class2(classid,cname) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;JAVA2班&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> class2(classid,cname) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;JAVA3班&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student2 <span class="keyword">values</span>(<span class="string">&#x27;A001&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;01-5月-05&#x27;</span>,<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student2(xh,xm,sex,birthday,sal) <span class="keyword">values</span>(<span class="string">&#x27;A002&#x27;</span>,<span class="string">&#x27;MIKE&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,to_date(<span class="string">&#x27;1905-05-06&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>),<span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student2(xh,xm,sex) <span class="keyword">values</span>(<span class="string">&#x27;A003&#x27;</span>,<span class="string">&#x27;JOHN&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将A001学生性别修改为&#x27;女‘</span></span><br><span class="line"><span class="comment">-- 将A001学生信息修改如下：性别为男，生日设置为1980-04-01</span></span><br><span class="line">update student2 <span class="keyword">set</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> xh<span class="operator">=</span><span class="string">&#x27;A001&#x27;</span>;</span><br><span class="line">update student2 <span class="keyword">set</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">where</span> xh<span class="operator">=</span><span class="string">&#x27;A001&#x27;</span>;</span><br><span class="line">update student2 <span class="keyword">set</span> birthday<span class="operator">=</span>to_date(<span class="string">&#x27;1980-04-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">where</span> xh<span class="operator">=</span><span class="string">&#x27;A001&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将生日为空的学生班级修改为Java3班</span></span><br><span class="line">update student2 </span><br><span class="line"><span class="keyword">set</span> studentcid<span class="operator">=</span>(<span class="keyword">select</span> classid <span class="keyword">from</span> class2 <span class="keyword">where</span> class2.cname<span class="operator">=</span><span class="string">&#x27;JAVA3班&#x27;</span>) </span><br><span class="line"><span class="keyword">where</span> birthday <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 请使用一条SQL语句，使用子查询，更新班级表中每个班级的人数字段</span></span><br><span class="line">Update CLASS2 c2</span><br><span class="line">    <span class="keyword">Set</span> ccount<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">                 <span class="keyword">from</span> student2 s2</span><br><span class="line">                 <span class="keyword">where</span> c2.classid<span class="operator">=</span> s2.studentcid);</span><br></pre></td></tr></table></figure><p>1）创建表date_test,包含列d，类型为date型。试向date_test表中插入两条记录，一条当前系统日期记录，一<br>条记录为“1998-08-18”。<br>2）试为date_test表增加一列g，数据类型字符类型，长度2， 默认值“女”。<br>3）试修改date_test表，g列数据类型为定长字符型10位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入日期类型数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> DATE_TEST <span class="keyword">values</span>(to_date(<span class="string">&#x27;1998-08-18&#x27;</span>,<span class="string">&#x27;YYYY-MM-DD&#x27;</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> DATE_TEST <span class="keyword">values</span>(to_date(sysdate));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加列并设置默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> DATE_TEST <span class="keyword">add</span>( G  <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> DATE_TEST modify(G <span class="type">char</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><p>1）查询入职时间在1982-7-9之后，并且不从事SALESMAN工作的员工姓名、入职时间、职位。<br>2）查询员工姓名的第三个字母是a的员工姓名。<br>3）查询除了10、20号部门以外的员工姓名、部门编号。<br>4）查询部门号为30号员工的信息，先按工资降序排序，再按姓名升序排序。<br>5）查询没有上级的员工(经理号为空)的员工姓名。<br>6）查询工资大于等于4500并且部门为10或者20的员工的姓名\工资、部门编号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询入职时间在1982-7-9之后，并且不从事SALESMAN工作的员工姓名、入职时间、职位</span></span><br><span class="line"><span class="keyword">select</span> ename, hiredate, job</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> hiredate<span class="operator">&gt;</span>to_date(<span class="string">&#x27;1982-07-09&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">and</span> job <span class="operator">!=</span> <span class="string">&#x27;SALESMAN&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询员工姓名的第三个字母是A的员工姓名</span></span><br><span class="line"><span class="keyword">select</span> ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;__A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询除了10、20号部门以外的员工姓名、部门编号</span></span><br><span class="line"><span class="keyword">select</span> ename, deptno</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno<span class="operator">!=</span><span class="number">10</span> <span class="keyword">and</span> deptno<span class="operator">!=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询部门号为30号员工的信息，先按工资降序排序，再按姓名升序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">30</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>, ename <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询没有上级的员工(经理号为空)的员工姓名</span></span><br><span class="line"><span class="keyword">select</span> ename</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询工资大于等于4500并且部门为10或者20的员工的姓名\工资、部门编号</span></span><br><span class="line"><span class="keyword">select</span> ename, sal, deptno</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> sal<span class="operator">&gt;=</span><span class="number">4500</span> <span class="keyword">and</span> (deptno<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> deptno<span class="operator">=</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p><strong>创建如下表结构</strong><br>学生基本信息表<br>Student<br>Studentid —主键,学号<br>StudentName –学生姓名<br>StudentSex  -学生性别</p><p>课程信息表<br>Subject<br>SubjectID —主键，课程编号<br>SubjectName—课程名</p><p>成绩表<br>Studentid —联合主键,学生编号<br>SubjectID —联合主键,课程编号<br>Grade —成绩</p><p><strong>添加如下数据</strong><br>学生信息：<br>101,’张三’,’男’<br>102,’李云’,’女’<br>103,’小明’,’男’<br>104,’李四’,’男’</p><p>课程信息：<br>‘A01’,’C++’<br>‘A02’,’ASP’<br>‘A03’,’JAVA’</p><p>成绩信息：<br>101,’A01’,59<br>101,’A02’,72<br>101,’A03’,90<br>102,’A01’,75<br>102,’A02’,91<br>103,’A01’,71</p><p><strong>查询如下信息</strong><br>1）学号 学生姓名 课程名称 成绩 （要全部学生信息）<br>2）学号 学生姓名 课程名称 成绩（只显示每科最高分）<br>3）学号 学生姓名 课程名称 成绩 （成绩大于60时的显示及格，小于60时的显示不及格）<br>4）学号 学生姓名 （查询出选课超过1门以上学生的信息）<br>5）查询成绩大于90分为优秀的人数<br>6）求男生里面分数最高的那个同学的姓名，课程名，成绩<br>7）求没有成绩的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;李云&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;103&#x27;</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;104&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SUBJECT <span class="keyword">values</span>(<span class="string">&#x27;A01&#x27;</span>,<span class="string">&#x27;C++&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SUBJECT <span class="keyword">values</span>(<span class="string">&#x27;A02&#x27;</span>,<span class="string">&#x27;ASP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SUBJECT <span class="keyword">values</span>(<span class="string">&#x27;A03&#x27;</span>,<span class="string">&#x27;JAVA&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> GRADETABLE <span class="keyword">values</span>(<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;A01&#x27;</span>,<span class="number">59</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> GRADETABLE <span class="keyword">values</span>(<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;A02&#x27;</span>,<span class="number">72</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> GRADETABLE <span class="keyword">values</span>(<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;A03&#x27;</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> GRADETABLE <span class="keyword">values</span>(<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;A01&#x27;</span>,<span class="number">75</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> GRADETABLE <span class="keyword">values</span>(<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;A02&#x27;</span>,<span class="number">91</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> GRADETABLE <span class="keyword">values</span>(<span class="string">&#x27;103&#x27;</span>,<span class="string">&#x27;A01&#x27;</span>,<span class="number">71</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学号 学生姓名 课程名称 成绩 （要全部学生信息）</span></span><br><span class="line"><span class="keyword">select</span> st.studentid, st.studentname, su.subjectname, gr.grade</span><br><span class="line"><span class="keyword">from</span> STUDENT st <span class="keyword">left</span> <span class="keyword">join</span> GRADETABLE gr <span class="keyword">on</span> gr.studentid <span class="operator">=</span> st.studentid </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> subject su <span class="keyword">on</span> gr.subjectid <span class="operator">=</span> su.subjectid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学号 学生姓名 课程名称 成绩（只显示每科最高分）</span></span><br><span class="line"><span class="keyword">select</span> st.studentid, st.studentname, su.subjectname, tab.grade</span><br><span class="line"><span class="keyword">from</span> student st, subject su, (<span class="keyword">select</span> studentid, subjectid, grade</span><br><span class="line">                                <span class="keyword">from</span> gradetable</span><br><span class="line">                                <span class="keyword">where</span> (subjectid,grade) <span class="keyword">in</span> (<span class="keyword">select</span> subjectid, <span class="built_in">max</span>(grade)</span><br><span class="line">                                <span class="keyword">from</span> gradetable</span><br><span class="line">                                <span class="keyword">group</span> <span class="keyword">by</span> subjectid)) tab</span><br><span class="line"><span class="keyword">where</span> st.studentid <span class="operator">=</span> tab.studentid <span class="keyword">and</span> su.subjectid <span class="operator">=</span> tab.subjectid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学号 学生姓名 课程名称 成绩 （成绩大于60时的显示及格，小于60时的显示不及格）</span></span><br><span class="line"><span class="keyword">select</span> st.studentid, st.studentname, su.subjectname, </span><br><span class="line">        decode(sign(gr.grade<span class="number">-60</span>), <span class="number">-1</span>, <span class="string">&#x27;不及格&#x27;</span>,<span class="string">&#x27;及格&#x27;</span>) 是否及格</span><br><span class="line"><span class="keyword">from</span> GRADETABLE gr,STUDENT st, subject su</span><br><span class="line"><span class="keyword">where</span> gr.studentid <span class="operator">=</span> st.studentid <span class="keyword">and</span> gr.subjectid <span class="operator">=</span> su.subjectid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学号 学生姓名 （查询出选课超过1门以上学生的信息）</span></span><br><span class="line"><span class="keyword">select</span> st.studentid, st.studentname</span><br><span class="line"><span class="keyword">from</span> gradetable gr <span class="keyword">left</span> <span class="keyword">join</span> student st <span class="keyword">on</span> st.STUDENTID <span class="operator">=</span> gr.STUDENTID</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> st.STUDENTID,st.studentname</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询成绩大于90分为优秀的人数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> gradetable</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> studentid</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">max</span>(grade) <span class="operator">&gt;</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求男生里面分数最高的那个同学的姓名，课程名，成绩</span></span><br><span class="line"><span class="keyword">select</span> st.studentname, su.subjectname, gr.grade</span><br><span class="line"><span class="keyword">from</span> student st, subject su, gradetable gr</span><br><span class="line"><span class="keyword">where</span> st.studentid <span class="operator">=</span> gr.studentid <span class="keyword">and</span> su.subjectid <span class="operator">=</span> gr.subjectid</span><br><span class="line">        <span class="keyword">and</span> st.studentsex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> </span><br><span class="line">        <span class="keyword">and</span> gr.grade <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(grade) <span class="keyword">from</span> (<span class="keyword">select</span> studentid <span class="keyword">from</span> student <span class="keyword">where</span> studentsex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>) <span class="keyword">natural</span> <span class="keyword">join</span> gradetable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求没有成绩的学生姓名</span></span><br><span class="line"><span class="keyword">select</span> s.studentname</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">where</span> s.studentid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> gr.studentid</span><br><span class="line">                          <span class="keyword">from</span> gradetable gr);</span><br></pre></td></tr></table></figure><p><br/></p>]]></content>
    
    
    <summary type="html">oracle数据库的上机练习题1</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="oracle" scheme="https://wheliosc.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>HTML基本标签</title>
    <link href="https://wheliosc.github.io/basic-html-tags"/>
    <id>https://wheliosc.github.io/basic-html-tags</id>
    <published>2019-03-10T05:52:02.875Z</published>
    <updated>2021-08-30T07:52:25.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="HTML是什么"><a href="#HTML是什么" class="headerlink" title="HTML是什么"></a>HTML是什么</h2><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li></ul><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>这是网站标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    网站的各种内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><table>    <tbody>        <tr>            <th>属性</th>            <th>值</th>            <th>描述</th>        </tr>        <tr>            <td rowspan="4">http-equiv</td>            <td>Content-Type</td>            <td>描述文档类型和字符编码</td>        <tr>            <td>expires</td>            <td>浏览器缓存有效性的期限，在这个时间（GMT）之内相同的请求使用缓存，这个时间之外使用http请求。</td>        </tr>        <tr>            <td>Refresh</td>            <td>content="2; URL=https://liyzy.github.io" 指两秒后跳转到指定页面。</td>        </tr>                <tr>            <td>Set-Cookie</td>            <td>Content="cookievalue=xxx; expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/" 如果网页过期，那么存盘的cookie将被删除。</td>        </tr>                <tr>               <td rowspan="2">name</td>            <td>Keywords</td>            <td>说明网站的关键词是什么</td>        </tr>        <tr>            <td>description</td>            <td>介绍网站内容</td>        </tr>    </tbody></table><h3 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h3><p><table>    <tbody>        <tr>            <th>标签</th>            <th>用法</th>            <th>说明</th>        </tr>        <tr>            <td>标题标签</td>            <td>&lt;h1&gt;&lt;/h1&gt;</td>            <td>一共有6级，从h1到h6</td>        </tr>        <tr>            <td>段落标签</td>            <td>&lt;p&gt;&lt;/p&gt;</td>            <td>&nbsp;</td>        </tr>        <tr>            <td>水平线标签</td>            <td>&lt;hr/&gt;</td>            <td>单个闭合标签</td>        </tr>        <tr>            <td>div标签</td>            <td>&lt;div&gt;&lt;/div&gt;</td>            <td>把文档分割为独立的、不同的部分。</td>        </tr>        <tr>            <td>表单标签</td>            <td>&lt;form&gt;&lt;/form&gt;</td>            <td>为用户输入创建 HTML 表单。</td>        </tr>        <tr>            <td>换行标签</td>            <td>&lt;br/&gt;</td>            <td>插入一个简单的换行符</td>        </tr>        <tr>            <td>span标签</td>            <td>&lt;span&gt;&lt;/span&gt;</td>            <td>当对它应用样式时，它才会产生视觉上的变化。</td>        </tr>        <tr>            <td>图像标签</td>            <td>&lt;img src="图片路径" alt="提示文字" title="提示文字"/&gt;</td>            <td></td>        </tr>    </tbody></table><br>🔖后三个是行级标签，前五个是块级标签。</p><h3 id="有序（无序）列表标签"><a href="#有序（无序）列表标签" class="headerlink" title="有序（无序）列表标签"></a>有序（无序）列表标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 有序列表标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>有效学习的步骤<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>课前主动预习<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>课上认真听讲<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>课后积极复习<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 无序列表标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>有效学习的要素<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>主动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>认真<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>积极<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义描述标签"><a href="#定义描述标签" class="headerlink" title="定义描述标签"></a>定义描述标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;Miyazono Kaori.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;245&quot;</span> <span class="attr">height</span>=<span class="string">&quot;311&quot;</span> <span class="attr">title</span>=<span class="string">&quot;宫园 薰&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>宫园薰，日本动漫《四月是你的谎言》女主角。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>幼时原本学习弹奏钢琴，后因有马公生影响成为小提琴手。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>通过一封亲笔书信向公生传达了近10年的爱慕。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在当前窗口打开链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://liyzy.github.io&quot;</span>&gt;</span>我的博客网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在新的浏览器窗口打开链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://liyzy.github.io&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>我的博客网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 图片链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://liyzy.github.io&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.png&quot;</span> <span class="attr">title</span>=<span class="string">&quot;跳转到博客&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 功能性链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:2469660964@qq.com?subject=Hello%20world&quot;</span>&gt;</span>个人信箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面内的锚链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>查看 Chapter 4。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Chapter 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This chapter explains ba bla bla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Chapter 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This chapter explains ba bla bla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Chapter 3<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This chapter explains ba bla bla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;C4&quot;</span>&gt;</span>Chapter 4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This chapter explains ba bla bla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Chapter 5<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This chapter explains ba bla bla<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面间的锚链接，假设当前是first.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;second.html#student&quot;</span>&gt;</span>跳转到另一个页面的student区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- second.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span>&gt;</span>Student<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>因为&lt;&gt;等符号在HTML中已使用，所以必须用其他符号来代替.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>    小于(&lt;)</span><br><span class="line"><span class="symbol">&amp;gt;</span>    大于(&gt;)</span><br><span class="line"><span class="symbol">&amp;nbsp;</span>  空格</span><br><span class="line"><span class="symbol">&amp;copy;</span>  版权号</span><br><span class="line"><span class="symbol">&amp;quot;</span>  引号</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.w3school.com.cn/h.asp">W3CSchool</a></p>]]></content>
    
    
    <summary type="html">HTML的基本标签用法</summary>
    
    
    
    
    <category term="HTML" scheme="https://wheliosc.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>二倍角公式</title>
    <link href="https://wheliosc.github.io/the-double-angle-formula"/>
    <id>https://wheliosc.github.io/the-double-angle-formula</id>
    <published>2019-03-10T04:37:12.769Z</published>
    <updated>2021-08-30T07:28:57.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="二倍角公式"><a href="#二倍角公式" class="headerlink" title="二倍角公式"></a>二倍角公式</h2><p>正弦形式<br>$\sin 2 \alpha = 2 \sin \alpha \cos \alpha$<br>余弦形式<br>$\cos 2 \alpha = 2 \cos ^ { 2 } \alpha - 1 = 1 - 2 \sin ^ { 2 } \alpha$<br>$= \cos ^ { 2 } \alpha - \sin ^ { 2 } \alpha = \frac { 1 - \tan ^ { 2 } \alpha } { 1 + \tan ^ { 2 } \alpha }$<br>正切形式<br>$\tan 2 \alpha = \frac { 2 \tan \alpha } { 1 - \tan ^ { 2 } \alpha } = \frac { 2 \cot \alpha } { \cot ^ { 2 } \alpha - 1 } = \frac { 2 } { \cot \alpha - \tan \alpha }$<br>🔖在正弦和余弦二倍角公式中，角$\alpha$可以为任意角，但正切二倍角公式中，只有当$\alpha \neq \frac { \pi } { 2 } + k \pi$及$\alpha \neq \frac { \pi } { 4 } + \frac { k \pi } { 2 } ( k \in Z )$时才成立；</p><h2 id="升（降）幂公式"><a href="#升（降）幂公式" class="headerlink" title="升（降）幂公式"></a>升（降）幂公式</h2><p>$\cos ^ { 2 } \alpha = \frac { 1 + \cos 2 \alpha } { 2 } , \sin ^ { 2 } \alpha = \frac { 1 - \cos 2 \alpha } { 2 }$<br>$1 + \cos 2 \alpha = 2 \cos ^ { 2 } \alpha , 1 - \cos 2 \alpha = 2 \sin ^ { 2 } \alpha , 1 \pm \sin 2 \alpha = ( \sin \alpha \pm \cos \alpha ) ^ { 2 }$</p>]]></content>
    
    
    <summary type="html">二倍角公式的正弦形式、余弦形式、正切形式和升降幂公式。</summary>
    
    
    
    
    <category term="工数" scheme="https://wheliosc.github.io/tags/%E5%B7%A5%E6%95%B0/"/>
    
    <category term="考研" scheme="https://wheliosc.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Python内置模块Collections</title>
    <link href="https://wheliosc.github.io/python-collection"/>
    <id>https://wheliosc.github.io/python-collection</id>
    <published>2019-01-24T03:23:06.789Z</published>
    <updated>2021-08-30T07:56:16.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple()"></a>namedtuple()</h2><p>factory function for creating tuple subclasses with named fields<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 练习使用namedtuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># namedtuple的三种声明方式</span></span><br><span class="line">Circle = namedtuple(<span class="string">&#x27;Circle&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]) </span><br><span class="line"><span class="comment"># Circle = namedtuple(&#x27;Circle&#x27;, &#x27;x y r&#x27;)</span></span><br><span class="line"><span class="comment"># Circle = namedtuple(&#x27;Circle&#x27;, &#x27;x, y, r&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">c1, c2</span>):</span></span><br><span class="line">    dis_of_circle_center = sqrt((c1.x - c2.x) ** <span class="number">2</span> + (c1.y - c2.y) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> dis_of_circle_center == <span class="number">0</span> <span class="keyword">and</span> c1.r == c2.r:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两圆重合，既是内切也是内含也是相交&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> dis_of_circle_center &lt; <span class="built_in">abs</span>(c1.r - c2[<span class="number">2</span>]):  <span class="comment"># c2.r和c2[2]是效果相同的两种索引方式</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;内含&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> dis_of_circle_center == <span class="built_in">abs</span>(c1.r - c2.r):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两圆内切&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">abs</span>(c1.r - c2.r) &lt; dis_of_circle_center &lt; c1.r + c2.r:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两圆相交&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> dis_of_circle_center == c1.r+c2.r:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两圆外切&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;外离&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x1 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆1的圆心坐标x：&#x27;</span>))</span><br><span class="line">    y1 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆1的圆心坐标y：&#x27;</span>))</span><br><span class="line">    r1 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆1的半径r：&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    x2 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆2的圆心坐标x：&#x27;</span>))</span><br><span class="line">    y2 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆2的圆心坐标y：&#x27;</span>))</span><br><span class="line">    r2 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆2的半径r：&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    circle1 = Circle(x1, y1, r1)</span><br><span class="line">    circle2 = Circle(x2, y2, r2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(circle1, circle2)  <span class="comment"># Circle(x=1.0, y=2.0, r=3.0) Circle(x=4.0, y=5.0, r=6.0)</span></span><br><span class="line"></span><br><span class="line">    judge(circle1, circle2)</span><br></pre></td></tr></table></figure></p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>list-like container with fast appends and pops on either end. </p><blockquote><p>It is short for “double-ended queue”. Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.<br>Though list objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for pop(0) and insert(0, v) operations which change both the size and position of the underlying data representation.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># deque操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">d1 = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># append(x) Add x to the right side of the deque.</span></span><br><span class="line">d1.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># deque([1, 2, 3, [4, 5], 6])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendleft(x) Add x to the left side of the deque.</span></span><br><span class="line">d1.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># deque([0, 1, 2, 3, [4, 5], 6])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy() 浅拷贝</span></span><br><span class="line">d2 = d1.copy()</span><br><span class="line"><span class="built_in">print</span>(d2)  <span class="comment"># deque([0, 1, 2, 3, [4, 5], 6])</span></span><br><span class="line">d1.pop()</span><br><span class="line"><span class="built_in">print</span>(d1, d2)  <span class="comment"># deque([0, 1, 2, 3, [4, 5]]) deque([0, 1, 2, 3, [4, 5], 6])</span></span><br><span class="line">d1.popleft()</span><br><span class="line"><span class="built_in">print</span>(d1, d2)  <span class="comment"># deque([1, 2, 3, [4, 5]]) deque([0, 1, 2, 3, [4, 5], 6])</span></span><br><span class="line">d1.append(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(d1, d2)  <span class="comment"># deque([1, 2, 3, [4, 5], 7]) deque([0, 1, 2, 3, [4, 5], 6])</span></span><br><span class="line"><span class="comment"># 改变原list中引用的子list的值时，d2中的对应值也会变化</span></span><br><span class="line">d1[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(d1, d2)  <span class="comment"># deque([1, 2, 3, [8, 5], 7]) deque([0, 1, 2, 3, [8, 5], 6])</span></span><br><span class="line"><span class="comment"># extend(iterable) Extend the right side of the deque by appending elements from the iterable argument.</span></span><br><span class="line">d1.extend([<span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(d1, d2)  <span class="comment"># deque([1, 2, 3, [8, 5], 7, 9, 10]) deque([0, 1, 2, 3, [8, 5], 6])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extendleft(iterable) Extend the left side of the deque by appending elements from iterable.</span></span><br><span class="line"><span class="comment"># Note, the series of left appends results in reversing the order of elements in the iterable argument.</span></span><br><span class="line">d1.extendleft([<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># deque([-3, -2, -1, 0, 1, 2, 3, [8, 5], 7, 9, 10])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># count(x) Count the number of deque elements equal to x.</span></span><br><span class="line"><span class="built_in">print</span>(d1.count(<span class="number">5</span>))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(d1.count(<span class="number">0</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index(x) Returns the position of x firstly match in the deque</span></span><br><span class="line"><span class="built_in">print</span>(d1.index(<span class="number">5</span>))  <span class="comment"># ValueError: 5 is not in deque</span></span><br><span class="line"><span class="built_in">print</span>(d1.index(<span class="number">0</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove(value) Remove the first occurrence of value.</span></span><br><span class="line">d1.append(<span class="number">0</span>)</span><br><span class="line">d1.remove(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># deque([-3, -2, -1, 1, 2, 3, [8, 5], 7, 9, 10, 0])</span></span><br><span class="line"><span class="built_in">print</span>(d1.remove(<span class="number">5</span>))  <span class="comment"># ValueError: deque.remove(x): x not in deque</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse() Reverse the elements of the deque in-place and then return None.</span></span><br><span class="line">d1.reverse()</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># deque([0, 10, 9, 7, [8, 5], 3, 2, 1, -1, -2, -3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clear()</span></span><br><span class="line"><span class="built_in">print</span>(d1.clear())  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d3 = deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d3)  <span class="comment"># deque([1, 2, 3, 4], maxlen=4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># insert(i, x) Insert x into the deque at position i.</span></span><br><span class="line"><span class="comment"># If the insertion would cause a bounded deque to grow beyond maxlen, an IndexError is raised.</span></span><br><span class="line">d3.pop()</span><br><span class="line">d3.insert(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(d3)  <span class="comment"># deque([1, 5, 2, 3], maxlen=4)</span></span><br><span class="line"><span class="built_in">print</span>(d3.insert(<span class="number">5</span>, <span class="number">2</span>))  <span class="comment"># IndexError: deque already at its maximum size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate(n=1) Rotate the deque n steps to the right(顺时针). If n is negative, rotate to the left(逆时针).</span></span><br><span class="line"><span class="comment"># When the deque is not empty, rotating one step to the right is equivalent to d.appendleft(d.pop())</span></span><br><span class="line"><span class="comment"># and rotating one step to the left is equivalent to d.append(d.popleft()).</span></span><br><span class="line">d3.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(d3)  <span class="comment"># deque([5, 2, 3, 1], maxlen=4)</span></span><br><span class="line">d3.rotate(-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(d3)  <span class="comment"># deque([3, 1, 5, 2], maxlen=4)</span></span><br><span class="line"></span><br><span class="line">d4 = d3.copy()</span><br><span class="line">d3[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(d3, d4)  <span class="comment"># deque([3, 1, 4, 2], maxlen=4) deque([3, 1, 5, 2], maxlen=4)</span></span><br></pre></td></tr></table></figure><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>dict subclass for counting hashable objects.</p><blockquote><p>A Counter is a dict subclass for counting hashable objects. It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages.</p></blockquote><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = Counter()  <span class="comment"># a new, empty counter</span></span><br><span class="line">c2 = Counter(<span class="string">&#x27;gallahad&#x27;</span>)  <span class="comment"># a new counter from an iterable</span></span><br><span class="line">c3 = Counter(&#123;<span class="string">&#x27;red&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;blue&#x27;</span>: <span class="number">2</span>&#125;)  <span class="comment"># a new counter from a mapping</span></span><br><span class="line">c4 = Counter(cats=<span class="number">4</span>, dogs=<span class="number">8</span>, birds=<span class="number">14</span>)  <span class="comment"># a new counter from keyword args</span></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>elements()</code> requires integer counts. It ignores zero and negative counts. Return an iterator over elements repeating each as many times as its count. Elements are returned in <strong>arbitrary</strong>(随意的) order.</li><li><code>most_common([n])</code> Return a list of the n most common elements and their counts from the most common to the least. Elements with equal counts are ordered arbitrarily.</li><li><code>subtract([iterable-or-mapping])</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c5 = Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">c6 = Counter(&#123;<span class="string">&#x27;a&#x27;</span>: -<span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">c5.subtract(c6)</span><br><span class="line"><span class="built_in">print</span>(c5)  <span class="comment"># Counter(&#123;&#x27;a&#x27;: 5, &#x27;d&#x27;: 4, &#x27;c&#x27;: 2, &#x27;b&#x27;: 0, &#x27;e&#x27;: -4&#125;)</span></span><br><span class="line"><span class="comment"># 在c5中e的计数为0，把Counter中的一个元素的值设为0并没有把这个元素从Counter中移除，要真正的移除使用del c[&#x27;a&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(c5 - c6)  # Counter(&#123;&#x27;a&#x27;: 5, &#x27;d&#x27;: 4, &#x27;c&#x27;: 2&#125;)</span></span><br><span class="line"><span class="comment"># 直接使用减号是将c5中与c6中键值都相同的元素删除，键相同值不同的元素值相减</span></span><br></pre></td></tr></table></figure></li><li><p><code>update()</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c5 = Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">c6 = Counter(&#123;<span class="string">&#x27;a&#x27;</span>: -<span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line"></span><br><span class="line">c5.update(c6)</span><br><span class="line"><span class="built_in">print</span>(c5)  <span class="comment"># Counter(&#123;&#x27;b&#x27;: 4, &#x27;c&#x27;: 4, &#x27;d&#x27;: 4, &#x27;e&#x27;: 4, &#x27;a&#x27;: -3&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>Others</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c + d                       <span class="comment"># add two counters together:  c[x] + d[x]</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c - d                       <span class="comment"># subtract (keeping only positive counts)</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c &amp; d                       <span class="comment"># intersection:  min(c[x], d[x]) # doctest: +SKIP</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c | d                       <span class="comment"># union:  max(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><p>dict subclass that remembers the order entries were added.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># regular unsorted dictionary</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;banana&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;apple&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;orange&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dictionary sorted by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>OrderedDict(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>]))</span><br><span class="line">OrderedDict([(<span class="string">&#x27;apple&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;pear&#x27;</span>, <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dictionary sorted by value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>OrderedDict(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">1</span>]))</span><br><span class="line">OrderedDict([(<span class="string">&#x27;pear&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;apple&#x27;</span>, <span class="number">4</span>)])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dictionary sorted by length of the key string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>OrderedDict(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> t: <span class="built_in">len</span>(t[<span class="number">0</span>])))</span><br><span class="line">OrderedDict([(<span class="string">&#x27;pear&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;apple&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure></p><ul><li><p><code>popitem(last=True)</code><br>The popitem() method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in LIFO order if last is true or FIFO order if false.</p></li><li><p><code>move_to_end(key, last=True)</code><br>Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises KeyError if the key does not exist.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = OrderedDict.fromkeys(<span class="string">&#x27;abcde&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.move_to_end(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(d.keys())</span><br><span class="line"><span class="string">&#x27;acdeb&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.move_to_end(<span class="string">&#x27;b&#x27;</span>, last=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(d.keys())</span><br><span class="line"><span class="string">&#x27;bacde&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://docs.python.org/3/library/collections.html">python.org</a></p><p><br/></p>]]></content>
    
    
    <summary type="html">Python的内置模块Collections，包括namedtuple，deque，Counter，OrderedDict</summary>
    
    
    
    
    <category term="Python" scheme="https://wheliosc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>hexo问题记录(持续更新...)</title>
    <link href="https://wheliosc.github.io/hexo"/>
    <id>https://wheliosc.github.io/hexo</id>
    <published>2019-01-17T09:29:58.940Z</published>
    <updated>2021-08-30T07:26:10.207Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h4 id="大写开头的标签出现404"><a href="#大写开头的标签出现404" class="headerlink" title="大写开头的标签出现404"></a>大写开头的标签出现404</h4><p>这个问题实际是由于Windows平台上的Git，默认设置了大小写不敏感导致的。<br>进入.deploy_git文件夹，修改.git下的 config 文件，将 ignorecase=true 改为 ignorecase=false</p>]]></content>
    
    
    <summary type="html">折腾hexo过程中出现的各种问题的记录</summary>
    
    
    
    
    <category term="hexo" scheme="https://wheliosc.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>The Zen of Pyhton(Python之禅)</title>
    <link href="https://wheliosc.github.io/the-zen-of-python"/>
    <id>https://wheliosc.github.io/the-zen-of-python</id>
    <published>2019-01-15T06:01:43.483Z</published>
    <updated>2021-08-30T07:56:56.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><p>今天看Python的时候，发现原来在Python中有这样一个彩蛋：The Zen of Python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#x27;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#x27;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#x27;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#x27;s do more of those!</span><br></pre></td></tr></table></figure><p>这是Tim Peter写的Python编程和设计的指导原则，即Python之禅，this.py中对原文的内容用了凯撒密码加密，明文对应密文字母右移13位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;Gur Mra bs Clguba, ol Gvz Crgref</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Ornhgvshy vf orggre guna htyl.</span></span><br><span class="line"><span class="string">Rkcyvpvg vf orggre guna vzcyvpvg.</span></span><br><span class="line"><span class="string">Fvzcyr vf orggre guna pbzcyrk.</span></span><br><span class="line"><span class="string">Pbzcyrk vf orggre guna pbzcyvpngrq.</span></span><br><span class="line"><span class="string">Syng vf orggre guna arfgrq.</span></span><br><span class="line"><span class="string">Fcnefr vf orggre guna qrafr.</span></span><br><span class="line"><span class="string">Ernqnovyvgl pbhagf.</span></span><br><span class="line"><span class="string">Fcrpvny pnfrf nera&#x27;g fcrpvny rabhtu gb oernx gur ehyrf.</span></span><br><span class="line"><span class="string">Nygubhtu cenpgvpnyvgl orngf chevgl.</span></span><br><span class="line"><span class="string">Reebef fubhyq arire cnff fvyragyl.</span></span><br><span class="line"><span class="string">Hayrff rkcyvpvgyl fvyraprq.</span></span><br><span class="line"><span class="string">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span></span><br><span class="line"><span class="string">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span></span><br><span class="line"><span class="string">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&#x27;er Qhgpu.</span></span><br><span class="line"><span class="string">Abj vf orggre guna arire.</span></span><br><span class="line"><span class="string">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg&#x27;f n onq vqrn.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span></span><br><span class="line"><span class="string">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg&#x27;f qb zber bs gubfr!&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        d[<span class="built_in">chr</span>(i+c)] = <span class="built_in">chr</span>((i+<span class="number">13</span>) % <span class="number">26</span> + c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s]))</span><br></pre></td></tr></table></figure><ul><li><code>chr()</code>用一个范围在range(256)内的整数作参数，返回当前整数对应的ASCII字符</li></ul><p>输出的Python编程和设计的指导原则值得学习，中文翻译如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标） </span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） </span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） </span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） </span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） </span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） </span><br><span class="line">可读性很重要（优美的代码是可读的） </span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） </span><br><span class="line">不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） </span><br><span class="line">当存在多种可能，不要尝试去猜测 </span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） </span><br><span class="line">虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） </span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） </span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） </span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br><span class="line"></span><br><span class="line">cv: douban 萝卜特(vzever)</span><br></pre></td></tr></table></figure></p><p><br/></p>]]></content>
    
    
    <summary type="html">Pyhton中的一个彩蛋，内容是Python编程和设计的指导原则</summary>
    
    
    
    
    <category term="Python" scheme="https://wheliosc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>软件工程[4] 总体设计</title>
    <link href="https://wheliosc.github.io/system-design"/>
    <id>https://wheliosc.github.io/system-design</id>
    <published>2019-01-08T07:52:58.452Z</published>
    <updated>2021-08-30T07:56:36.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><h4 id="总体设计的两个阶段"><a href="#总体设计的两个阶段" class="headerlink" title="总体设计的两个阶段"></a>总体设计的两个阶段</h4><ul><li>系统设计阶段：确定系统的具体实现方案</li><li>结构设计阶段：确定软件结构</li></ul><p>🔖系统设计关注：物理组成、成本、工期，这些都是方案的组成部分。</p><h4 id="典型的总体设计过程"><a href="#典型的总体设计过程" class="headerlink" title="典型的总体设计过程"></a>典型的总体设计过程</h4><ul><li>设想供选择的方案</li><li>选取合理的方案</li><li>推荐最佳方案</li><li>功能分解</li><li>设计软件结构</li><li>设计数据库</li><li>制定测试计划</li><li>书写文档</li><li>审查与复审</li></ul><p>🔖文档包括：系统说明、用户手册、测试计划、详细的实现计划和数据库的设计结果。</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。<br>模块化的理论依据是$E(P_1+P_2)&gt;E(P_1)+E(P_2)$，$E(P)$代表解决P问题的成本，即把复杂的问题分解成许多容易解决的小问题，从而降低成本。但随着模块数的增多，接口成本会随之增加，所以应根据这两个因素，得到最适当的模块数。</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽出事务的本质特性——事物、状态或过程之间总存在着某些相似的方面(共性)——而暂时不考虑它们的细节，它是人类认识复杂事物时最有力的思维工具。从抽象到具体分析和构造软件的层次结构，是进行软件设计的一种有效的方法。<br>复杂的动态系统：高级的抽象概念构造和理解$\rightarrow$较低的层次$\rightarrow$ … $\rightarrow$最低层次、具体元素</p><h4 id="逐步求精"><a href="#逐步求精" class="headerlink" title="逐步求精"></a>逐步求精</h4><p>“为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。”<br>帮助软件工程师把精力集中在与当前开发阶段最相关的方面；目前不需要考虑的细节留到以后考虑；把一个时期内必须解决的问题按照优先级排序；自顶向下的策略。<br>求精实际上是细化过程。抽象使得设计者能够说明过程和数据，同时却忽略低层细节。事实上，可以把抽象看作是一种通过忽略多余的细节同时强调有关的细节，而实现逐步求精的方法。求精帮助设计者在设计过程中揭示出低层细节。</p><h4 id="信息隐藏与局部化"><a href="#信息隐藏与局部化" class="headerlink" title="信息隐藏与局部化"></a>信息隐藏与局部化</h4><p>局部化是指把一些关系密切的软件元素物理地放得彼此靠近。在模块中使用局部数据是局部化的一个例子。<br>信息隐藏指的是应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</p><h4 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h4><p>“模块独立”概念是模块化、抽象、逐步求精和信息隐藏等概念的直接结果，也是完成有效的模块设计的基本标准。<br>模块的独立程度可以由两个定性标准来度量，这两个标准分别称为耦合(Coupling)和内聚(Cohesion)。</p><ul><li>耦合衡量<strong>不同模块</strong>彼此间互相依赖(连接)紧密程度</li><li>内聚衡量<strong>一个模块</strong>内部各个元素彼此结合的紧密程度</li></ul><p>📌好的设计应力争：高内聚低耦合</p><h5 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h5><p>耦合的强弱取决于模块间接口的复杂程度，进入或访问一个模块的点，以及通过接口的数据。<br>在软件设计中应该追求尽可能松散耦合的系统。在这样的系统中可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解。此外，由于模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小。<br>因此，模块间的耦合程度的强弱将直接影响系统的可理解性、可测试性、可靠性和可维护性。</p><ul><li>数据耦合<br>一个模块访问另一个模块时，彼此之间是通过简单数据参数 (不是控制参数、公共数据结构或外部变量)  来交换输入、输出信息。</li><li>控制耦合<br>传递的信息中有控制信息，尽管有时这种控制信息是数据的形式。控制耦合可以把模块适当分解后用数据耦合代替它。</li><li>特征耦合<br>把整个数据结构作为参数传递，而被调用的模块仅需使用其中一部分数据。</li><li>公共环境耦合<br>一组模块都访问同一个公共数据环境，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</li><li>内容耦合<br>最高程度的耦合。出现以下情况之一就是发生了内容耦合：<ul><li>一个模块直接访问另一个模块的内部数据</li><li>一个模块不通过正常入口转到另一模块内部(goto语句)</li><li>两个模块有一部分程序代码重迭(只可能出现在汇编语言中)</li><li>一个模块有多个入口(一个模块有几种功能)</li></ul></li></ul><p>🔖公共环境耦合的复杂程度随耦合模块的个数增加而显著增加。若只是两模块间有公共数据环境，则公共耦合有两种情况：松散公共环境耦合和紧密环境公共耦合。</p><ul><li>松散公共环境耦合。一个模块往公共环境送数据，一个模块从中取数据，这是数据耦合的一种形式。</li><li>紧密环境公共耦合。两个模块都既往公共环境中送数据又从中取数据，介于数据耦合和控制耦合之间。</li></ul><p>📌设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全避免内容耦合。</p><h5 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h5><p>内聚标志一个模块内各个元素彼此结合的紧密程度，理想内聚的模块只做一件事情。设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多。<br>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。</p><p>低内聚</p><ul><li>偶然内聚<br>一个模块任务间关系松散或者没有关系。</li><li>逻辑内聚<br>模块完成的任务在逻辑上属于相同或者相似的一类(如都是输出)。</li><li>时间内聚<br>包含的任务必须在同一段时间内执行 (如初始化模块)。</li></ul><p>中内聚</p><ul><li>过程内聚<br>一个模块内的处理元素相关，并且以特定的次序执行。通过研究程序流程图划分的模块一般是过程内聚。</li><li>通信内聚<br>模块中所有元素都使用同一个输入数据和/或产生同一个输出数据。</li></ul><p>高内聚</p><ul><li>顺序内聚<br>一个模块内的处理元素和同一个功能密切相关，并且必须顺序执行（前一个处理的输出是后一个处理的输入）。</li><li>功能内聚<br>模块内所有处理元素属于一个整体，完成一个单一的功能。</li></ul><p>🎈判断内聚方式的方法：模块<strong>是否只完成单一功能</strong>，是则为功能内聚，否则<strong>考虑模块内各组成部分的关系</strong>；如果是<strong>数据流</strong>的关系，那么<strong>考虑次序是否重要</strong>，是则为顺序内聚，否则为通信内聚；如果是<strong>控制流</strong>的关系，那么<strong>考虑次序是否重要</strong>，是则为过程内聚，否则为时间内聚；如果<strong>既不是数据流也不是控制流</strong>，那么<strong>考虑功能间逻辑是否类似</strong>，是则为逻辑内聚，否则为偶然内聚。</p><h3 id="表示软件结构的图形工具"><a href="#表示软件结构的图形工具" class="headerlink" title="表示软件结构的图形工具"></a>表示软件结构的图形工具</h3><h4 id="层次图-H图-和HIPO图"><a href="#层次图-H图-和HIPO图" class="headerlink" title="层次图(H图)和HIPO图"></a>层次图(H图)和HIPO图</h4><p>在层次图中一个矩形框代表一个模块。框间的连线表示调用关系(位于上方的矩形框所代表的模块调用位于下方的矩形框所代表的模块)。<br>🔖H图与需求分析时介绍的层次方框图看起来是一样的，但内容和含义完全不同。H图方框间的连线表示调用关系，而不是组成关系。</p><p>HIPO图：带编号的H图(最顶层的方框不加编号)+带编号的IPO图。</p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p>图中一个方框代表一个模块，框内注明模块的名字或主要功能；方框之间的箭头(或直线)表示模块的调用(call)关系。<br>在结构图中通常还用带注释的箭头表示模块调用过程中来回传递的信息，可以利用注释箭头尾部的形状来区分传递的信息是数据还是控制信息：尾部是空心圆表示传递的是数据；实心圆表示传递的是控制信息。</p><p><br/></p>]]></content>
    
    
    <summary type="html">主要内容有总体设计的过程、原则和图形化工具</summary>
    
    
    
    
    <category term="软件工程" scheme="https://wheliosc.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程[3] 需求分析</title>
    <link href="https://wheliosc.github.io/requirement-analysis"/>
    <id>https://wheliosc.github.io/requirement-analysis</id>
    <published>2019-01-08T04:37:06.460Z</published>
    <updated>2021-08-30T07:56:31.905Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h3><ul><li>确定对系统的综合要求</li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ul><p>🔖系统的综合要求包括：功能需求、性能需求、可靠性和可用性需求、出错处理需求、接口需求、约束、逆向需求和将来可能提出的要求。<br>🔖通常用数据流图、实体-联系图、状态转换图、数据字典和主要的处理算法描述系统的逻辑模型。</p><h3 id="分析建模"><a href="#分析建模" class="headerlink" title="分析建模"></a>分析建模</h3><p>需求分析过程应建立三种模型：</p><ul><li>数据模型(使用实体-联系图，即E-R图)</li><li>功能模型(使用数据流图)</li><li>行为模型(使用状态转换图)</li></ul><h3 id="实体-联系图"><a href="#实体-联系图" class="headerlink" title="实体-联系图"></a>实体-联系图</h3><p>数据模型包含三种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>数据对象是对软件必须理解的复合信息的表示。所谓复合信息是指具有一系列不同性质或属性的事物，因此，仅有单个值的事物(例如长度，名称)不是数据对象。可以由一组属性来定义的<strong>实体</strong>都可以认为是数据对象。（联系或称关系也可能有一组属性，但它不是数据对象）<br>数据对象只封装了数据，没有包含作用于这些数据上的操作。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性定义了数据对象的性质和特征。<br>为了唯一地标识数据对象的某一个实例，定义数据对象中的一个属性或几个属性为关键字，简称键 (key)。</p><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>数据对象彼此之间相互连接的方式称为联系(关系)。</p><ul><li>一对一联系(1∶1)<br>🌰一个班级有一位班长．一个班长只能在一个班级任职，班级和班长这两个实体的联系是一对一的。</li><li>一对多联系(1∶N)<br>🌰一个班级有多个班干部，一个班干部只能在一个班级任职，班级和班干部这两个实体的联系是一对多的。</li><li>多对多联系(M∶N)<br>🌰一个学生可以选修多门课，一门课可以有多个学生选修，学生和课程这两个实体之间的联系是多对多的。</li></ul><h4 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h4><p>通常用矩形框代表实体，用连接相关实体的菱形框表示关系。用椭圆形或圆角矩形表示实体(或关系)的属性。并用无向边把实体(或关系)与其属性连接起来。</p><h3 id="状态转换图-STD"><a href="#状态转换图-STD" class="headerlink" title="状态转换图(STD)"></a>状态转换图(STD)</h3><p>状态转换图(State Transition Diagram, STD)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。<br>在STD中用圆形框或椭圆框表示状态，通常在框内标上状态名。状态规定了系统对事件的响应方式。<br>系统对事件的响应，既可以是做一个(或一系列)动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态又做动作。<br>在状态图中定义的状态主要有：初态、终态和中间状态。在一个状态图中只能有一个初态，终态可以有零个或多个。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是在某个特定时刻发生的事情，它是对引起系统从一个状态转换到另一个状态的外界事件的抽象。简而言之，事件就是引起系统状态转换的控制信息。<br>在状态图中，从一个状态到另一个状态的转换用箭头线表示，箭头表明转换方向，箭头线上标上事件名。必要时可在事件名后面加一个方括号，括号内写上状态转换的条件（守卫条件）。也就是说，仅当方括号内所列出的条件为真时，该事件的发生才引起箭头所示的状态转换。</p><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><ul><li>初态用实心圆表示；终态用同心圆（内圆为实心圆）表示。</li><li>中间状态用圆角矩形表示，用两条水平横线分为上中下三部分。上面为状态名，必须有的；中间为状态变量的名字和值（比如，timer=0），可选的；下面为活动表（语法格式为：事件名/动作表达式），可选的。<br>活动表🌰：do/开始录音；exit/播放音乐</li><li>状态间转换用有向箭头，箭线上标明事件表达式。</li></ul><h3 id="其他图形工具"><a href="#其他图形工具" class="headerlink" title="其他图形工具"></a>其他图形工具</h3><h4 id="层次方框图"><a href="#层次方框图" class="headerlink" title="层次方框图"></a>层次方框图</h4><p>树形结构，树形结构的顶层是一个单独的矩形框，它代表完整的数据结构，下面各层的矩形框代表这个数据结构的子集，最底层的各个框代表组成这个数据的实际数据元素。</p><h4 id="Wariner图"><a href="#Wariner图" class="headerlink" title="Wariner图"></a>Wariner图</h4><p>花括号内的信息条目构成顺序关系；花括号从左至右排列表示树型层次结构；符号“⊕”表示不可兼具的选择关系；“￣”表示“非”；圆括号内的数字表示重复次数，（1,n）表示重复结构，（1）或不标次数表示顺序结构，（0,1）表示选择结构。<br><img src="" alt="Wariner"></p><h4 id="IPO图-Input-Process-Output-Diagram"><a href="#IPO图-Input-Process-Output-Diagram" class="headerlink" title="IPO图(Input Process Output Diagram)"></a>IPO图(Input Process Output Diagram)</h4><p>左边框中列出有关的输入，中间框中列出主要的处理，右边框中列出产生的输出。处理的顺序暗示了执行的顺序，箭头指出数据通信的情况。<br><img src="" alt="IPO"></p><p><br/></p>]]></content>
    
    
    <summary type="html">主要内容有需求分析的任务和建模使用的图形工具</summary>
    
    
    
    
    <category term="软件工程" scheme="https://wheliosc.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Depreciation</title>
    <link href="https://wheliosc.github.io/depreciation"/>
    <id>https://wheliosc.github.io/depreciation</id>
    <published>2019-01-06T06:33:23.119Z</published>
    <updated>2021-08-30T07:42:21.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="What-can-be-depreciation"><a href="#What-can-be-depreciation" class="headerlink" title="What can be depreciation?"></a>What can be depreciation?</h3><ul><li>Assets must be <strong>used in business</strong> or held for production of income.</li><li>Assets must <strong>have a definite useful life</strong> and a life &gt; one  year.</li><li>Assets that must be sth that <strong>wears out</strong>,  gets used up, become obsolete or lose value.</li></ul><p>🔖Depreciable property includes buildings, machinery, equipment, vehicles and some intangible properties(such as copyrights, designs, etc). </p><h3 id="Cost-basis"><a href="#Cost-basis" class="headerlink" title="Cost basis"></a>Cost basis</h3><p>The total cost that is claimed as an expense over an asset’s life, which includes <strong>the actual cost</strong> of the asset and <strong>all incidental expenses</strong> such as freight, insurance, and site preparation.</p><h3 id="Salvage-value"><a href="#Salvage-value" class="headerlink" title="Salvage value"></a>Salvage value</h3><p>The salvage value of an asset is an asset’s estimated value at the end of its life.<br>It is the amount eventually recovered through sale, trade-in, or salvage.</p><h3 id="Method-of-depreciation"><a href="#Method-of-depreciation" class="headerlink" title="Method of depreciation"></a>Method of depreciation</h3><h4 id="Straight-Line-Method-直线折旧法"><a href="#Straight-Line-Method-直线折旧法" class="headerlink" title="Straight-Line Method(直线折旧法)"></a>Straight-Line Method(直线折旧法)</h4><p>$D _ { n } = ( I - S ) / N , and\ constant\ for\ all\ n$<br>$I = cost\ basis, S = salvage\ value, N = depreciable\ life$ </p><h4 id="Modified-Accelerated-Cost-Recovery-System-MACRS-修正的加速折旧法"><a href="#Modified-Accelerated-Cost-Recovery-System-MACRS-修正的加速折旧法" class="headerlink" title="Modified Accelerated Cost Recovery System(MACRS,修正的加速折旧法)"></a>Modified Accelerated Cost Recovery System(MACRS,修正的加速折旧法)</h4><ul><li>Only a half-year of depreciation is allowed for the first year.</li><li>A full year’s depreciation is allowed in each of the remaining years.</li><li>The remaining half-year’s depreciation is incurred in the year following the end of the recovery period.</li><li>A half-year of depreciation is also allowed for the year in which the property is disposed of, or is otherwise retired from service, anytime before the end of the recovery period.</li><li><em>Switching from the DB method to the SL method</em>.</li></ul><p>🔖关键在于：项目的第一年只允许计提半年的折旧。如果项目生命周期大于折旧年限（比如5年），那么需要在第六年计提第一年剩下的半年的折旧。如果项目生命周期小于折旧年限，那么在项目的最后一年计提半年的折旧。<br>🌰5-YEAR MACRS</p><div class="table-container"><table><thead><tr><th>n</th><th>DDB</th><th>SL</th></tr></thead><tbody><tr><td> 1</td><td>1/2 * DDB=1/2 * 1/5 *  2 = 20%</td><td>\</td></tr><tr><td> 2</td><td>2 * 1/5 * （1 - 20%）= 32%</td><td>\                           </td></tr><tr><td> 3</td><td>2 * 1/5 * （1 - 20% - 32%）= 19%</td><td>\       </td></tr><tr><td> 4</td><td>2 * 1/5 * （1 - 20% - 32% - 19%）= 11.6%</td><td>1/2.5 * （1 - 20% - 32% - 19%）= 11.6% </td></tr><tr><td> 5</td><td>2 * 1/5* （29% - 11.6%）= 6.96%</td><td>1/1.5 * （29% - 11.6%）= 11.6%         </td></tr><tr><td> 6</td><td>\</td><td>0.5 * 11.6% = 5.8% </td></tr></tbody></table></div><h4 id="Declining-Balance-Method-余额递减法"><a href="#Declining-Balance-Method-余额递减法" class="headerlink" title="Declining Balance Method(余额递减法)"></a>Declining Balance Method(余额递减法)</h4><p>加速折旧法的一种。<br>$\alpha = ( 1 / N ) \times (multiplier) \quad D _ { n } = \alpha B _ { n - 1 }$<br>$\alpha B _ { n - 1 }$为上一年的$Book\ value$，$B_n=B_{n-1}-D_n$<br>🔖If $\alpha$ is chosen to be the upper bound, $\alpha$ = 2(1/N), we call it a 200% DB or double declining balance method.(双倍余额递减法)<br>🔖因为余额递减折旧法是按比例折旧，所以在不考虑有残值的情况($S=0$)下，使用余额递减折旧法永远也不能将固定资产(cost basis)计提干净。<br>🔖因为余额递减折旧法不考虑残值，所以要注意在有残值的情况下，不允许固定资产的账面折余值小于预计残值收入。国内对折旧期年限到期以前的两年折旧额的处理采用直线法，即倒数第二年的期初账面余额减去残值，然后除以2，得到最后两年的平均年折旧额。</p><h5 id="Switching-policy-DB-Switching-to-SL"><a href="#Switching-policy-DB-Switching-to-SL" class="headerlink" title="Switching policy(DB Switching to SL)"></a>Switching policy(DB Switching to SL)</h5><p>🌰Assum S=0, cost basis=10000, depreciation life=5, double declining balance:<br>Without switching table</p><div class="table-container"><table><thead><tr><th>n</th><th>Depreciation</th><th>Book value </th></tr></thead><tbody><tr><td> 1</td><td>10000*0.4=<font color="red">4000</font></td><td>6000       </td></tr><tr><td> 2</td><td>6000*0.4=<font color="red">2400</font></td><td>3600       </td></tr><tr><td> 3</td><td>3600*0.4=<font color="red">1440</font></td><td>2160       </td></tr><tr><td> 4</td><td>2160*0.4=<font color="red">864</font></td><td>1296       </td></tr><tr><td> 5</td><td>1296*0.4=<font color="red">518</font></td><td>778      </td></tr></tbody></table></div><p>With switching to SL table</p><div class="table-container"><table><thead><tr><th>n</th><th>Depreciation</th><th>Book value </th></tr></thead><tbody><tr><td> 1</td><td>10000/5=2000&lt;<font color="red">4000</font></td><td>6000       </td></tr><tr><td> 2</td><td>6000/4=1500&lt;<font color="red">2400</font></td><td>3600       </td></tr><tr><td> 3</td><td>3600/3=1200&lt;<font color="red">1440</font></td><td>2160       </td></tr><tr><td> 4</td><td>2160/2=<font color="red">1080</font>&gt;864</td><td>1080       </td></tr><tr><td> 5</td><td>1080/1=<font color="red">1080</font>&gt;518</td><td>0     </td></tr></tbody></table></div><p>📌使用转换策略时，SL计算中的N是还<strong>剩下</strong>的折旧年数。</p><h4 id="Units-of-Production-Method-单位产品工作量法"><a href="#Units-of-Production-Method-单位产品工作量法" class="headerlink" title="Units-of-Production Method(单位产品工作量法)"></a>Units-of-Production Method(单位产品工作量法)</h4><p>$D _ { n } = \frac { \text { Service units consumed for year } n } { \text { total service units } } ( I - S )$</p><p><br/></p>]]></content>
    
    
    <summary type="html">Method of depreciation</summary>
    
    
    
    
    <category term="工程经济学" scheme="https://wheliosc.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Payback period and AE analysis</title>
    <link href="https://wheliosc.github.io/payback-period-and-others"/>
    <id>https://wheliosc.github.io/payback-period-and-others</id>
    <published>2019-01-04T10:42:56.250Z</published>
    <updated>2021-08-30T07:56:12.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="Payback-period"><a href="#Payback-period" class="headerlink" title="Payback period"></a>Payback period</h2><h3 id="Conventional-Payback-Period-静态回收期"><a href="#Conventional-Payback-Period-静态回收期" class="headerlink" title="Conventional Payback Period(静态回收期)"></a>Conventional Payback Period(静态回收期)</h3><h4 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h4><p>静态回收期=累计净现金流量开始出现正值的年份数 - 1 + [上年累计净现金流量的绝对值/当年净现金流量]</p><h4 id="Weakness"><a href="#Weakness" class="headerlink" title="Weakness"></a>Weakness</h4><p>Does not consider the time value of money.</p><h3 id="Discounted-Payback-Period-动态回收期"><a href="#Discounted-Payback-Period-动态回收期" class="headerlink" title="Discounted Payback Period(动态回收期)"></a>Discounted Payback Period(动态回收期)</h3><h4 id="Formula-1"><a href="#Formula-1" class="headerlink" title="Formula"></a>Formula</h4><p>动态回收期=累计净现金流量<strong>折现值</strong>开始出现正值的年份数 - 1 + [上年累计净现金流量<strong>折现值</strong>的绝对值/当年净现金流量<strong>折现值</strong>]</p><h4 id="Weakness-1"><a href="#Weakness-1" class="headerlink" title="Weakness"></a>Weakness</h4><p>Cash flows occurring after discounted payback period(DPP) are ignored.</p><h4 id="Calculate"><a href="#Calculate" class="headerlink" title="Calculate"></a>Calculate</h4><p>Method1:<br><img src="https://wx3.sinaimg.cn/large/006xwwY9ly1g0ub4r4pv8j30fp082gm2.jpg" alt="Method1"><br>Method2:<br><img src="https://ws2.sinaimg.cn/large/006xwwY9ly1g0ub4rpbwtj30zd05jaah.jpg" alt="Method2"></p><h2 id="Capitalized-Equivalent-Worth-等值资本化"><a href="#Capitalized-Equivalent-Worth-等值资本化" class="headerlink" title="Capitalized Equivalent Worth(等值资本化)"></a>Capitalized Equivalent Worth(等值资本化)</h2><p>A special case of the PW criterion is useful when the life of a proposed project is perpetual or the service life is extremely long.<br>The capitalized cost represents the amount of money that must be invested <strong>today</strong> in order to yield a certain return A at the end of each and every period forever.<br>一次性投入以在以后的每个阶段(例如每年、每月等)产生一个确定的回报A。</p><h3 id="Formula-2"><a href="#Formula-2" class="headerlink" title="Formula"></a>Formula</h3><p>$C E ( i ) = P W ( i ) = A ( P / A , i , N ) = A / i \ (n\rightarrow \infty)$</p><h2 id="Annual-equivalent-worth-年金等值分析"><a href="#Annual-equivalent-worth-年金等值分析" class="headerlink" title="Annual equivalent worth(年金等值分析)"></a>Annual equivalent worth(年金等值分析)</h2><p>在评估项目时，如果使用现值分析(PW)应当保证两个项目的分析期(项目存活周期)相同。如果不同，可以采用最小公倍数法统一分析期，但这种方法很麻烦。这种情况下，可以使用年金等值分析，计算每一年的平均花费，然后进行比较。二者的关系是$\mathrm { AE } ( \mathrm { i } ) = \mathrm { PW } ( \mathrm { i } ) ( \mathrm { A } / \mathrm { P } , \mathrm { i } , \mathrm { N } )$。</p><h2 id="Capital–Recovery-Cost-资本重置费用"><a href="#Capital–Recovery-Cost-资本重置费用" class="headerlink" title="Capital–Recovery Cost(资本重置费用)"></a>Capital–Recovery Cost(资本重置费用)</h2><p>$\begin{aligned} \mathrm { CR } ( i ) &amp; = I ( A / P , i , N ) - S ( A / F , i , N ) \\ &amp; = ( I - S ) ( A / P , i , N ) + i S \end{aligned}$<br>$I$为一开始购进设备的花费，$S$为设备的残值。</p><p><br/></p>]]></content>
    
    
    <summary type="html">Payback period, Capitalized Equivalent(CE), AE analysis, Capital–Recovery Cost(CR)</summary>
    
    
    
    
    <category term="工程经济学" scheme="https://wheliosc.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Economic Equivalence Computation</title>
    <link href="https://wheliosc.github.io/economic-equivalence"/>
    <id>https://wheliosc.github.io/economic-equivalence</id>
    <published>2019-01-03T11:26:28.462Z</published>
    <updated>2021-08-30T07:42:25.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="Single-Payment-Series"><a href="#Single-Payment-Series" class="headerlink" title="Single-Payment Series"></a>Single-Payment Series</h3><h4 id="Compound-Amount-Factor-复利系数"><a href="#Compound-Amount-Factor-复利系数" class="headerlink" title="Compound-Amount Factor(复利系数)"></a>Compound-Amount Factor(复利系数)</h4><p>$F = P ( 1 + i ) ^ { N } = P ( F / P , i , N )$</p><h4 id="Present-Worth-Factor-现值系数"><a href="#Present-Worth-Factor-现值系数" class="headerlink" title="Present-Worth Factor(现值系数)"></a>Present-Worth Factor(现值系数)</h4><p>$P = F [1 / ( 1 + i )] ^ { N } = F ( P / F , i , N )$</p><h3 id="Equal-Payment-Series"><a href="#Equal-Payment-Series" class="headerlink" title="Equal-Payment Series"></a>Equal-Payment Series</h3><h4 id="Compound-Amount-Factor-复利系数-1"><a href="#Compound-Amount-Factor-复利系数-1" class="headerlink" title="Compound-Amount Factor(复利系数)"></a>Compound-Amount Factor(复利系数)</h4><p>$F = A  (  F  /  A ,  i  ,  N  )$</p><h4 id="Sinking-Fund-Factor-偿债基金系数"><a href="#Sinking-Fund-Factor-偿债基金系数" class="headerlink" title="Sinking-Fund Factor(偿债基金系数)"></a>Sinking-Fund Factor(偿债基金系数)</h4><p>$A = F  (  A  /  F ,  i  ,  N  )$</p><h4 id="Capital-Recovery-Factor-投资回收系数"><a href="#Capital-Recovery-Factor-投资回收系数" class="headerlink" title="Capital-Recovery Factor(投资回收系数)"></a>Capital-Recovery Factor(投资回收系数)</h4><p>$A = P  (  A  /  P ,  i  ,  N  )$</p><h4 id="Present-Worth-Factor-现值系数-1"><a href="#Present-Worth-Factor-现值系数-1" class="headerlink" title="Present-Worth Factor(现值系数)"></a>Present-Worth Factor(现值系数)</h4><p>$P = A  (  P  /  A ,  i  ,  N  )$</p><h3 id="Gradient-Series-梯度序列"><a href="#Gradient-Series-梯度序列" class="headerlink" title="Gradient Series(梯度序列)"></a>Gradient Series(梯度序列)</h3><h4 id="Linear-Gradient-Series-线性梯度系列"><a href="#Linear-Gradient-Series-线性梯度系列" class="headerlink" title="Linear Gradient Series(线性梯度系列)"></a>Linear Gradient Series(线性梯度系列)</h4><p>$P = G  (  P  /  G ,  i  ,  N  )$<br><img src="https://ws1.sinaimg.cn/large/006xwwY9ly1g0uayapjz7j30vj0e60tw.jpg" alt="Linear Gradient"></p><h4 id="Geometric-Gradient-Series-几何梯度系列"><a href="#Geometric-Gradient-Series-几何梯度系列" class="headerlink" title="Geometric Gradient Series(几何梯度系列)"></a>Geometric Gradient Series(几何梯度系列)</h4><p>$P = A_1  (  P  /  A_1 , g, i  ,  N  )$<br><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0uayaj3ykj30b1071t8v.jpg" alt="Geometric Gradient"></p><h3 id="Composite-cash-flow"><a href="#Composite-cash-flow" class="headerlink" title="Composite cash flow"></a>Composite cash flow</h3><p>Q1:<br><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0uau70fq8j30hd0fngm5.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/006xwwY9ly1g0uau6kcsvj30ml0im0un.jpg" alt="image"><br><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0uau6rekbj30pd0idmyf.jpg" alt="image"><br>Q2:<br><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0uau7x89gj30lc0a2my4.jpg" alt="image"><br><img src="https://wx2.sinaimg.cn/large/006xwwY9ly1g0uau7hsg7j30in09ywg0.jpg" alt="image"><br>Q3:<br><img src="https://ws2.sinaimg.cn/large/006xwwY9ly1g0uau8c9knj30h80a7mxv.jpg" alt="image"><br><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0uau84evkj30kp09w3yt.jpg" alt="image"></p><p><br/></p>]]></content>
    
    
    <summary type="html">Basic Formula of Economic Equivalence</summary>
    
    
    
    
    <category term="工程经济学" scheme="https://wheliosc.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Cost of Capital</title>
    <link href="https://wheliosc.github.io/cost-of-capital"/>
    <id>https://wheliosc.github.io/cost-of-capital</id>
    <published>2018-12-31T10:19:59.164Z</published>
    <updated>2021-08-30T07:42:08.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="Types-of-Financing"><a href="#Types-of-Financing" class="headerlink" title="Types of Financing:"></a>Types of Financing:</h3><h4 id="Equity-financing"><a href="#Equity-financing" class="headerlink" title="Equity financing"></a>Equity financing</h4><p>Equity financing uses retained earnings or funds raised from an issuance of stock to finance a capital.</p><h4 id="Debt-financing"><a href="#Debt-financing" class="headerlink" title="Debt financing"></a>Debt financing</h4><p>Debt financing uses money raised through loans or by an issuance of bonds to finance a capital investment.</p><h3 id="Cost-of-Capital"><a href="#Cost-of-Capital" class="headerlink" title="Cost of Capital"></a>Cost of Capital</h3><p>Weighted average of Cost of Equity($i_e$) and Cost of Debt($i_d$)</p><h4 id="Cost-of-Equity"><a href="#Cost-of-Equity" class="headerlink" title="Cost of Equity"></a>Cost of Equity</h4><p>$i _ { e } = r _ { f } + \beta \left[ r _ { M } - r _ { f } \right]$</p><ul><li>$r_f$ = risk free interest rate (commonly referenced to U.S. Treasury bond yield)</li><li>$r_M$ = market rate of return (commonly referenced to average return on S&amp;P 500 stock index funds)</li><li>$\beta$ = A number greater than one (β &gt; 1) means that the stock is more volatile than the market on average; a number less than one (β &lt; 1) means that the stock is less volatile than the market on average. </li></ul><h4 id="the-after-tax-Cost-of-Debt"><a href="#the-after-tax-Cost-of-Debt" class="headerlink" title="the after-tax Cost of Debt"></a>the after-tax Cost of Debt</h4><p>$i _ { d } = \left( c _ { s } / c _ { d } \right) k _ { s } \left( 1 - t _ { m } \right) + \left( c _ { b } / c _ { d } \right) k _ { b } \left( 1 - t _ { m } \right)$</p><ul><li>$c_s$ = the amount of the term loan</li><li>$c_b$ = the amount of bond financing</li><li>$k_s$ = the before-tax interest rate on the term loan</li><li>$k_b$ = the before-tax interest rate on the bond</li><li>$t_m$ = the firm’s marginal tax rate</li><li>$c_d$ = $c _ { s } + c _ { b }$</li></ul><h4 id="Cost-of-Capital-1"><a href="#Cost-of-Capital-1" class="headerlink" title="Cost of Capital"></a>Cost of Capital</h4><p>$k = \frac { i _ { d } c _ { d } } { V } + \frac { i _ { e } c _ { e } } { V }$</p><ul><li>$c_d$ = Total debt capital(such as bonds) in dollars</li><li>$c_e$ =Total equity capital in dollars</li><li>$V$ = $c_d+c_e$</li><li>$i_e$ = Average equity interest rate per period considering all equity sources</li><li>$i_d$ = After-tax average borrowing interest rate per period considering all debt sources</li><li>$k$ = Tax-adjusted weighted-average cost of capital</li></ul><p><br/></p>]]></content>
    
    
    <summary type="html">Analysis of Cost of Capital</summary>
    
    
    
    
    <category term="工程经济学" scheme="https://wheliosc.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Interest Rate</title>
    <link href="https://wheliosc.github.io/interest-rate"/>
    <id>https://wheliosc.github.io/interest-rate</id>
    <published>2018-12-31T05:24:00.743Z</published>
    <updated>2021-08-30T07:52:29.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="Simple-interest-单利"><a href="#Simple-interest-单利" class="headerlink" title="Simple interest(单利)"></a>Simple interest(单利)</h3><p>Interest earned on only the principal amount during each interest period.<br>仅用本金计算利息，而不计算利息所产生的利息。<br>🌰如果有n个计息周期，周期利率为i，本金为P，则到投资期末，本利和F为：$F=P(1+i\times n)$</p><h3 id="Compound-interest-复利"><a href="#Compound-interest-复利" class="headerlink" title="Compound interest(复利)"></a>Compound interest(复利)</h3><p>The interest earned in each period is calculated based on the total amount at the end of the previous period.<br>除了本金的计算外，还要计算利息所产生的利息。<br>🌰如果有n个计息周期，周期利率为i，本金为P，则到投资期末，本利和F为：$F=P(1+i)^n$</p><h4 id="Cyclic-Interest-Rate-周期利率"><a href="#Cyclic-Interest-Rate-周期利率" class="headerlink" title="Cyclic Interest Rate(周期利率)"></a>Cyclic Interest Rate(周期利率)</h4><p>Cyclic interest rate refers to the interest rate which is calculated more than once in a year, and the average interest rate is the cyclic interest rate.<br>周期利率是指一年内计息超过一次以上，平均每次计息的利率就是周期利率。<br>$i=r/n$，$i$为周期利率，$r$为名义利率，$n$为一年内的<strong>计息周期(interest period)数</strong></p><h4 id="Nominal-Interest-Rate-名义利率"><a href="#Nominal-Interest-Rate-名义利率" class="headerlink" title="Nominal Interest Rate(名义利率)"></a>Nominal Interest Rate(名义利率)</h4><p>Interest rate quoted based on _an annual period_—-annual percentage rate(APR)年百分率</p><h4 id="Effective-Interest-Rate-实际利率"><a href="#Effective-Interest-Rate-实际利率" class="headerlink" title="Effective Interest Rate(实际利率)"></a>Effective Interest Rate(实际利率)</h4><p>Actual interest earned or paid in a year or some other time period.<br>如果计息周期和支付周期一致，$i_a=(1+r/n)^n-1=(1+i)^n-1$，$i_a$为实际利率，$r$为名义利率，$i$为周期利率<br>如果一年有K个支付周期(payment period)，每个支付周期内有C个计息周期(interest period)，那么一个支付周期内的实际利率为$i_p = [ 1 + r / C K ] ^ { C } - 1$，当C特别大趋近于无穷时，$i_p = e^{r/K}-1$</p><h3 id="Equivalence-Analysis-using-Effective-Interest-Rates"><a href="#Equivalence-Analysis-using-Effective-Interest-Rates" class="headerlink" title="Equivalence Analysis using Effective Interest Rates"></a>Equivalence Analysis using Effective Interest Rates</h3><h4 id="Two-concepts"><a href="#Two-concepts" class="headerlink" title="Two concepts"></a>Two concepts</h4><p>payment period: 支付周期<br>interest period: 计息周期</p><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><p>In all financial analysis, we need to convert the APR into an appropriate effective interest rate based on a payment period.(which is the interest amount accumulated over a given period). </p><ul><li>Identify the payment period (e.g., annual, quarter, month, week, etc)</li><li>Identify the interest period (e.g., annually, quarterly, monthly, etc)</li><li>Find the _effective interest_ rate that <font color="red">covers the payment period</font>.</li></ul><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><ol><li>Suppose your savings account pays 9% interest compounded quarterly. If you deposit ￥10,000 for one year, how much would you have?<br>$i = \frac { 9 \% } { 4 } = 2.25 \%$<br>$i _ { a } = ( 1 + 0.0225 ) ^ { 4 } - 1 = 9.31 \%$<br>$F= 10,000 (F/P,2.25 \% ,4)=10,000(F/P,9.31 \% ,1)=10,931$</li><li>A series of equal quarterly payments of ￥5,000 for 10 years is equivalent to what present amount at an interest rate of 9% compounded<br>(a) quarterly (b) monthly (c) continuously<br>(a) Payment period: Quarterly; Interest Period: Quarterly<br>$i = \frac { 9 \% } { 4 } = 2.25 \%$ per quarter<br>$N = 40 quarters$<br>$P = 5,000 ( P / A , 2.25 \% , 40 ) = 130,968$<br>(b) Payment period: Quarterly; Interest Period: Monthly<br>$i = \frac { 9 \% } { 12 } = 0.75 \%$ per month<br>$i _ { p } = ( 1 + 0.0075 ) ^ { 3 } = 2.267 \%$ per quarter<br>$N = 40 quarters$<br>$P = 5,000 ( P / A , 2.267 \% , 40 ) = 130,586$<br>(c) Payment period: Quarterly; Interest Period: Continuously<br>$i = e ^ { 0.09 / 4 } - 1 = 2.276 \%$ per quarter<br>$N = 40 quarters$<br>$P = 5,000 ( P / A , 2.276 \% , 40 ) = 130,384$</li></ol><p><br/></p>]]></content>
    
    
    <summary type="html">Types of interest rate</summary>
    
    
    
    
    <category term="工程经济学" scheme="https://wheliosc.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>软件工程[2] 可行性研究</title>
    <link href="https://wheliosc.github.io/feasibility-study"/>
    <id>https://wheliosc.github.io/feasibility-study</id>
    <published>2018-12-25T09:29:59.236Z</published>
    <updated>2021-08-30T07:56:25.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="可行性研究的任务"><a href="#可行性研究的任务" class="headerlink" title="可行性研究的任务"></a>可行性研究的任务</h3><p>不是解决问题，而是确定问题是否值得去解决。<br>分析可能解法的利弊；判定系统规模和目标是否能够实现；效益是否可观。<br>进一步分析和澄清问题定义；之后导出系统的逻辑模型；从逻辑模型出发，探索主要解法（实现方案）；对每种解法从以下方面研究可行性：</p><ul><li>技术可行性 现有技术能否实现目标系统？</li><li>经济可行性 能否收回投资并获得利润？</li><li>操作可行性 操作方式是否适用于用户组织？</li><li>法律、社会效益可行性 是否符合法律要求？</li></ul><h3 id="可行性研究的过程"><a href="#可行性研究的过程" class="headerlink" title="可行性研究的过程"></a>可行性研究的过程</h3><ul><li>复查系统规模和目标</li><li>研究目前正在使用的系统（完成它的基本功能；解决它存在的问题；增加收入或减少支出）</li><li>导出系统的高层逻辑模型（数据流图、数据字典）</li><li>进一步定义问题（分析员与用户复查问题定义、工程规模和目标）</li><li>导出和评价供选择的解法（从技术等方面研究可行性）</li><li>推荐行动方针（是否继续进行该项目，若是则选择最佳解法，并进行成本/效益分析）</li><li>草拟开发计划</li><li>书写文档提交审查</li></ul><h3 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h3><p>系统流程图是概括地描绘物理系统的传统工具。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程（程序流程图）。<br>程序流程图是描述<strong>过程设计</strong>的工具。</p><h3 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a>数据流图(DFD)</h3><p>在数据流图中没有任何具体的物理部件，只是描绘<strong>数据</strong>在软件中流动和被处理的逻辑过程。</p><h4 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h4><div class="table-container"><table><thead><tr><th>符号</th><th>含义 </th></tr></thead><tbody><tr><td> 正方形或立方体</td><td>数据源点或终点</td></tr><tr><td> 圆角矩形或圆形</td><td>变换数据的处理</td></tr><tr><td> 开口矩形或两条平行线</td><td>数据存储</td></tr><tr><td> 箭头</td><td>特定数据流动方向</td></tr></tbody></table></div><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul><li>顶层（0层）数据流图。仅包含一个加工，它代表被开发系统。</li><li>中间层数据流图。对其上层父图的细化，其每一加工可能继续细化，形成子图。</li><li>底层数据流图。加工不需再做分解（基本加工）的数据流图。</li></ul><p><img src="" alt="DFD"></p><h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>数据字典是描述数据的信息的集合，是对系统中使用的所有数据元素的定义的集合。系统的逻辑模型由DFD和数据字典共同构成，缺一不可。</p><h4 id="数据字典的内容"><a href="#数据字典的内容" class="headerlink" title="数据字典的内容"></a>数据字典的内容</h4><ul><li>一般信息。名字，别名，描述等。</li><li>定义。数据类型，长度，结构等。</li><li>使用特点。值的范围，使用频率，使用方式（输入，输出，本地），条件值等。</li><li>控制信息。来源，用户，使用它的程序，改变权，使用权等。</li><li>分组信息。父结构，从属结构，物理位置（记录、文件和数据库）等。</li></ul><h4 id="定义数据的方法"><a href="#定义数据的方法" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h4><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>栗子</th></tr></thead><tbody><tr><td> =</td><td>定义为</td><td></td></tr><tr><td> +</td><td>和</td><td>x=a＋b，表示x由a和b组成</td></tr><tr><td> [..$\mid$..]</td><td>或</td><td>x=[a$\mid$b]，表示x由a或由b组成</td></tr><tr><td> {}</td><td>重复</td><td>x=3{a}8，表示x中至少出现3次a, 至多出现8次a，也可以用上下标的形式表示次数限制</td></tr><tr><td> ()</td><td>可选</td><td>x=(a)，表示a可在x中出现,也可不出现</td></tr></tbody></table></div><p>🌰发票 = 单位名称 + 1{商品名+数量+单价+金额}5 + 总金额 + 日期 + (营业员)</p><h3 id="成本-效益分析"><a href="#成本-效益分析" class="headerlink" title="成本/效益分析"></a>成本/效益分析</h3><h4 id="成本估计"><a href="#成本估计" class="headerlink" title="成本估计"></a>成本估计</h4><ul><li>代码行技术。人力成本=每行代码成本*代码行数。</li><li>任务分解技术。对于每个任务，估计人力成本（人月为单位）。</li><li>自动估计成本技术。采用相关软件自动估算。</li></ul><h4 id="成本-效益分析的方法"><a href="#成本-效益分析的方法" class="headerlink" title="成本/效益分析的方法"></a>成本/效益分析的方法</h4><ul><li>货币的时间价值。工程经济学P和F的关系。</li><li>投资回收期。越短越好。</li><li>纯收入。越多越好。</li><li>投资回报率。衡量工程经济效益时最重要的参考依据。</li></ul><p>learn more: <a href="https://liyzy.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/">工程经济学</a></p><p><br/></p>]]></content>
    
    
    <summary type="html">主要内容有可行性研究的任务和方法，成本/效益分析，重点数据流图数据字典</summary>
    
    
    
    
    <category term="软件工程" scheme="https://wheliosc.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程[1] 软件工程学概述</title>
    <link href="https://wheliosc.github.io/software-engineering-outline"/>
    <id>https://wheliosc.github.io/software-engineering-outline</id>
    <published>2018-12-25T07:26:34.539Z</published>
    <updated>2021-08-30T07:56:21.491Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。软件危机包含下述两方面的问题：如何开发软件，以满足对软件日益增长的需求；如何维护数量不断膨胀的已有软件。</p><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>与软件本身特点有关：</p><ul><li>缺乏“可见性”，管理和控制软件开发过程相当困难。</li><li>不可能测试出全部错误，软件维护意味着改正或修改原来的设计，使得软件较难维护。</li><li>规模庞大，在技术和管理上异常复杂和困难。</li></ul><p>与软件开发与维护的方法不正确有关：</p><ul><li>忽视软件需求分析的重要性。</li><li>轻视软件维护。</li></ul><h4 id="消除的途径"><a href="#消除的途径" class="headerlink" title="消除的途径"></a>消除的途径</h4><ul><li>对计算机软件正确认识：软件是<strong>程序</strong>、<strong>数据</strong>及相关<strong>文档</strong>的完整集合。</li><li>既要有技术措施(方法和工具)，又要有科学的组织管理措施<ul><li>严密管理，良好组织，发扬团队精神</li><li>推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法，尽快消除错误概念和做法</li><li>开发和使用更好的软件工具</li></ul></li></ul><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>软件生命周期由软件定义（包括问题定义、可行性研究和需求分析三个阶段）、软件开发（包括总体设计、详细设计、编码及单元测试和综合测试四个阶段，前两个阶段又称为系统设计，后两个阶段又称为系统实现）和运行（软件）维护3个时期组成。</p><h4 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h4><p>“要解决的问题是什么” ——问题性质、工程目标、工程规模</p><h4 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h4><p>“上一个阶段所确定的问题是否有行得通的解决办法” ——技术、经济、操作、法律、社会效益等方面</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>“目标系统必须做什么” ——经用户确认的系统逻辑模型以及规格说明书</p><h4 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h4><p>“概括地回答怎样实现目标系统?” ——实现目标系统的几种可能的方案；确定程序由哪些模块组成以及模块间的关系（体系结构）</p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><p>“应该怎样具体地实现这个系统” ——详细设计每个模块；确定实现模块功能所需的算法和数据结构</p><h4 id="编码和单元测试"><a href="#编码和单元测试" class="headerlink" title="编码和单元测试"></a>编码和单元测试</h4><p>写出正确的、容易理解、容易维护的程序模块<br>单元测试：对编写出的每个程序模块进行测试</p><h4 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h4><p>通过各种类型的测试(及相应的调试)使软件达到预定的要求。最基本的测试是集成测试和验收测试。必要时可以用现场测试或平行运行进一步测试检验。保留正式的文档把测试计划、详细测试方案及实际测试结果保存，作为软件配置的一部分。</p><h4 id="运行维护"><a href="#运行维护" class="headerlink" title="运行维护"></a>运行维护</h4><ul><li>改正性维护。诊断和改正在使用过程中发现的软件错误。</li><li>适应性维护。适应性修改软件以适应环境的变化。</li><li>完善性维护。根据用户的要求改进或扩充软件使它更完善。</li><li>预防性维护。修改软件为将来的维护活动预先做准备。</li></ul><h3 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h3><h4 id="瀑布模型-Waterfall-Model"><a href="#瀑布模型-Waterfall-Model" class="headerlink" title="瀑布模型(Waterfall Model)"></a>瀑布模型(Waterfall Model)</h4><p><img src="https://ws1.sinaimg.cn/large/006xwwY9ly1g3chwd9pwgj30no0gddh7.jpg" alt="waterfall"></p><p><strong>传统的瀑布模型开发软件特点：</strong></p><ul><li><p>阶段间具有顺序性和依赖性</p><ul><li>前一阶段完成后才能开始后一阶段的工作。</li><li>前一阶段输出作为后一阶段输入，只有前一阶段有正确输出时，后一阶段才有可能正确结果。（实际上不可避免地会犯错误，因此实际的瀑布模型是带反馈环的）</li></ul></li><li><p>推迟实现的观点</p><ul><li>可避免急于求成而导致的返工。</li><li>将系统分析与逻辑设计同物理实现清楚分开开来。</li><li>尽可能推迟程序的物理实现。</li></ul></li><li><p>质量保证的观点（文档驱动的模型）</p><ul><li>每个阶段都必须完成和提交规定的文档，否则则认为该阶段任务未完成。</li><li>每个阶段结束前都要对所完成的文档进行严格评审，以尽早发现问题，纠正错误。</li></ul></li></ul><p><strong>优点：</strong></p><ul><li>提供了一种规范，使得分析、设计、编码、测试与维护工作可以在该规范的指导下有序地展开，避免了软件开发、维护过程中的随意状态。</li><li>对于需求确定、不随时间发生变化的项目，瀑布模型仍然是一种可以考虑采用的过程模型。</li></ul><p><strong>缺点：</strong></p><ul><li>完全依赖静态文档，不适应需求经常发生变更的环境。</li><li>瀑布倒流导致开发成本高。</li><li>只有到项目的开发晚期才能够得到程序的可运行版本，因疏忽而导致的错误要到检验运行时才能发现，造成经济、时间的损失。</li><li>出现“阻塞”状态，导致开发周期长。</li></ul><h4 id="快速原型模型-Rapid-Prototype-Model"><a href="#快速原型模型-Rapid-Prototype-Model" class="headerlink" title="快速原型模型(Rapid Prototype Model)"></a>快速原型模型(Rapid Prototype Model)</h4><p><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g3cii1ltt3j30ch0fidge.jpg" alt="Rapid Prototype Model"><br><strong>特点：</strong></p><ul><li>不带”反馈环“，线性顺序开发。</li><li>快速原型的本质是“快速”，尽可能使用快速开发工具尽快地建造出原型系统，以加速软件开发过程，节约软件开发成本。</li><li>原型的用途是获知用户的真正需求，一旦需求确定了，原型将被完全或部分抛弃。</li></ul><p><strong>优点：</strong></p><ul><li>减少由于需求的不明确而带来的开发风险。</li></ul><p><strong>缺点：</strong></p><ul><li>不适用于大型复杂系统的开发。</li><li>缺乏规范化的文档，内部结构可能不够好。</li></ul><h4 id="增量模型-Incremental-Model"><a href="#增量模型-Incremental-Model" class="headerlink" title="增量模型(Incremental Model)"></a>增量模型(Incremental Model)</h4><p><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g3cil5ywilj30i40bkq3i.jpg" alt="Incremental Model"><br><strong>特点：</strong></p><ul><li>任务或功能模块驱动，可以分阶段提交产品。</li><li>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</li><li>第一个增量构件往往实现软件的基本需求，提供最核心的功能。</li><li>然后以”滚雪球“的方式逐步扩充系统功能。</li></ul><p><strong>优点：</strong></p><ul><li>较短时间内提交可以部分工作的产品，对用户起到镇静剂的作用。</li><li>减少全新产品带给客户的冲击。</li><li>重要功能被首先交付使用，可以得到更多测试。</li><li>由于将一个大系统分解为多个小系统，这就等于将一个大风险分解为多个小风险，从而降低了开发难度和开发风险。</li><li>人员分配灵活，在项目开始不用投入大量的人力资源。</li></ul><p><strong>缺点：</strong></p><ul><li>集成新的增量构件时，必须保证不破坏原有系统。（需要开放式架构）</li></ul><h4 id="螺旋模型-Spiral-Model"><a href="#螺旋模型-Spiral-Model" class="headerlink" title="螺旋模型(Spiral Model)"></a>螺旋模型(Spiral Model)</h4><p><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g3ciosqv47j30g50fp0u7.jpg" alt="Spiral Model"><br>使用原型和风险分析相结合来尽量降低风险，可以理解为在每个阶段之前都增加了风险分析过程的快速原型模型。<br><strong>优点：</strong></p><ul><li>对可选方案和约束条件的强调有利于已有软件的重用。</li><li>支持用户需求的动态变化。</li><li>有助于已有软件的重用。</li><li>有助于把软件质量作为软件开发的重要目标。</li><li>减少了过多/过少测试带来的风险。</li><li>维护作为开发的一个周期，与开发没有本质区别。</li><li>风险驱动型：风险过大时能及时终止项目。</li></ul><p><strong>缺点：</strong></p><ul><li>风险驱动：需要专业的风险评估人员。</li><li>过多的迭代次数会增加项目成本，延迟提交时间。</li><li>很难让用户确信这种演化方法的结果是可以控制的。由于建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</li></ul><h4 id="喷泉模型-Fountain-Model"><a href="#喷泉模型-Fountain-Model" class="headerlink" title="喷泉模型(Fountain Model)"></a>喷泉模型(Fountain Model)</h4><p><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g3cirxgi3kj30ar0g8aap.jpg" alt="Fountain Model"></p><ul><li>以用户需求为动力，以对象为驱动的模型，是典型的面向对象生命周期模型。</li><li>体现了面向对象软件开发过程迭代和无缝的特性<ul><li>圆圈重叠：活动之间存在交迭。</li><li>OO方法在概念和表示方法上的一致性保证了各项开发活动间的无缝过渡。</li><li>向下箭头：阶段内的迭代（求精）。</li><li>各项活动无明显边界，可同步进行。（为避免活动开发过分无序，应把“线性过程” （快速原型模型或如图中的中轴线）作为总目标）</li></ul></li></ul><p><strong>优点：</strong></p><ul><li>各个阶段没有明显的界限，开发人员可以同步进行开发，提高了软件项目开发效率，节省了开发时间。</li></ul><p><strong>缺点：</strong></p><ul><li>各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，因此不利于项目的管理。</li><li>要求严格管理文档，使得审核的难度加大，尤其是可能随时加入各种信息。 </li></ul><h4 id="RUP-Rational-Unified-Process"><a href="#RUP-Rational-Unified-Process" class="headerlink" title="RUP (Rational Unified Process)"></a>RUP (Rational Unified Process)</h4><p><img src="https://wx3.sinaimg.cn/large/006xwwY9ly1g3civ1h2vej30lx0fe7a8.jpg" alt="RUP"><br>(1) 9个核心工作流，前6个为核心过程工作流程，后3个为核心支持工作流程。<br>(2) 把软件生命周期划分为四个连续的阶段：初始阶段、精化阶段、构建阶段和移交阶段。<br>(3) 强调采用迭代和渐增的方式来开发软件。<br>(4) 采用UML语言描述软件开发过程。<br>(5) 有功能强大的软件工具Rational Rose支撑。</p><p><strong>优点：</strong></p><ul><li>在开发早期或中期，用户需求可以变化。</li><li>在迭代之初，它不要求有一个相近的产品原型。</li><li>模型的适用范围很广，几乎适用于所有的项目开发。</li></ul><p><strong>缺点：</strong></p><ul><li>要求项目组成员具有很高的水平并掌握先进的开发工具。 </li></ul><h4 id="敏捷过程与极限编程（Agile-Software-Process-amp-XP）"><a href="#敏捷过程与极限编程（Agile-Software-Process-amp-XP）" class="headerlink" title="敏捷过程与极限编程（Agile Software Process &amp; XP）"></a>敏捷过程与极限编程（Agile Software Process &amp; XP）</h4><p>敏捷宣言：</p><ul><li>个体和互动高于流程和工具</li><li>工作的软件高于面面俱到的文档</li><li>客户合作高于合同谈判</li><li>响应变化高于遵循计划</li></ul><p>敏捷开发的特点：</p><ul><li>渐增式。短周期、小版本渐进交付。</li><li>协作。业务人员和开发人员长期紧密地在一起工作和交流。</li><li>简单易懂。方法本身易学、易修改和易存档。</li><li>适配性。即使在最后时刻也能够处理需求变化。</li></ul><p><strong>XP的优点：</strong></p><ul><li>由于采用简单策略，不需要长期计划和复杂管理，因而<strong>开发周期短</strong>。</li><li>由于采用迭代增量开发、反馈修正和反复测试的方法，因而<strong>软件质量有保证</strong>。</li><li>由于适应用户需求的变化，因而<strong>与用户关系和蔼</strong>。</li></ul><blockquote><p>（1）重视客户的参与；（2）重视团队合作和沟通；（3）制定计划前做出合理预测；（4）让编程人员参与软件功能的管理；（5）重视质量；（6）简单设计；（7）高频率的重新设计和重构；（8）高频率及全面的测试；（9）递增开发；（10）连续的过程评估；（11）对过去的工作持续不断的检查。</p></blockquote><p><strong>XP的缺点：</strong></p><blockquote><p>（1）以代码为中心，忽略了设计；（2）缺乏设计文档，局限于小规模项目；（3）对已完成工作的检查步骤缺乏清晰的结构；（4）质量保证依赖于测试；（5）缺乏质量规划；（6）没有提供数据的收集和使用的指导；（7）开发过程不详细；（8）全新的管理手法带来的认同度问题；（9）缺乏过渡时的必要支持。</p></blockquote><h4 id="微软过程（MSF）"><a href="#微软过程（MSF）" class="headerlink" title="微软过程（MSF）"></a>微软过程（MSF）</h4><p>MSF = RUP + Agile<br>微软过程软件生命周期：规划阶段、设计阶段、开发阶段、完成开发工作、准备好可发布版本。</p><div class="table-container"><table><thead><tr><th>序号</th><th>模   型 名 称</th><th>优    点</th><th>缺    点</th><th>适   用 范 围</th></tr></thead><tbody><tr><td>1</td><td>瀑布模型</td><td>简单好学</td><td>逆转性差</td><td>面向过程开发</td></tr><tr><td>2</td><td>增量模型</td><td>可以分阶段提交</td><td>有时用户不同意</td><td>系统可拆卸和组装</td></tr><tr><td>3</td><td>迭代模型</td><td>需求可变</td><td>风险大</td><td>有高素质软件团队</td></tr><tr><td>4</td><td>原型模型</td><td>开发速度快</td><td>不利于创新</td><td>已有产品的原型</td></tr><tr><td>5</td><td>螺旋模型</td><td>需求可变</td><td>建设周期长</td><td>庞大、复杂、高风险项目</td></tr><tr><td>6</td><td>喷泉模型</td><td>提高开发效率</td><td>不利于项目的管理</td><td>面向对象开发</td></tr><tr><td>7</td><td>XP模型</td><td>提高开发效率</td><td>不适合大团队、大项目</td><td>小团队，小项目</td></tr></tbody></table></div><p><br/></p>]]></content>
    
    
    <summary type="html">主要内容有软件危机、软件生命周期和8种典型的软件过程模型</summary>
    
    
    
    
    <category term="软件工程" scheme="https://wheliosc.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 8.0.13+Navicat 12.1.11安装记录</title>
    <link href="https://wheliosc.github.io/mysql-navicat-install-record"/>
    <id>https://wheliosc.github.io/mysql-navicat-install-record</id>
    <published>2018-12-19T09:24:23.000Z</published>
    <updated>2021-08-30T07:52:40.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="安装Mysql-8-0-13"><a href="#安装Mysql-8-0-13" class="headerlink" title="安装Mysql 8.0.13"></a>安装Mysql 8.0.13</h2><ul><li>下载<a href="https://dev.mysql.com/downloads/mysql/">MySQL Community Edition(GPL)</a><br>选择不带Debug和Test的版本（自定）。<br><img src="https://ws1.sinaimg.cn/large/006xwwY9ly1g13ivuwor6j310w06i0tj.jpg" alt="mysql"></li><li>解压到自选路径</li><li>添加配置文件</li></ul><p>解压后这个版本是没有my-default.ini的，在根目录下(eg. D:\Program Files\mysql-8.0.13-winx64)新建文本文档my.ini，内容如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"></span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line"></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">#设置3306端口</span><br><span class="line"></span><br><span class="line">port = 3306 </span><br><span class="line"></span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line"></span><br><span class="line">basedir=D:\Program Files\mysql-8.0.13-winx64</span><br><span class="line"></span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line"></span><br><span class="line">datadir=D:\Program Files\mysql-8.0.13-winx64\data</span><br><span class="line"></span><br><span class="line"># 允许最大连接数</span><br><span class="line"></span><br><span class="line">max_connections=200</span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line"></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line"></span><br><span class="line">default-storage-engine=INNODB </span><br><span class="line"></span><br><span class="line"># 默认主机地址（解决navicat连接数据库出现2003...(10061)错误）</span><br><span class="line"></span><br><span class="line">bind-address = 0.0.0.0</span><br></pre></td></tr></table></figure></p><p>默认字符集推荐UTF-8MB4，UTF-8在后面初始化时会出警告(虽然程序员从不看警告\doge)。<br>端口可以自己设置，不一定要3306，但不要端口冲突了就行。<br>安装目录和数据存放目录<strong>改成自己的</strong>！！！</p><ul><li><p>安装mysql服务</p><ul><li>以管理员身份运行cmd或者PowerShell，否则安装时会报错。（下面是PowerShell操作）</li><li>cd到bin目录，比如：<code>cd d:\Program Files\mysql-8.0.13-winx64\bin\</code></li><li><p>初始化<code>mysqld --initialize --console</code>(如果没有为mysql添加环境变量，就是<code>.\mysqld --initialize --console</code>)，等待一段时间，在根目录下的data文件夹里，就会生成一堆文件。<img src="https://wx2.sinaimg.cn/large/006xwwY9ly1g13ivv3fr2j30ki0lamz8.jpg" alt=""><br>控制台里会给一些提示，其中<code>A temporary password is generated for root@localhost:</code>后面跟的是随机生成的初始登录密码，复制备用。</p></li><li><p>安装服务<br><code>mysqld -install</code>，成功或者已经存在都会有提示。移除是<code>mysqld -remove</code></p></li><li>启动服务<br><code>net start mysql</code>，没有初始化的话，这里会出现(3534)错误。停止服务是<code>net stop mysql</code></li><li>登录<br><code>mysql -u root -p</code>，之后回车输入初始密码，然后就登录成功了。可以测试<code>show databases;</code>退出键入<code>quit</code></li><li>修改密码<br><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;xxxxxxx&#39;;</code><br>xxxxxxx是要设的密码。</li></ul></li></ul><h2 id="安装Navicat-12-1-11"><a href="#安装Navicat-12-1-11" class="headerlink" title="安装Navicat 12.1.11"></a>安装Navicat 12.1.11</h2><ul><li>下载<a href="https://www.navicat.com.cn/products/navicat-premium">Navicat premium 12.1.11</a><br>这个都会，关键肯定是在于How to use it for free？😏</li><li><a href="https://github.com/JohnHubcr/navicat-keygen">Use it for free.</a></li></ul><p><br/></p>]]></content>
    
    
    <summary type="html">Mysql 8.0.13+Navicat 12.1.11安装记录及使用方法</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://wheliosc.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>中间语言表示</title>
    <link href="https://wheliosc.github.io/Intermediate-language-representation"/>
    <id>https://wheliosc.github.io/Intermediate-language-representation</id>
    <published>2018-12-10T10:14:56.358Z</published>
    <updated>2021-08-30T07:52:34.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="编译器构成"><a href="#编译器构成" class="headerlink" title="编译器构成"></a>编译器构成</h2><p>编译器分为前端和后端：<br>前端：依赖于源语言，独立于目标机器。包括词法分析器、语法分析器、语义分析器和中间代码生成器。<br>后端：依赖于目标机器，独立于源语言。包括代码优化器和代码生成器。</p><h2 id="中间语言表示"><a href="#中间语言表示" class="headerlink" title="中间语言表示"></a>中间语言表示</h2><h3 id="后缀表示"><a href="#后缀表示" class="headerlink" title="后缀表示"></a>后缀表示</h3><ul><li>如果$E$是变量或常数，那么$E$的后缀表示就是$E$本身。</li><li>如果$E$是形式为$E_1 \ op \  E_2$的表达式，那么$E$的后缀表示是$E_1^{\prime}\  E_2^{\prime} \ op$，其中$E_1^{\prime}$和$E_2^{\prime}$分别是$E_1$和$E_2$的后缀表示。</li><li>如果$E$是形式为$(E_1)$的表达式，那么$E_1$的后缀表示也是$E$的后缀表示。</li><li>后缀表示不需要括号。</li></ul><p>🌰(8 - 4) + 2 的后缀表示是8 4 - 2 +</p><h3 id="图形表示——语法树有向无环图DAG"><a href="#图形表示——语法树有向无环图DAG" class="headerlink" title="图形表示——语法树有向无环图DAG"></a>图形表示——语法树有向无环图DAG</h3><p><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0uabt9morj30t90ccdhh.jpg" alt=""></p><h3 id="三地址代码"><a href="#三地址代码" class="headerlink" title="三地址代码"></a>三地址代码</h3><p>三地址代码是语法树或DAG的一种线性表示。<br>一般形式：$x := y\ op\ z$，其中，如果x不是最终结果，那么x作为临时变量放在活动记录的临时变量区中。<br>🌰$a := (-b + c<em>d ) + c</em>d$的DAG的三地址代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 = -b;</span><br><span class="line">t2 = c * d;</span><br><span class="line">t3 = t1 + t2;</span><br><span class="line">t4 = t2 + t3;</span><br><span class="line">a = t4;</span><br></pre></td></tr></table></figure></p><p><br/></p>]]></content>
    
    
    <summary type="html">中间语言表示，包括后缀表示、图形表示（语法树和DAG）以及三地址代码</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>L属性定义的计算</title>
    <link href="https://wheliosc.github.io/Computation-of-L-attribute-definition"/>
    <id>https://wheliosc.github.io/Computation-of-L-attribute-definition</id>
    <published>2018-12-09T12:27:43.701Z</published>
    <updated>2021-08-30T07:30:54.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="L属性定义的自上而下计算"><a href="#L属性定义的自上而下计算" class="headerlink" title="L属性定义的自上而下计算"></a>L属性定义的自上而下计算</h3><h4 id="L属性定义"><a href="#L属性定义" class="headerlink" title="L属性定义"></a>L属性定义</h4><p>如果每个产生式$A \rightarrow X _ { 1 } X _ { 2 } \cdots X _ { n }$的每条语义规则计算的属性是A的综合属性；或者是$X_j$的继承属性，$1 \leq j \leq n$, 但它仅依赖：</p><ul><li>该产生式中$X_j$左边符号$X _ { 1 } , X _ { 2 } , \dots , X _ { j - 1 }$的属性</li><li>A的继承属性</li></ul><p>显然，S属性定义属于L属性定义，因为上面的两条限制是对继承属性的限制。</p><h4 id="L属性定义与S属性定义的区别"><a href="#L属性定义与S属性定义的区别" class="headerlink" title="L属性定义与S属性定义的区别"></a>L属性定义与S属性定义的区别</h4><p>S属性定义中，只要将产生式作为一个整体看待即可，语义规则可以视为是附着在整个产生式上。<br>L属性定义则不一样，它跟属性所属的符号在产生式中的位置有关系，于是需要翻译方案。</p><h4 id="翻译方案"><a href="#翻译方案" class="headerlink" title="翻译方案"></a>翻译方案</h4><p>它的语义动作（在此不叫语义规则）放在花括号<code>&#123;&#125;</code>内，并且插入到产生式右部合适的地方。这是一种动作和分析交错的方法，以表示动作的执行时机。<br><strong>只有综合属性时：</strong><br>为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。<br><strong>既有综合属性又有继承属性时：</strong></p><ul><li>产生式右部符号的<strong>继承属性</strong>必须在先于这个符号的动作中计算。</li><li>一个动作不能引用该动作右边符号的<strong>综合属性</strong>。</li><li>左部非终结符的<strong>综合属性</strong>只能在它所引用的所有属性都计算完后才能计算。计算该属性的动作通常放在产生式右端的末尾。</li></ul><p>总的来说就是要保证动作在引用属性时其值已经可用，也就是要保证动作不会引用还没有计算出值的属性。</p><p>🌰对于文法<br>$S \rightarrow A _ { 1 } A _ { 2 } \quad \left\{ A _ { 1 } .in : = 1 ; A _ { 2 } .in : = 2 \right\}$<br>$A \rightarrow a \quad \{ p r i n t ( A.in ) \}$<br>不符合条件一。在分析$A_1$时，要把它推导成$a$然后输出$A_1.in$，然而，这个时候还不知道$A_1.in$的值，因为赋值动作在整个产生式的末尾。如果把第一条产生式改为$S \rightarrow\{ A _ { 1 } .in : = 1 ; A _ { 2 } .in : = 2\}A _ { 1 } A _ { 2 }$，则是合理的翻译方案。</p><h4 id="预测分析器的设计"><a href="#预测分析器的设计" class="headerlink" title="预测分析器的设计"></a>预测分析器的设计</h4><p>构造预测分析器时，必须要消除左递归，而消除左递归可能会引起继承属性的出现。原因是翻译分案的属性信息（语法树结点指针）的流动方向和归约的方向不一致。</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>(1) 函数的形参、返回值和局部变量</p><ul><li>对每个<strong>非终结符A</strong>构造一个函数过程，对A的每个<strong>继承属性</strong>设置一个<strong>形式参数</strong>。</li><li>函数的<strong>返回值</strong>为A的<strong>综合属性</strong>（作为记录，或指向记录的一个指针，记录中有若干域，每个属性对应一个域）。为了简单，假设每个非终结只有一个综合属性。</li><li>A对应的函数过程中，为出现在A的产生式中的<strong>每一个文法符号的每一个属性</strong>都设置一个<strong>局部变量</strong>。</li></ul><p>(2) 非终结符A对应的函数过程中，根据当前的输入符号决定使用哪个产生式候选。<br>(3) 每个产生式对应的程序代码中，按照从左到右的次序，对于单词符号（终结符）、非终结符和语义动作分别作以下工作：</p><ul><li>对于带有综合属性x的<strong>终结符</strong>X，把x的值存入为X.x设置的变量中。然后产生一个匹配X的调用，并继续读入一个输入符号。</li><li>对于每个<strong>非终结符</strong>B，产生赋值语句$c = B \left( b _ { 1 } , b _ { 2 } , \cdots , b _ { k } \right)$其中，$b _ { 1 } , b _ { 2 } , \cdots , b _ { k }$是为B的<strong>继承属性</strong>设置的变量，c是为B的<strong>综合属性</strong>设置的变量。</li><li>对于<strong>语义动作</strong>，把动作的代码抄进分析器中，用代表属性的变量来代替对属性的每一次引用。</li></ul><h4 id="用综合属性代替继承属性"><a href="#用综合属性代替继承属性" class="headerlink" title="用综合属性代替继承属性"></a>用综合属性代替继承属性</h4><h3 id="L属性定义的自下而上计算"><a href="#L属性定义的自下而上计算" class="headerlink" title="L属性定义的自下而上计算"></a>L属性定义的自下而上计算</h3><p>它能实现任何基于LL(1)文法的L属性定义，也能实现许多（但不是所有的）基于LR(1)的L属性定义。</p><h4 id="L属性自下而上计算需要解决的问题"><a href="#L属性自下而上计算需要解决的问题" class="headerlink" title="L属性自下而上计算需要解决的问题"></a>L属性自下而上计算需要解决的问题</h4><p>自下而上的分析中，语义动作的执行是在使用产生式对句柄进行归约的时候。但是，L属性定义的继承属性的计算需要嵌在产生式右部不同的地方。<br>🌰对于文法$A \rightarrow X Y \{ Z . i = X . x \} Z$<br>在$Z$还没有开始处理前，继承属性$Z.i$在栈中就没有对应的$val$条目供其使用。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>通过改写文法，使得所有嵌入在产生式中间的动作变换成只在产生式的最右端出现。分以下三种情况讨论：</p><h5 id="删除翻译方案中嵌入的动作"><a href="#删除翻译方案中嵌入的动作" class="headerlink" title="删除翻译方案中嵌入的动作"></a>删除翻译方案中嵌入的动作</h5><p>在文法中加入推出空串的标记<strong>非终结符</strong>，让每个嵌入动作由不同的标记非终结符M代表，并把该动作放在产生式$M \rightarrow \varepsilon$的右端。<br>🌰<br>$E \rightarrow T R$<br>$R \rightarrow + T \left\{ p r i n t \left( ^ { \prime } + ^ { \prime } \right) \right\} R _ { 1 } | - T \left\{ p r i n t \left(^ { \prime } - ^ { \prime } \right) \right\} R _ { 1 } | \varepsilon$<br>$T \rightarrow n u m \{p r i n t (n u m. v a l) \}$<br>删除嵌入动作后：<br>$E \rightarrow T R$<br>$R \rightarrow + T M R _ { 1 } \left| - T N R _ { 1 } \right| \varepsilon$<br>$M \rightarrow \varepsilon \{ print ( ^ { \prime } + ^ { \prime } )\}$<br>$N \rightarrow \varepsilon \{ print ( ^ { \prime } - ^ { \prime } )\}$<br>$T \rightarrow n u m \{p r i n t (n u m. v a l) \}$</p><h5 id="分析栈上的继承属性"><a href="#分析栈上的继承属性" class="headerlink" title="分析栈上的继承属性"></a>分析栈上的继承属性</h5><p><strong>第一种情况：所依赖的属性在分析栈上的位置能静态确定</strong><br>对于产生式$A\rightarrow XY$，因为$Y$以下的任何子树在规约前，$X.s$的值已经在栈中，所以它的值可以被$Y$继承。如果$Y$的继承属性由复写规则$Y.i=X.s$定义，$X.s$是综合属性，那么在需要使用$Y.i$的地方，都可以使用$X.s$代替，如果能静态的确定$X.s$在栈中的位置。<br><strong>第二种情况：所依赖的属性在分析栈上的位置不能静态确定</strong><br>🌰</p><div class="table-container"><table><thead><tr><th>产生式</th><th>语义规则</th></tr></thead><tbody><tr><td> $S\rightarrow aAC$</td><td>$C.i=A.s$</td><td></td></tr><tr><td> $S\rightarrow bABC$</td><td>$C.i=A.s$</td><td></td></tr><tr><td> $C\rightarrow c$</td><td>$C.s=g(C.i)$</td><td></td></tr></tbody></table></div><p>由于B可能在、也可能不在A和C之间，因此在使用$C\rightarrow c$规约时$C.i$的值（也就是$A.s$的值）在$stack[top-2].val$或者在$stack[top-1].val$。<br>可以添加一个标志非终结符M，使$M.i$继承A的综合属性值，然后第二个产生式中的C继承M的综合属性值，这样，无论是用第一个产生式还是第二个产生式，$C.i$的值都可以在$stack[top-1].val$中得到。</p><div class="table-container"><table><thead><tr><th>产生式</th><th>语义规则</th></tr></thead><tbody><tr><td> $S\rightarrow aAC$</td><td>$C.i=A.s$</td><td></td></tr><tr><td> $S\rightarrow bABMC$</td><td>$M.i=A.s;\ C.i=M.s$</td><td></td></tr><tr><td> $C\rightarrow c$</td><td>$C.s=g(C.i)$</td><td></td></tr><tr><td> $M\rightarrow \varepsilon$</td><td>$M.s=M.i$</td><td></td></tr></tbody></table></div><h5 id="模拟继承属性的计算"><a href="#模拟继承属性的计算" class="headerlink" title="模拟继承属性的计算"></a>模拟继承属性的计算</h5><p>如果继承属性并不直接等于某个综合属性，而是它的一个函数，可以使用标记非终结符来模拟继承属性的计算。<br>🌰</p><div class="table-container"><table><thead><tr><th>产生式</th><th>语义规则</th></tr></thead><tbody><tr><td> $S \rightarrow a A C$</td><td>$C.i =f(A.s)$</td><td></td></tr><tr><td> $C \rightarrow c$</td><td>$C.s=g(C.i)$</td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>产生式</th><th>语义规则</th></tr></thead><tbody><tr><td> $S \rightarrow a A N C$</td><td>$N . i = A . s; \ C.i = N.s$</td><td></td></tr><tr><td> $N \rightarrow \varepsilon$</td><td>$N.s=f(A.s)$</td><td></td></tr><tr><td> $C \rightarrow c$</td><td>$C.s=g(C.i)$</td><td></td></tr></tbody></table></div><h4 id="引进标记非终结符号对基础文法的影响"><a href="#引进标记非终结符号对基础文法的影响" class="headerlink" title="引进标记非终结符号对基础文法的影响"></a>引进标记非终结符号对基础文法的影响</h4><p><strong>基础文法是LL(1)文法</strong><br>没有影响，修改后的文法仍将保持LL(1)文法。因为每个标记非终结符号是唯一的，而且只有唯一一个的$\varepsilon$产生式。任何一个LL(1)文法一定是LR(1)文法，因此加标记非终结符不会引起LR分析动作的冲突。<br><strong>基础文法是LR(1)文法</strong><br>可能使修改后的文法变成非LR(1)文法。</p><p><br/></p>]]></content>
    
    
    <summary type="html">包括L属性定义的自上而下计算和L属性定义的自下而上计算</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>运行时存储空间的组织与管理</title>
    <link href="https://wheliosc.github.io/Organization-and-Management-of-Runtime-Storage-Space"/>
    <id>https://wheliosc.github.io/Organization-and-Management-of-Runtime-Storage-Space</id>
    <published>2018-12-09T12:24:55.526Z</published>
    <updated>2021-08-30T07:30:45.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>过程：是一个声明，最简单的形式是将一个名字和一个语句联系起来。名字是过程名，语句是程序体。<br>过程的活动：过程的一次执行被称为过程的一次活动。<br>活动记录：过程的每次活动所需信息的存储空间。<br>生存期：从过程体开始执行到执行结束的时间，包括消耗在其调用过程和调用过程中调用其它过程所花费的时间。</p><h2 id="局部存储分配"><a href="#局部存储分配" class="headerlink" title="局部存储分配"></a>局部存储分配</h2><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>作用域：一个声明起作用的程序部分。<br>即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象。比如对函数的一个形参，每次赋不同的值，形参的名字只声明了一次，但可以表示不同的保存值的存储单元。</p><h3 id="名字到存储单元的绑定"><a href="#名字到存储单元的绑定" class="headerlink" title="名字到存储单元的绑定"></a>名字到存储单元的绑定</h3><p>环境把名字映射到左值（存储单元），而状态把左值映射到右值（值）。<br>赋值改变状态，但不改变环境。<br>如果环境将名字x映射到存储单元s，就说x被绑定到s。</p><font color="red">名字</font> -- <font color="gold">环境</font> --> <font color="red">存储单元</font> -- <font color="gold">状态</font> --> <font color="red">值</font><h3 id="活动记录"><a href="#活动记录" class="headerlink" title="活动记录"></a>活动记录</h3><p>一般的活动记录包括以下内容：</p><div class="table-container"><table><thead><tr><th>域</th><th>用途 </th></tr></thead><tbody><tr><td> 临时数据</td><td>保存临时值，比如寄存器不足时，将计算的中间结果存放在这</td></tr><tr><td> 局部数据</td><td>保存本过程内部定义的局部变量</td></tr><tr><td> 保存的机器状态</td><td>用于保存本过程调用前的机器状态</td></tr><tr><td> 访问链</td><td>通过访问链访问非局部数据</td></tr><tr><td> 控制链</td><td>指向调用者的活动记录</td></tr><tr><td> 返回值</td><td>存放本过程返回给调用过程的值</td></tr><tr><td> 参数</td><td>存放调用过程提供的实在参数</td></tr></tbody></table></div><h3 id="局部数据的布局"><a href="#局部数据的布局" class="headerlink" title="局部数据的布局"></a>局部数据的布局</h3><p>字节是可编址内存的最小单位。<br>一个过程所声明的局部变量，按这些变量声明时出现的次序，在活动记录的局部数据区中依次分配空间。<br>局部数据的地址可以用相对于某个位置（本过程对应的活动记录的起始位置）的偏移来表示。<br>数据对象的存储安排深受目标机器寻址方式的影响，存在对齐问题。例如，要求整数（int，long）的相对地址可以被4整除。<br>由于对齐而引起的无用空间称为衬垫空白区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于以下两个结构体，因为衬垫区的存在，其size不同</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>   c1;</span><br><span class="line">    <span class="keyword">char</span>   c2;</span><br><span class="line">    <span class="keyword">int</span>    i1;</span><br><span class="line">    <span class="keyword">double</span> d1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>   c1;</span><br><span class="line">    <span class="keyword">int</span>    i1;</span><br><span class="line">    <span class="keyword">double</span> d1;</span><br><span class="line">    <span class="keyword">char</span>   c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="全局栈式存储分配"><a href="#全局栈式存储分配" class="headerlink" title="全局栈式存储分配"></a>全局栈式存储分配</h2><h3 id="运行时内存空间的划分"><a href="#运行时内存空间的划分" class="headerlink" title="运行时内存空间的划分"></a>运行时内存空间的划分</h3><div class="table-container"><table><thead><tr><th>区</th><th>用途 </th></tr></thead><tbody><tr><td> 代码</td><td>存放目标代码（.exe） </td></tr><tr><td> 静态区</td><td>全局变量，静态变量等</td></tr><tr><td> 堆</td><td>动态分配的内存 </td></tr><tr><td> 空闲内存</td><td>为堆和栈提供动态支持 </td></tr><tr><td> 栈</td><td>活动记录 </td></tr></tbody></table></div><p>堆和栈是动态的，在它们占用的存储空间不断变化时，相向增长。在实际机器中，堆向高地址增长，栈向低地址增长。</p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="静态分配策略"><a href="#静态分配策略" class="headerlink" title="静态分配策略"></a>静态分配策略</h4><p>名字在程序被<strong>编译时绑定</strong>到存储单元，不需要运行时的任何支持。<br>绑定的生存期是程序的<strong>整个运行时间</strong>。<br>控制再次进入该过程时，局部变量的值和控制上一次<strong>离开时的一样</strong>。<br>每个活动记录的大小是固定的。<br>过程调用时保存信息的地址在编译时也是已知的。</p><h4 id="栈式分配策略——活动树和运行栈"><a href="#栈式分配策略——活动树和运行栈" class="headerlink" title="栈式分配策略——活动树和运行栈"></a>栈式分配策略——活动树和运行栈</h4><p>栈式分配主要用于管理过程的活动记录。<br>局部变量的生存期是<strong>过程活动的时间</strong>。<br>控制进入该过程时，局部变量绑定到存储单元，过程活动结束后，<strong>局部变量的空间释放</strong>。</p><h5 id="活动树"><a href="#活动树" class="headerlink" title="活动树"></a>活动树</h5><ul><li>每个结点代表某过程的一个活动</li><li>根结点代表主程序的活动</li><li>结点a是结点b的父结点，当且仅当控制流从a的活动进入b的活动</li><li>结点a 处于结点b 的左边，当且仅当a的生存期先于b的生存期</li></ul><p>活动的执行顺序（程序的控制流）对应活动树的后根遍历（深度优先）。</p><h5 id="运行栈"><a href="#运行栈" class="headerlink" title="运行栈"></a>运行栈</h5><p>把控制栈中的信息拓广到包括过程活动所需的所有<strong>局部信息</strong>（即活动记录）。不要把静态的数据画在运行栈里。</p><h5 id="栈上可变长数据"><a href="#栈上可变长数据" class="headerlink" title="栈上可变长数据"></a>栈上可变长数据</h5><p>活动记录的长度在编译时不能确定的情况。🌰局部数组的大小要等到过程激活时才能确定。<br>解决方案：<br>编译时，在活动记录中为这样的数组分配存放数组指针的单元。<br>运行时，这些指针指向分配在栈顶的数组存储空间。<br>运行时，对数组的访问都要通过相应指针来间接访问。</p><h5 id="悬空引用"><a href="#悬空引用" class="headerlink" title="悬空引用"></a>悬空引用</h5><p>引用某个已被释放的存储单元<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">dangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;  <span class="comment">// return之后，i的存储单元被释放掉了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    p = dangle();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="堆式分配策略"><a href="#堆式分配策略" class="headerlink" title="堆式分配策略"></a>堆式分配策略</h4><p>内存分配与释放按照任意次序进行。<br>堆中可能包含交错的正在使用的和已经释放的区域。</p><h4 id="三种分配策略的比较"><a href="#三种分配策略的比较" class="headerlink" title="三种分配策略的比较"></a>三种分配策略的比较</h4><div class="table-container"><table><thead><tr><th>\</th><th>静态分配</th><th>栈式分配</th><th>堆式分配</th></tr></thead><tbody><tr><td> 使用范围</td><td>外部变量、静态局部变量、常量</td><td>局部变量、形参</td><td>动态变量</td></tr><tr><td> 分配时间</td><td>程序开始前</td><td>进入过程前</td><td>用户决定</td></tr><tr><td> 释放时间</td><td>程序结束后</td><td>过程结束</td><td>用户决定</td></tr><tr><td> 地址计算时间</td><td>编译时</td><td>运行时</td><td>运行时</td></tr><tr><td> 存取速度</td><td>快</td><td>慢</td><td>慢</td></tr></tbody></table></div><h2 id="非局部名字的访问"><a href="#非局部名字的访问" class="headerlink" title="非局部名字的访问"></a>非局部名字的访问</h2><h3 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h3><h4 id="无过程嵌套的静态作用域"><a href="#无过程嵌套的静态作用域" class="headerlink" title="无过程嵌套的静态作用域"></a>无过程嵌套的静态作用域</h4><p>由于没有过程嵌套，声明在过程外的所有变量都可以分配在静态区。过程体中的非局部引用可以直接使用静态确定的地址（非局部数据此时就是全局数据）。</p><h4 id="有过程嵌套的静态作用域"><a href="#有过程嵌套的静态作用域" class="headerlink" title="有过程嵌套的静态作用域"></a>有过程嵌套的静态作用域</h4><h5 id="过程嵌套深度"><a href="#过程嵌套深度" class="headerlink" title="过程嵌套深度"></a>过程嵌套深度</h5><p>设主程序的嵌套深度为1，从一个过程进入一个被包围的过程时，嵌套深度加1。<br>变量的嵌套深度：它的声明所在过程的嵌套深度作为该名字的嵌套深度。</p><h5 id="访问链（静态链）"><a href="#访问链（静态链）" class="headerlink" title="访问链（静态链）"></a>访问链（静态链）</h5><p>如果过程p直接嵌在过程q中，那么过程p的活动记录的访问链直接指向<strong>最靠近的</strong>属于过程q的活动记录的访问链。<br>假定过程p的嵌套深度为$n_p$，它调用嵌套深度为$n_x$的过程x:<br>(1) $n_p &lt; n_x$。表明被调用过程比p嵌的更深，而且过程x肯定嵌在过程p里，否则无法调用。这种情况下需要追踪访问链$n_x-n_p$次。<br>(1) $n_p \geq n_x$。追踪访问链$n _ { p } - n _ { x } + 1$次到达了静态包围x和p的且离它们最近的那个过程的最新活动记录。所到达的访问链就是x的活动记录中的访问链应该指向的那个访问链。</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>被调用过程的非局部名字a和它在调用过程中引用的是<strong>同样的</strong>存储单元。<br>新的绑定仅为被调用过程的局部名字建立，这些名字在被调用过程的活动记录中<strong>占用</strong>存储单元。<br>总结的说，动态作用域就是<strong>谁调用的找谁</strong>。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="值调用"><a href="#值调用" class="headerlink" title="值调用"></a>值调用</h3><p>实参的右值传给被调用过程。把形参当作所在过程的局部名看待，形参的存储单元在该过程的活动记录中。调用过程计算实参，并把右值放入形参的存储单元中。</p><font color="red">对形参的任何操作不会影响调用者实参的值。</font><h3 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h3><p>实参的左值传给被调用过程。把实参的左值放入形参的存储单元。在被调用过程的目标代码中，任何对形参的引用都是通过传给该过程的指针来间接引用实参的。</p><font color="red">对形参的任何赋值都会影响调用者实参的值。</font><h3 id="换名调用"><a href="#换名调用" class="headerlink" title="换名调用"></a>换名调用</h3><p>用实参表达式对形参进行正文替换。<br><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> main(input,output);</span><br><span class="line">    <span class="keyword">var</span> a,b: integer;</span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">p</span><span class="params">(x,y,z: integer)</span>;</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        y:＝y+<span class="number">1</span>;</span><br><span class="line">        z:＝z+x;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        a:＝<span class="number">2</span>;</span><br><span class="line">        b:＝<span class="number">3</span>;</span><br><span class="line">        p(a+b, a, a);</span><br><span class="line">        print a;</span><br><span class="line">    <span class="keyword">end</span>．</span><br><span class="line"><span class="comment">&#123;值调用结果为2，不改变实参值&#125;</span></span><br><span class="line"><span class="comment">&#123;引用调用结果为8，a+b的结果5放在临时变量中，传参时将临时变量地址传过去&#125;</span></span><br><span class="line"><span class="comment">&#123;换名调用可以看作是执行a=a+1;a=a+(a+b);注意在第二条语句中右边的每一个a都等于3&#125;</span></span><br></pre></td></tr></table></figure></p><p><br/></p>]]></content>
    
    
    <summary type="html">包括局部存储分配（活动记录等）、运行时内存分配策略、非局部名字的访问和参数传递等内容</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>语法制导的定义</title>
    <link href="https://wheliosc.github.io/Syntax-Directed-Definition"/>
    <id>https://wheliosc.github.io/Syntax-Directed-Definition</id>
    <published>2018-12-05T12:08:57.510Z</published>
    <updated>2021-08-30T07:56:52.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="语法制导"><a href="#语法制导" class="headerlink" title="语法制导"></a>语法制导</h3><p>语义分析的主流技术是语法制导翻译技术。<br>语法制导是带有<strong>属性</strong>和<strong>规则</strong>的上下文无关文法。<br>属性：在上下文无关文法的基础上，为每个文法符号（终结符或非终结符）配备若干相关的“值”，称为属性。属性可以计算和传递。<br>规则：对于文法的每个产生式都配备了一组属性的计算规则。</p><h3 id="综合属性和继承属性"><a href="#综合属性和继承属性" class="headerlink" title="综合属性和继承属性"></a>综合属性和继承属性</h3><p>每个文法产生式$A \rightarrow \alpha$有一组形式为$b : = f \left( c _ { 1 } , c _ { 2 } , \cdots , c _ { k } \right)$的语义规则，其中$f$是函数，$b$和$c _ { 1 } , c _ { 2 } ,  \cdots ,  c _ { k }$是该产生式文法符号的属性。</p><h4 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h4><p>如果$b$是$A$的属性，$c _ { 1 } , c _ { 2 } ,  \cdots ,  c _ { k }$ 是产生式右部文法符号的属性或$A$的其它属性。属性值由分析树中它的子结点的属性值来计算。</p><h4 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h4><p>如果$b$是产生式右部某个文法符号$A$的属性， $c _ { 1 } , c _ { 2 } ,  \cdots ,  c _ { k }$是产生式右部文法符号的属性或$A$的其它属性。属性值由结点的兄弟结点及父结点的属性值来计算。</p><h4 id="关于属性"><a href="#关于属性" class="headerlink" title="关于属性"></a>关于属性</h4><ul><li>终结符只有综合属性，并且这些综合属性通常由词法分析器提供。因为终结符没有任何的子结点。</li><li>非终结符号既有综合属性也可有继承属性，文法的开始符号没有继承属性，除非另外加以说明。因为开始符号没有任何的兄弟结点或者父结点。</li><li>文法符号的综合属性集和继承属性集的交集应为空。</li><li>对出现在<strong>产生式右边的继承属性</strong>和出现在<strong>产生式左边的综合属性</strong>都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性。</li><li>出现在<strong>产生式左边的继承属性</strong>和出现在<strong>产生式右边的综合属性</strong>不由所给的产生式的属性计算规则进行计算，它们由其它产生式的属性规则计算或者由属性计算器的参数提供。</li></ul><h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><p>属性文法是指语义规则函数无副作用的语法制导定义。<br>副作用指的是过程调用或程序段（比如打印值、输出中间代码等）。<br>🌰在产生式的语义规则中定义print(E.val)</p><h3 id="注释分析树"><a href="#注释分析树" class="headerlink" title="注释分析树"></a>注释分析树</h3><p>每个结点的属性值都标注出来的分析树，称为注释分析树。<br>分析树是（最左、最右）推导的图形表示。每个分支结点由非终结符标记，子结点由该终结符本次推导所用产生式的右部的各符号依次标记。</p><h3 id="属性依赖图"><a href="#属性依赖图" class="headerlink" title="属性依赖图"></a>属性依赖图</h3><p>在一棵分析树中的结点的继承属性和综合属性之间的相互依赖关系可以由称作依赖图的一个有向图来描述。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>为每一个包含过程调用的语义规则引入一个虚拟综合属性b，这样把每一个语义规则都写成$b : = f \left( c _ { 1 } , c _ { 2 } , \cdots , c _ { k } \right)$的形式。</li><li>依赖图中为每一个属性设置一个结点，如果属性b依赖于属性c，则从属性c的结点有一条有向边连到属性b的结点。</li></ul><p>简单的说，如果一个属性n需要另一个属性m才能进行计算，那么添加一个有向线由m指向n。</p><h4 id="属性的计算次序"><a href="#属性的计算次序" class="headerlink" title="属性的计算次序"></a>属性的计算次序</h4><p>良定义的：若一个属性文法不存在属性之间的循环依赖关系，则称该文法为良定义的。<br>如果是良定义的，那么依赖图的任一拓扑排序都是一个合理的属性计算顺序。</p><p><br/></p>]]></content>
    
    
    <summary type="html">语法制导的定义，包括综合属性和继承属性、注释分析树、属性依赖图等内容</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="语法制导" scheme="https://wheliosc.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>自下而上的语法分析</title>
    <link href="https://wheliosc.github.io/Bottom-up-parsing"/>
    <id>https://wheliosc.github.io/Bottom-up-parsing</id>
    <published>2018-12-01T13:50:25.295Z</published>
    <updated>2021-08-30T07:30:50.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>右句型$\gamma$的句柄是一个产生式的右部$\beta$，并且该句柄$\beta$通过产生式$A\rightarrow\beta$归约后，得到的是最右推导中的前一个句型。<br>右句型：所有在最右推导中出现的句型都是右句型。<br>🌰$S \Rightarrow _ { r m }$ <strong>aABe</strong> $\Rightarrow _ { r m }$ aA<strong>d</strong>e $\Rightarrow _ { r m }$ a<strong>Abc</strong>de $\Rightarrow _ { r m }$ a<strong>b</strong>bcde<br>文法为<br>$S \rightarrow$ aABe<br>${ A \rightarrow A b c | b }$<br>$B \rightarrow d$<br>abbcde中的第一个b通过$A\rightarrow b$归约后得到aAbcde，是最右推导的前一个句型，所以第一个b是句柄。而第二个b通过$A\rightarrow b$归约后得到aAAcde，不是最右推导的前一个句型，所以第二个b不是句柄。（栗子中加粗部分为句柄）</p><ul><li>句柄的右边仅含终结符。</li><li>如果文法二义，那么句柄可能不唯一。</li></ul><h2 id="两个冲突"><a href="#两个冲突" class="headerlink" title="两个冲突"></a>两个冲突</h2><p>移进-归约冲突：既可以移进又可以归约时，无法决定。<br>归约-归约冲突：当不止一个产生式可以归约，无法决定对哪个产生式进行归约。</p><h2 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h2><p>活前缀：右句型的前缀，该前缀不超过最右句型句柄的右端。<br>在移进-归约分析中，出现在栈中的串都是活前缀。<br>🌰$\mathcal { S } \Rightarrow * _ { r m } \gamma A w \Rightarrow _ { r m } \gamma \beta w$<br>$\gamma \beta$的任意前缀（包括$\varepsilon$和$\gamma \beta$本身）都是活前缀，这里的$\beta$是句柄。</p><h2 id="LR分析表"><a href="#LR分析表" class="headerlink" title="LR分析表"></a>LR分析表</h2><p>L表示从左到右扫描输入串，R表示最右推导。分为LR(0)/SLR(1)、LR(1)、LALR三种。</p><h3 id="构造SLR分析表"><a href="#构造SLR分析表" class="headerlink" title="构造SLR分析表"></a>构造SLR分析表</h3><ul><li>拓广文法，即添加产生式$S ^ { \prime } \rightarrow S$</li><li>构建识别活前缀的DFA</li><li>根据DFA构建SLR分析表</li></ul><h4 id="构建识别活前缀的DFA"><a href="#构建识别活前缀的DFA" class="headerlink" title="构建识别活前缀的DFA"></a>构建识别活前缀的DFA</h4><p><strong>LR(0)闭包函数closure(I)</strong></p><ul><li>I中的所有项都属于closure(I)</li><li>如果$A \rightarrow \alpha \cdot B \beta$属于closure(I)，并且$B \rightarrow \gamma$是产生式，那么如果$B \rightarrow \cdot \gamma$还不在closure(I)中，则把它加入closure(I)中。</li><li>重复上面两个步骤，直至closure(I)不再变化。</li></ul><p><strong>LR(0)状态转换函数goto(I, X)</strong><br>I状态集中所有形如$[ A \rightarrow \alpha \cdot X \beta ]$的产生式对应的产生式$[ A \rightarrow \alpha X \cdot \beta ]$的<strong>LR(0)闭包</strong>。X为终结符或非终结符。<br>🌰$S \rightarrow$ aABe ；${ A \rightarrow A b c | b }$ ；$B \rightarrow d$<br>对于$I_0: S’ \rightarrow S$；$S \rightarrow \cdot aABe$<br>$I_1=goto(I_0, a):$ $S \rightarrow a \cdot ABe$；$A \rightarrow \cdot Abc$；$A \rightarrow \cdot b$</p><p><strong>识别文法G活前缀的DFA通过下面的方式构造：</strong></p><ul><li>令$C = \{closure(S’ \rightarrow S)\}$</li><li>对$C$中的每一个项目集应用转换函数goto(I, X)得到新的项目集$I_n$，并把$I_n$加入到$C$中。</li><li>重复第二步，直到$C$不再增大为止。</li></ul><h4 id="根据DFA构建SLR分析表"><a href="#根据DFA构建SLR分析表" class="headerlink" title="根据DFA构建SLR分析表"></a>根据DFA构建SLR分析表</h4><p><strong>状态i从$I_i$构造，它的action函数如下确定：</strong></p><ul><li>如果$[ A \rightarrow \alpha \cdot a \beta ]$在$I_i$中，并且goto($I_i$,a )=$I_j$，那么置action[i, a]为$s_j$。</li><li>如果$[ A \rightarrow \alpha \cdot ]$在$I_i$中，那么对FOLLOW(A)中的所有终结符a，置action[i, a]为$r_j$，$j$是产生式$A \rightarrow \alpha \cdot$的编号。</li><li>如果$\left[ \mathcal { S } ^ { \prime } \rightarrow \mathcal { S } \cdot \right]$在$I_i$中，那么置action[i,　💲]为接受acc。</li></ul><p>如果出现动作冲突，那么该文法就不是SLR(1)的。 </p><p><strong>构造状态i的goto函数：</strong><br>对所有的非终结符A，如果goto($I_i$,A)= $I_j$, 那么goto[i, A]=$j$。</p><p><strong>不能由上面两步定义的条目都为error。</strong></p><h4 id="SLR-1-文法的问题"><a href="#SLR-1-文法的问题" class="headerlink" title="SLR(1)文法的问题"></a>SLR(1)文法的问题</h4><p>每个SLR(1)文法都不是二义的，但是，有许多非二义的文法不是SLR(1)，文法描述能力弱。SLR(1)是在构造完DFA的LR(0)项目集之后才应用预测符号的，即对需要归约的产生式，当其遇到产生式左部非终结符的FOLLOW集中的终结符时才进行归约，而在LR(0)的构造中没有考虑预测。</p><h3 id="构造规范的LR分析表"><a href="#构造规范的LR分析表" class="headerlink" title="构造规范的LR分析表"></a>构造规范的LR分析表</h3><p>基本步骤同SLR一样，只在第二步和第三步时有所不同，只说不同的地方。</p><h4 id="构建识别活前缀的DFA-1"><a href="#构建识别活前缀的DFA-1" class="headerlink" title="构建识别活前缀的DFA"></a>构建识别活前缀的DFA</h4><p>使用LR(1)文法，1表示项目$[A \rightarrow \alpha \cdot \beta , a]$中搜索符的长度。<br><strong>LR(1)闭包函数closure(I)</strong></p><ul><li>I中的所有项都属于closure(I)</li><li>若$[A\rightarrow \alpha \cdot B \beta, a]$属于closure(I)，$B\rightarrow \gamma$是产生式，则对于每个终结符b$\in FIRST(\beta a)$，项$[B\rightarrow \cdot \gamma ,b]$也加入到closure(I)中。</li><li>重复上面两个步骤，直至closure(I)不再变化。</li></ul><p>搜索符b的集合是FOLLOW(B)的一个子集。</p><p><strong>LR(1)状态转换函数goto(I, X)</strong><br>I状态集中所有形如$[ A \rightarrow \alpha \cdot X \beta,b ]$的产生式对应的产生式$[ A \rightarrow \alpha X \cdot \beta,b ]$的<strong>LR(1)闭包</strong>。X为终结符或非终结符。注意这里的搜索符集b是直接由前面对应的项目抄过来的。</p><p><strong>识别文法G活前缀的DFA通过下面的方式构造：</strong></p><ul><li>令$C = \{closure([S’ \rightarrow S, doller])\}$注：这里的doller指💲，latex解析不正确这样代替一下…</li><li>对$C$中的每一个项目集应用转换函数goto(I, X)得到新的项目集$I_n$，并把$I_n$加入到$C$中。</li><li>重复第二步，直到$C$不再增大为止。</li></ul><h4 id="根据DFA构建SLR分析表-1"><a href="#根据DFA构建SLR分析表-1" class="headerlink" title="根据DFA构建SLR分析表"></a>根据DFA构建SLR分析表</h4><p>基本同SLR，不同点在于：在action函数中，如果有归约，SLR是根据左部非终结符的<strong>FOLLOW集</strong>决定进行归约；LR(1)是根据<strong>搜索符</strong>决定进行归约。</p><h4 id="LR-1-文法的问题"><a href="#LR-1-文法的问题" class="headerlink" title="LR(1)文法的问题"></a>LR(1)文法的问题</h4><p>LR(1)文法描述能力较强，但是由于状态数目多，分析表较大。</p><h3 id="构造LALR分析表"><a href="#构造LALR分析表" class="headerlink" title="构造LALR分析表"></a>构造LALR分析表</h3><p>LALR是在SLR(1)和LR(1)之间进行了文法描述能力与分析表紧凑程度之间做的折中。</p><h4 id="LALR的做法"><a href="#LALR的做法" class="headerlink" title="LALR的做法"></a>LALR的做法</h4><p>合并识别LR(1)文法的活前缀的DFA中的同心项目集。</p><h4 id="同心项目集"><a href="#同心项目集" class="headerlink" title="同心项目集"></a>同心项目集</h4><p>略去搜索符后相同的项目集。<br>🌰$B \rightarrow \cdot b B$ 和 $B \rightarrow \cdot b B ,b / a$</p><h4 id="合并同心集引起的冲突"><a href="#合并同心集引起的冲突" class="headerlink" title="合并同心集引起的冲突"></a>合并同心集引起的冲突</h4><p><strong>同心集的合并不会引起新的移进-归约冲突。</strong><br>🌰如果同心集中有移进-归约冲突$\left[ A \rightarrow \alpha \cdot, a / b \right][ B \rightarrow \beta \cdot a \gamma , c / d ]$，当面对输入符号a时不知道该移进还是归约。合并前的项目集应该有$\left[ A \rightarrow \alpha \cdot, x \right][ B \rightarrow \beta \cdot a \gamma , y ]$，肯定有个x为a，所以一定存在移进-归约冲突，说明合并之前就存在移进-归约冲突了。</p><p><strong>同心集的合并有可能产生新的归约-归约冲突。</strong><br>🌰合并前项目集$[A \rightarrow c \cdot, d][B \rightarrow c \cdot, e]$和$[A \rightarrow c \cdot, e][B \rightarrow c \cdot, d]$，合并后为<br>$[A \rightarrow c \cdot, e/d][B \rightarrow c \cdot, d/e]$，此时就产生了新的归约-归约冲突。</p><h2 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h2><p>求LR分析表的工具：<br><a href="https://cyberzhg.github.io/toolbox/lr0">LR(0)/SLR(1)</a>　　<a href="https://cyberzhg.github.io/toolbox/lr1">SLR(1)</a>　　<a href="https://cyberzhg.github.io/toolbox/lalr">LALR</a></p><p><br/></p>]]></content>
    
    
    <summary type="html">自下而上语法分析，内容包括句柄、活前缀的概念，两种冲突，以及三种LR分析表的画法</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="语法分析" scheme="https://wheliosc.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>自上而下的语法分析</title>
    <link href="https://wheliosc.github.io/Top-down-parsing"/>
    <id>https://wheliosc.github.io/Top-down-parsing</id>
    <published>2018-11-28T10:31:50.574Z</published>
    <updated>2021-08-30T07:57:05.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><p>进行自上而下的语法分析，基于文法是LL(1)文法。分为递归下降的预测分析和非递归下降的预测分析。</p><h3 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h3><p>对产生式组<br>$A \rightarrow \alpha | \alpha b_1 | \alpha b_2 | \ldots | \alpha b_m | \gamma_1 | \gamma_2 | \ldots | \gamma_p$<br>用如下产生式组替换<br>$A \rightarrow \alpha A ^ { \prime } \left| \gamma _ { 1 } \right| \gamma _ { 2 } | \ldots | \gamma _ { p }$<br>$A ^ { \prime } \rightarrow \varepsilon | b _ 1| b _ 2 | \dots | b _ { \mathrm { m } }$</p><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>对产生式组<br>$A \rightarrow A \alpha _ { 1 } | A \alpha _ { 2 } | \cdots | A \alpha _ { n } | \beta _ { 1 } | \beta _ { 2 } | \ldots | \beta _ { m }$<br>用如下产生式组替换<br>$A \rightarrow \beta _ { 1 } A ^ { \prime } | \beta _ { 2 } A ^ { \prime } | \ldots | \beta _ { m } A ^ { \prime }$<br>$A ^ { \prime } \rightarrow \alpha _ { 1 } \mathrm { A ^ { \prime } } | \alpha _ { 2 } \mathrm { A ^ { \prime } } |\ldots | \alpha _ { \mathrm { n } } \mathrm { A ^ { \prime } } | \varepsilon$<br><strong>Tips: 消除左递归并非一定产生等价的LL(1)文法。</strong><br>🌰$S\rightarrow Aa \mid b, A\rightarrow SB, B\rightarrow ab$</p><ul><li>如果把A的产生式代入S的产生式得到等价文法是LL(1)的。</li><li>如果把S的产生式代入A的产生式得到等价文法不是LL(1)的。</li></ul><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p>第一个L代表从左到右扫描输入串，第二个L代表最左推导，1表示分析的每一步只需向前查看一个符号。<br>LL(1)文法具有无二义性、无左公因子、无左递归的性质。对于文法的任何非终结符，使用它匹配输入串时，能够根据所面临的输入符号准确的选择产生式，如果该产生式匹配成功，那么这个匹配不是虚假匹配，如果该产生式匹配不成功，则用其他的产生式也一定不会匹配成功。</p><h4 id="判断一个文法是否是LL-1-文法"><a href="#判断一个文法是否是LL-1-文法" class="headerlink" title="判断一个文法是否是LL(1)文法"></a>判断一个文法是否是LL(1)文法</h4><p>对于文法中的任何两个产生式$A\rightarrow\alpha\mid\beta$，满足：</p><ul><li>FISRT($\alpha$)$\bigcap$FISRT($\beta$)=$\varnothing$</li><li>如果$\beta\Rightarrow^*\varepsilon$，那么$FISRT(\alpha)\bigcap FOLLOW(\beta)=\varnothing$</li></ul><h3 id="非递归分析预测分析表的构建"><a href="#非递归分析预测分析表的构建" class="headerlink" title="非递归分析预测分析表的构建"></a>非递归分析预测分析表的构建</h3><ul><li>对文法的每个产生式$A\rightarrow\alpha$，执行第二步和第三步。</li><li>对FIRST($\alpha$)的每个终结符a，把$A\rightarrow\alpha$加入 M[A, a]（即加入表中A行a列）。</li><li>如果$\varepsilon$在FIRST($\alpha$)中，对FOLLOW(A)的每个终结符b（包括💲）, 把$A\rightarrow\alpha$加入M[A, b]。</li><li>M的其它没有定义的条目都是error。</li></ul><p><br/></p>]]></content>
    
    
    <summary type="html">自上而下语法分析，内容包括如何将文法转变为LL(1)文法，以及如何判断LL(1)文法，构造预测分析表</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="语法分析" scheme="https://wheliosc.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>用例图中拓展(extend)和包含(include)的区别</title>
    <link href="https://wheliosc.github.io/the-difference-between-include-and-extend-in-use-case-diagram"/>
    <id>https://wheliosc.github.io/the-difference-between-include-and-extend-in-use-case-diagram</id>
    <published>2018-11-27T10:02:30.533Z</published>
    <updated>2021-08-30T07:57:15.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="拓展-Extend"><a href="#拓展-Extend" class="headerlink" title="拓展(Extend)"></a>拓展(Extend)</h3><p>扩展关系是扩展用例的泛化关系继续基本用例的行为。扩展用例通过在概念上将附加动作序列插入基本用例序列来实现这一点。这允许扩展用例在基本用例中达到适当的<strong>扩展点</strong>并且满足<strong>扩展条件</strong>时继续基本用例的活动序列。当扩展用例活动序列完成时，基本用例继续。<br>扩展用例通常定义<strong>可选</strong>的行为，这些行为本身并不一定有意义。<br><img src="https://wx1.sinaimg.cn/large/006xwwY9ly1g0ubur8404j309f04gdfr.jpg" alt=""><br>注册用例本身就是<strong>完整</strong>且有意义的。它可以通过<strong>可选</strong>的Get Help On Registration用例进行扩展。拓展点为Registration Help。</p><h3 id="包含-include"><a href="#包含-include" class="headerlink" title="包含(include)"></a>包含(include)</h3><p>包含的用例的执行类似于编程中的子程序调用或宏命令。包含用例取决于所包含的用例的添加，这是<strong>必需</strong>的而非可选的。<br><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0ubxc8alxj30h802u0sn.jpg" alt=""><br>_用例B从较大的用例A中提取到一个单独的用例中。_<br><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0uc1w8p89j30h8035aa1.jpg" alt=""><br>_用例B和C从较大的用例A中提取到单独的用例中。_<br><img src="https://wx1.sinaimg.cn/large/006xwwY9ly1g0uc2apenxj30hs06edfw.jpg" alt=""><br>_用例C是从用例A和B中提取出来的，两个用例都使用UML包含关系重用。_<br><img src="https://wx3.sinaimg.cn/large/006xwwY9ly1g0uc2o9dt0j308h06ojra.jpg" alt=""><br>_结帐用例包括几个用例 - 扫描项目，计算总额和税金以及付款_</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="用例之间的依赖关系"><a href="#用例之间的依赖关系" class="headerlink" title="用例之间的依赖关系"></a>用例之间的依赖关系</h3><p>在拓展关系中，基本用例是不依赖拓展用例来完成自身功能的。<br>在包含关系中，基本用例必须依赖包含的用例才能完成自身的功能。</p><h3 id="基本用例完整性"><a href="#基本用例完整性" class="headerlink" title="基本用例完整性"></a>基本用例完整性</h3><p>在拓展关系中，基本用例是完整的；而在包含关系中，基本用例是不完整的，是抽象用例。</p><h3 id="通过拓展点区别"><a href="#通过拓展点区别" class="headerlink" title="通过拓展点区别"></a>通过拓展点区别</h3><p>拓展关系是具有拓展点的，如果在两个用例之间可以找到一个合理的拓展点，那么可以认为两个用例之间是具有拓展关系的。</p><h3 id="通过目的区别"><a href="#通过目的区别" class="headerlink" title="通过目的区别"></a>通过目的区别</h3><p>包含关系旨在重用由另一个用例建模的行为，而拓展关系旨在为现有用例添加部分以及为可选系统服务建模。<br>Include =重用功能<br>Extends =新功能和/或可选功能</p><h2 id="用例关系的比较"><a href="#用例关系的比较" class="headerlink" title="用例关系的比较"></a>用例关系的比较</h2><p><img src="https://wx2.sinaimg.cn/large/006xwwY9ly1g0ubw7n5qjj30xl08t0ug.jpg" alt=""></p><p></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.uml-diagrams.org">uml-diagrams.org</a><br><a href="https://stackoverflow.com/questions/1696927/whats-is-the-difference-between-include-and-extend-in-use-case-diagram">Stack Overflow: What’s is the difference between include and extend in use case diagram?</a><br><a href="http://www.agilemodeling.com/essays/useCaseReuse.htm">Reuse in Use-Case Models: extend, include, and Inheritance</a></p><p><br /></p>]]></content>
    
    
    <summary type="html">UML用例图中拓展(extend)和包含(include)关系的区别</summary>
    
    
    
    
    <category term="软件工程" scheme="https://wheliosc.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="UML" scheme="https://wheliosc.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>FISRT集和FOLLOW集</title>
    <link href="https://wheliosc.github.io/first-set&amp;follow-set"/>
    <id>https://wheliosc.github.io/first-set&amp;follow-set</id>
    <published>2018-11-25T12:34:34.725Z</published>
    <updated>2021-08-30T07:42:29.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="FIRST集"><a href="#FIRST集" class="headerlink" title="FIRST集"></a>FIRST集</h3><h4 id="什么是FIRST集"><a href="#什么是FIRST集" class="headerlink" title="什么是FIRST集"></a>什么是FIRST集</h4><p>FIRST($\alpha$)是从$\alpha$推导出的串的起始终结符的集合。<br>特殊情况：$\alpha\Rightarrow^{*}\varepsilon$时，规定$\varepsilon\in FIRST(\alpha)$</p><h4 id="怎么求FIRST集"><a href="#怎么求FIRST集" class="headerlink" title="怎么求FIRST集"></a>怎么求FIRST集</h4><ul><li>若X$\rightarrow$a…， 则将终结符a加入FIRST(X)中；</li><li>若X$\rightarrow\varepsilon$，则将$\varepsilon$加入FIRST(X)中；</li><li>若X$\rightarrow$Y…，且Y属于非终结符，则将FIRST(Y)$-${$\varepsilon$}加入到FIRST(X)中；</li><li>若X$\rightarrow Y_1Y_2…Y_K$,且$Y_1,Y_2,..Y_{i-1}$ (2$\leqslant$i$\leqslant$k)都是非终结符，且$Y_1,Y_2,…Y_{i-1}$ 的FIRST集合中均包含$\varepsilon$，则将FIRST($Y_j$)的所有非$\varepsilon$元素加入到FIRST(X)中，(j=1,2,…i)。特别地，若$Y_1$~$Y_K$均有$\varepsilon$产生式，则将$\varepsilon$加到FIRST(X)中。</li></ul><p><strong>FISRT集中有$\varepsilon$。</strong></p><h3 id="FOLLOW集"><a href="#FOLLOW集" class="headerlink" title="FOLLOW集"></a>FOLLOW集</h3><h4 id="什么是FOLLOW集"><a href="#什么是FOLLOW集" class="headerlink" title="什么是FOLLOW集"></a>什么是FOLLOW集</h4><p>FOLLOW($\alpha$)是在所有句型中紧跟在$\alpha$后面的终结符集合。<br>特殊情况：如果A是某个句型的最右符号$(S\Rightarrow^{*}\beta A)$，那么终结符💲属于FOLLOW(A)。</p><h4 id="怎么求FOLLOW集"><a href="#怎么求FOLLOW集" class="headerlink" title="怎么求FOLLOW集"></a>怎么求FOLLOW集</h4><ul><li>对文法的开始符号S，将$加入到FOLLOW(S)中。</li><li>若有$A\rightarrow\alpha B\beta$，则将FIRST($\beta$)$-${$\varepsilon$}加入到FOLLOW(B)中。$\alpha$可以为空串。</li><li>若$A\rightarrow\alpha B$或$A\rightarrow\alpha B\beta$，且$\beta\Rightarrow^{*}\varepsilon$，则将 FOLLOW(A)加入FOLLOW(B)中。$\alpha$可以为空串。</li></ul><p><strong>FOLLOW集中没有$\varepsilon$。</strong></p><h3 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h3><p>安利一个求FISRT集和FOLLOW集的工具：<a href="https://cyberzhg.github.io/toolbox/first_follow">Toolbox</a></p><p><br /></p>]]></content>
    
    
    <summary type="html">如何求FISRT集和FOLLOW集</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>由NFA转DFA以及DFA的化简</title>
    <link href="https://wheliosc.github.io/NFA-transform-to-MinDFA"/>
    <id>https://wheliosc.github.io/NFA-transform-to-MinDFA</id>
    <published>2018-11-25T12:34:34.721Z</published>
    <updated>2021-08-30T07:55:58.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="NFA-Non-deterministic-Finite-Automata"><a href="#NFA-Non-deterministic-Finite-Automata" class="headerlink" title="NFA(Non-deterministic Finite Automata)"></a>NFA(Non-deterministic Finite Automata)</h3><p>不确定有限自动机<br>构造NFA分成两步：画出每一个小单元的NFA；将每一个小单元的NFA组合。</p><h4 id="小单元的NFA"><a href="#小单元的NFA" class="headerlink" title="小单元的NFA"></a>小单元的NFA</h4><ul><li>单个输入符号a<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-1.png" alt="nfa 1"></li><li>连接运算ab<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-2.png" alt="nfa 2"></li><li>选择运算a|b<br>添加两个状态（选择运算开始状态和结束状态），在开始状态引两个路径通过$\varepsilon$分别到两个单输入符号的NFA，同时两个NFA都通过$\varepsilon$到结束状态。<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-3.png" alt="nfa 3"></li><li>闭包运算<br>添加两个状态（闭包运算开始状态和结束状态），四条线：闭包运算开始状态到单元开始状态；单元结束状态到闭包运算结束状态；闭包运算开始状态到闭包运算结束状态；单元结束状态到单元开始状态。<br>(a|b)<em><br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-4.jpg" alt="nfa 4"><br>(ab)</em><br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-5.png" alt="nfa 5"><br>a*<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-6.png" alt="nfa 6"></li></ul><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>在组合时，每一个小单元的NFA的开始状态不变，结束状态和下一个单元的开始状态合并。<br>(a|b)*ab<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/nfa-7.png" alt="nfa 7"></p><h3 id="NFA转DFA-Deterministic-Finite-Automata"><a href="#NFA转DFA-Deterministic-Finite-Automata" class="headerlink" title="NFA转DFA(Deterministic Finite Automata)"></a>NFA转DFA(Deterministic Finite Automata)</h3><h4 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h4><p>$\varepsilon$-$closure(\{1,2,…,n\})$：状态集{1,2,…,n}的$\varepsilon$闭包。<br>上式的含义为求1，2，…，n状态仅通过<strong>零个或多个</strong>$\varepsilon$可以到达的所有状态组成的集合。<br>$move(A,a)$：状态转换集。<br>A中的所有状态通过a可以到达的所有状态组成的集合。</p><h4 id="以-a-b-ab-为例"><a href="#以-a-b-ab-为例" class="headerlink" title="以$(a|b)*ab$为例"></a>以$(a|b)*ab$为例</h4><ul><li>标记A集合<br>A集合为开始状态（即0状态）的$\varepsilon$闭包。<br>如img-7中，0状态通过$\varepsilon$可以到达1状态，7状态；1状态通过$\varepsilon$又可以到达2状态和4状态；再加上本身：故A={0, 1, 2, 4, 7}。</li><li>找出所有的输入字母<br>如$(a|b)*ab$中，所有的输入字母为{a, b}</li><li>根据输入字母寻找A集合的$\varepsilon$闭包<br>如img-7中，A集合中遇到a能发生状态转变的只有2和7，转换到状态3和8，所以$move(A,a)$={3,8}；<br>然后求$\varepsilon$-$closure(move(A,a))$，即$\varepsilon$-$closure(\{3,8\})$，可以得到结果为{3, 8, 6, 1, 2, 4, 7}=B。<br>$move(A,b)$={5},然后求$\varepsilon$-$closure(\{5\})$={5, 6, 1, 2, 4, 7}=C。</li><li>根据输入字母寻找所有新产生的集合的$\varepsilon$闭包<br>$\varepsilon$-$closure(move(B,a))$={1,2,3,4,6,7,8}=B<br>$\varepsilon$-$closure(move(B,a))$={1,2,4,5,6,7,9}=D<br>$\varepsilon$-$closure(move(C,a))$={1,2,3,4,6,7,8}=B<br>$\varepsilon$-$closure(move(C,a))$={1,2,4,5,6,7}=C<br>$\varepsilon$-$closure(move(D,a))$={1,2,3,4,6,7,8}=B<br>$\varepsilon$-$closure(move(D,a))$={1,2,4,5,6,7}=C<br>包含NFA结束状态的集合为DFA结束状态，在例子中D状态为结束状态；A状态为开始状态。</li><li>根据以上的计算结果画出DFA<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/img-8.PNG" alt="img 8"></li></ul><h3 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h3><ul><li>加入死状态<br>如果一个DFA的转换函数不是全函数，那么<strong>必须</strong>加入一个死状态$S_d$，死状态只有输入而没有输出。例如一个状态S对a没有转换，即move(S,a)=$\varnothing$，则$\varepsilon$-$closure(move(S,a))$=$S_d$。</li><li>把状态集分为接受状态集和非接受状态集<br>接受状态集指包含NFA结束状态的集合；非接受状态集指不包含NFA结束状态的状态集。<br>例如，在例子中，可以把状态机划分为{A,B,C}和{D}。</li><li>合并不可区分状态<br>对上一个步骤中的每一个集合的进行划分。如果集合中只有一个元素，那就不必再划分，如{D}；如果集合中有多个元素，则寻找哪几个元素经过所有输入字母的转换后可以产生非本集合的元素，则将其分离成一个新的集合，如果两个状态通过所有的输入字母都转换到该集合的相同元素，那么它们不必再分。</li><li>对于上一个步骤中产生的新划分，重复上一步骤，直至不可再分。</li><li>如果结果中有死状态，则去除死状态，把所有到死状态的转换都改为无定义。</li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p><strong>其实可以把划分的过程看成是一个集合内部排异的过程。</strong><br>栗子🌰：<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/img-9.png" alt="img 9"><br>首先根据接受和非接受划分为集合{A,B,C}和{D,E,F,G,H,I}<br>对于集合{A,B,C}，A说我可以到B和C，C说我可以到B和C，B说我可以到B和D。A和C听了就不高兴了，我们两个不论怎么变都是到我们这个小集体里，你咋还跑出去了呢，我俩不和你好了。于是就分成了{A,C}和{B}。A和C又开始继续交流，但是他俩通过变换都跑到了{A,C}的外边，一起叛变，<strong>而且对于每一个输入符号，两人都是到同一个元素</strong>，只有这样，两人还是朋友，嗯，{A,C}成为一个集合。<br>对于集合{D,E,F,G,H,I}，兄弟六人怎么变都还是在这兄弟六人内部，于是六个人是一个团结的集体。<br>所以，原来的9个状态，经过划分之后，就变成了3个状态。<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/img-10.png" alt="img 10"><br>栗子🌰🌰：<br>再给一个栗子自己体会吧<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/img-11.png" alt="img 11"><br>化简之后：<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/img-12.png" alt="img 12"></p><h3 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h3><p>安利一个求NFA,DFA,Min-DFA的工具：<a href="https://cyberzhg.github.io/toolbox/">Toolbox</a></p><hr />]]></content>
    
    
    <summary type="html">由正规式如何画出NFA，并将NFA转换为最简DFA</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="词法分析" scheme="https://wheliosc.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Pyhton GUI编程之tkinter</title>
    <link href="https://wheliosc.github.io/tkinter"/>
    <id>https://wheliosc.github.io/tkinter</id>
    <published>2018-11-16T12:47:28.403Z</published>
    <updated>2021-08-30T07:57:00.490Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="tkinter控件使用图片问题"><a href="#tkinter控件使用图片问题" class="headerlink" title="tkinter控件使用图片问题"></a>tkinter控件使用图片问题</h2><p><code>_tkinter.TclError: couldn&#39;t recognize data in image file &quot;xxx&quot;</code><br>参考<a href="http://effbot.org/tkinterbook/photoimage.htm">The Tkinter PhotoImage Class</a>，PhotoImage for images in PGM, PPM, GIF and PNG formats. The latter is supported starting with Tk 8.6.想要使用其他类型的图片需要使用PIL(Python Imaging Library)处理。<br>首先安装Pillow<br><code>pip install Pillow</code><br>然后<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;you image path&quot;</span>)</span><br><span class="line">photo = ImageTk.PhotoImage(image)</span><br><span class="line">label = Label(image=photo)</span><br><span class="line">label.image = photo <span class="comment"># keep a reference!</span></span><br><span class="line">label.pack()</span><br></pre></td></tr></table></figure></p><h2 id="设置窗口标题"><a href="#设置窗口标题" class="headerlink" title="设置窗口标题"></a>设置窗口标题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.title(<span class="string">&quot;yZip 1.0.0&quot;</span>) <span class="comment"># 窗口标题</span></span><br></pre></td></tr></table></figure><h2 id="设置窗口居中显示"><a href="#设置窗口居中显示" class="headerlink" title="设置窗口居中显示"></a>设置窗口居中显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># maxsize()获得当前显示器分辨率</span></span><br><span class="line">nScreenWid, nScreenHei = root.maxsize()  </span><br><span class="line"><span class="comment"># 窗口应有大小，若使用winfo_width()则返回当前窗口大小，如果还未调用mainloop(),则返回0</span></span><br><span class="line">nCurWid = root.winfo_reqwidth()  </span><br><span class="line">nCurHeight = root.winfo_reqheight()</span><br><span class="line"><span class="comment"># &#123;&#125;x&#123;&#125;设置窗口初始大小，如果没有这个设置，窗口会随着组件大小的变化而变化;&#123;&#125;+&#123;&#125;表示窗口距离屏幕左上角的位置</span></span><br><span class="line">root.geometry(<span class="string">&quot;&#123;&#125;x&#123;&#125;+&#123;&#125;+&#123;&#125;&quot;</span>.<span class="built_in">format</span>(nCurWid, nCurHeight, </span><br><span class="line">              (nScreenWid - nCurWid)//<span class="number">2</span>, (nScreenHei - nCurHeight)//<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="设置窗口背景颜色"><a href="#设置窗口背景颜色" class="headerlink" title="设置窗口背景颜色"></a>设置窗口背景颜色</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.configure(background=<span class="string">&#x27;RoyalBlue&#x27;</span>)  <span class="comment"># 窗口背景颜色</span></span><br></pre></td></tr></table></figure><h2 id="设置窗口置顶"><a href="#设置窗口置顶" class="headerlink" title="设置窗口置顶"></a>设置窗口置顶</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.wm_attributes(<span class="string">&#x27;-topmost&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="禁止窗口最大化"><a href="#禁止窗口最大化" class="headerlink" title="禁止窗口最大化"></a>禁止窗口最大化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = Tk()</span><br><span class="line">root.resizable(<span class="literal">False</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="创建下拉菜单Combobox"><a href="#创建下拉菜单Combobox" class="headerlink" title="创建下拉菜单Combobox"></a>创建下拉菜单Combobox</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下拉选择菜单</span></span><br><span class="line">ziptype = StringVar()  <span class="comment"># 窗体自带的文本，新建一个值</span></span><br><span class="line">typeChoices = Combobox(frame2, width=<span class="number">12</span>, textvariable=ziptype)</span><br><span class="line">typeChoices[<span class="string">&#x27;values&#x27;</span>] = (<span class="string">&#x27;zip&#x27;</span>, <span class="string">&#x27;7z&#x27;</span>, <span class="string">&#x27;tar&#x27;</span>)  <span class="comment"># 设置下拉列表的值</span></span><br><span class="line">typeChoices.grid(row=<span class="number">3</span>, column=<span class="number">1</span>, sticky=NW)</span><br><span class="line">typeChoices.current(<span class="number">0</span>)  <span class="comment"># 设置下拉列表默认显示的值，0为 numberChosen[&#x27;values&#x27;] 的下标值</span></span><br></pre></td></tr></table></figure><h2 id="创建输入框Entry"><a href="#创建输入框Entry" class="headerlink" title="创建输入框Entry"></a>创建输入框Entry</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sv1 = StringVar()  <span class="comment"># 可以使用sv1.get()获得输入框的内容，当在初始化时定义了textvariable=sv1</span></span><br><span class="line"></span><br><span class="line">entryKey = Entry(frame3, width=<span class="number">20</span>, bg=<span class="string">&quot;white&quot;</span>, fg=<span class="string">&quot;black&quot;</span>,</span><br><span class="line">                 show=<span class="string">&#x27;*&#x27;</span>, state=DISABLED, textvariable=sv1,  <span class="comment"># 初始状态设为不可用</span></span><br><span class="line">                 validate=<span class="string">&quot;focusout&quot;</span>,  <span class="comment"># validate密码格式验证在该输入框失去焦点后</span></span><br><span class="line">                 invalidcommand=invalid,  <span class="comment"># 密码格式不正确即validatecommand返回False时调用invalid</span></span><br><span class="line">                 validatecommand=(self.top.register(validateKey), <span class="string">&#x27;%P&#x27;</span>))  <span class="comment"># 密码格式验证函数，这里只需验证第一个输入框即可</span></span><br><span class="line">entryKey.grid(row=<span class="number">5</span>, column=<span class="number">1</span>, padx=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="创建复选框Checkbutton"><a href="#创建复选框Checkbutton" class="headerlink" title="创建复选框Checkbutton"></a>创建复选框Checkbutton</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">check = IntVar()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testCheckButton</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;var is &quot;</span> + <span class="built_in">str</span>(check.get()))</span><br><span class="line"></span><br><span class="line">c = Checkbutton(frame2, text=<span class="string">&quot;输入密码：&quot;</span>, font=<span class="string">&quot;YaHei, 10&quot;</span>,</span><br><span class="line">                variable=check, command=testCheckButton)</span><br><span class="line">c.grid(row=<span class="number">5</span>, column=<span class="number">0</span>, sticky=NW)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">check变量具有值0或者1</span></span><br><span class="line"><span class="string">可以用check.get()获得check的值，即Checkbutton的状态（0为未勾选，1为勾选）</span></span><br><span class="line"><span class="string">当初始时设置了variable=check</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="comment"># 一般情况下的事件绑定</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;事件处理函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;handler&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = tkinter.Tk()</span><br><span class="line">    btn = tkinter.Button(text=<span class="string">u&#x27;按钮&#x27;</span>, command=handler)</span><br><span class="line">    btn.pack()</span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="comment"># handler()函数需要参数的情况下使用lambda</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;事件处理函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;handler&quot;</span>, a, b, c)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = tkinter.Tk()</span><br><span class="line">    btn = tkinter.Button(text=<span class="string">u&#x27;按钮&#x27;</span>, command=<span class="keyword">lambda</span> : handler(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>))</span><br><span class="line">    btn.pack()</span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure><h2 id="创建消息框messagebox"><a href="#创建消息框messagebox" class="headerlink" title="创建消息框messagebox"></a>创建消息框messagebox</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox </span><br><span class="line"></span><br><span class="line">tkinter.messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>, <span class="string">&#x27;明天有雨&#x27;</span>)       <span class="comment"># 提示信息</span></span><br><span class="line">tkinter.messagebox.showwarning(<span class="string">&#x27;警告&#x27;</span>,<span class="string">&#x27;木马文件&#x27;</span>)     <span class="comment"># 警告信息</span></span><br><span class="line">tkinter.messagebox.showerror(<span class="string">&#x27;错误&#x27;</span>,<span class="string">&#x27;密码不匹配&#x27;</span>)     <span class="comment"># 错误信息</span></span><br><span class="line">tkinter.messagebox.askokcancel(<span class="string">&#x27;询问&#x27;</span>,<span class="string">&#x27;继续?&#x27;</span>)           <span class="comment"># 是否继续某操作</span></span><br><span class="line">tkinter.messagebox.asktrycancel(<span class="string">&#x27;询问&#x27;</span>,<span class="string">&#x27;再次尝试?&#x27;</span>)      <span class="comment"># 是否再次尝试某操作</span></span><br><span class="line">tkinter.messagebox.askquestion(<span class="string">&#x27;问题&#x27;</span>,<span class="string">&#x27;你喜欢音乐么？&#x27;</span>)   <span class="comment"># 询问一个 是/否 问题</span></span><br><span class="line">tkinter.messagebox.askyesno(<span class="string">&#x27;问题&#x27;</span>,<span class="string">&#x27;你喜欢音乐么？&#x27;</span>)      <span class="comment"># 询问一个 是/否 问题</span></span><br></pre></td></tr></table></figure><h2 id="画布工具Canvas"><a href="#画布工具Canvas" class="headerlink" title="画布工具Canvas"></a>画布工具Canvas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">canvas = tk.Canvas(root, bg=<span class="string">&#x27;gray&#x27;</span>, height=<span class="number">200</span>, width=<span class="number">100</span>)</span><br><span class="line"> </span><br><span class="line">image_file = tk.PhotoImage(file=<span class="string">&#x27;tkinter.gif&#x27;</span>)</span><br><span class="line">image = canvas.create_image(<span class="number">10</span>, <span class="number">10</span>, anchor=<span class="string">&#x27;nw&#x27;</span>, image=image_file)</span><br><span class="line"> </span><br><span class="line">x0, y0, x1, y1 = <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">40</span></span><br><span class="line"><span class="comment"># 从坐标(20,20)到(40,40)画一条直线。</span></span><br><span class="line">line = canvas.create_line(x0, y0, x1, y1)   </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 从0度到180度画一个扇形</span></span><br><span class="line">arc = canvas.create_arc(x0+<span class="number">30</span>, y0+<span class="number">30</span>, x1+<span class="number">30</span>, y1+<span class="number">30</span>, start=<span class="number">0</span>, extent=<span class="number">180</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个矩形</span></span><br><span class="line">rect = canvas.create_rectangle(<span class="number">100</span>, <span class="number">30</span>, <span class="number">100</span>+<span class="number">20</span>, <span class="number">30</span>+<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个填充色为red的圆</span></span><br><span class="line">oval = canvas.create_oval(x0, y0, x1, y1, fill=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">canvas.pack()</span><br></pre></td></tr></table></figure><h2 id="列表Treeview"><a href="#列表Treeview" class="headerlink" title="列表Treeview"></a>列表Treeview</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">columns = (<span class="string">&quot;文件名&quot;</span>, <span class="string">&quot;文件大小&quot;</span>, <span class="string">&quot;文件夹路径&quot;</span>)</span><br><span class="line">treeview = Treeview(frame1, height=<span class="number">18</span>, show=<span class="string">&quot;headings&quot;</span>,</span><br><span class="line">                    columns=columns, yscrollcommand=scrollBar.<span class="built_in">set</span>)</span><br><span class="line"><span class="comment"># 设置每列宽度和对齐方式</span></span><br><span class="line">treeview.column(<span class="string">&quot;文件名&quot;</span>, width=<span class="number">200</span>, anchor=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">treeview.column(<span class="string">&quot;文件大小&quot;</span>, width=<span class="number">200</span>, anchor=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">treeview.column(<span class="string">&quot;文件夹路径&quot;</span>, width=<span class="number">380</span>, anchor=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置每列表头标题文本</span></span><br><span class="line">treeview.heading(<span class="string">&quot;文件名&quot;</span>, text=<span class="string">&quot;文件名&quot;</span>)</span><br><span class="line">treeview.heading(<span class="string">&quot;文件大小&quot;</span>, text=<span class="string">&quot;文件大小&quot;</span>)</span><br><span class="line">treeview.heading(<span class="string">&quot;文件夹路径&quot;</span>, text=<span class="string">&quot;文件夹路径&quot;</span>)</span><br><span class="line">treeview.pack()</span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SelectFiles</span>(<span class="params">treeview</span>):</span></span><br><span class="line">    fnames = askopenfilenames()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fnames)):</span><br><span class="line">        basename = os.path.basename(fnames[i])</span><br><span class="line">        size = os.path.getsize(fnames[i])</span><br><span class="line">        treeview.insert(<span class="string">&quot;&quot;</span>, <span class="string">&quot;end&quot;</span>, values=[basename, size, fnames[i]])</span><br><span class="line"><span class="comment"># 删除选中条目</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DeleteFilesFromTreeview</span>(<span class="params">treeview</span>):</span></span><br><span class="line">    selected_files = treeview.selection()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(selected_files)):</span><br><span class="line">        treeview.delete(selected_files[i])</span><br><span class="line"><span class="comment"># 得到所有的条目值</span></span><br><span class="line">children = treeview.get_children()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> children:</span><br><span class="line">    <span class="built_in">print</span>(treeview.item(c)[<span class="string">&quot;values&quot;</span>][<span class="number">0</span>])  <span class="comment"># 要得到第二列值则改为treeview.item(c)[&quot;values&quot;][1]</span></span><br></pre></td></tr></table></figure><h2 id="字符串类型的一串数字格式化输出"><a href="#字符串类型的一串数字格式化输出" class="headerlink" title="字符串类型的一串数字格式化输出"></a>字符串类型的一串数字格式化输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; size &lt; <span class="number">1024</span> * <span class="number">1024</span>:</span><br><span class="line">    size = <span class="string">&quot;%(size).1f&quot;</span> % &#123;<span class="string">&#x27;size&#x27;</span>: size / <span class="number">1024</span>&#125; + <span class="string">&quot;KB&quot;</span></span><br><span class="line"><span class="keyword">elif</span> size &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>:</span><br><span class="line">    size = <span class="string">&quot;%(size).2f&quot;</span> % &#123;<span class="string">&#x27;size&#x27;</span>: size / (<span class="number">1024</span> * <span class="number">1024</span>)&#125; + <span class="string">&quot;MB&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    size = <span class="string">&quot;%(size).2f&quot;</span> % &#123;<span class="string">&#x27;size&#x27;</span>: size / (<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>)&#125; + <span class="string">&quot;GB&quot;</span></span><br></pre></td></tr></table></figure><h2 id="窗口隐藏（或最小化）与显示"><a href="#窗口隐藏（或最小化）与显示" class="headerlink" title="窗口隐藏（或最小化）与显示"></a>窗口隐藏（或最小化）与显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐藏窗口</span></span><br><span class="line">mainwindow.withdraw()    </span><br><span class="line"><span class="comment"># 显示窗口</span></span><br><span class="line">mainwindow.update()</span><br><span class="line">mainwindow.deiconify()</span><br><span class="line"><span class="comment"># 最小化窗口</span></span><br><span class="line">mainwindow.iconify()</span><br><span class="line"><span class="comment"># 显示窗口</span></span><br><span class="line">mainwindow.deiconify()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://effbot.org/tkinterbook/pack.htm">effbot.org</a><br><a href="https://tkdocs.com/tutorial/tree.html">TKDocs</a></p><p><br/></p>]]></content>
    
    
    <summary type="html">使用tkinter编程时遇到的一些问题和解决方法</summary>
    
    
    
    
    <category term="Python" scheme="https://wheliosc.github.io/tags/Python/"/>
    
    <category term="tkinter" scheme="https://wheliosc.github.io/tags/tkinter/"/>
    
  </entry>
  
  <entry>
    <title>网络与信息安全复习</title>
    <link href="https://wheliosc.github.io/Review-of-Network-Information-Security"/>
    <id>https://wheliosc.github.io/Review-of-Network-Information-Security</id>
    <published>2018-11-04T14:27:37.492Z</published>
    <updated>2021-08-30T07:30:25.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p ></p><span id="more"></span><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="安全攻击分类"><a href="#安全攻击分类" class="headerlink" title="安全攻击分类"></a>安全攻击分类</h3><p>被动攻击：信息内容泄露、流量分析<br>主动攻击：伪装、重播、消息修改、拒绝服务</p><h3 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h3><p>认证：保证通信的真实性。确保通信双方的身份是可信的。<br>访问控制：防止资源非授权使用<br>数据保密性：防止传输消息受到<strong>被动攻击</strong>。<br>数据完整性：与<strong>主动攻击</strong>有关，检测而不是阻止。<br>不可否认性：防止通信方对通信行为的否认，包括源不可否认性和宿不可否认性。<br>可用性：系统或系统资源能够按照要求根据系统性能规范被授权系统的实体访问和使用。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="理论安全与实际安全"><a href="#理论安全与实际安全" class="headerlink" title="理论安全与实际安全"></a>理论安全与实际安全</h3><p>理论安全：攻击者无论截获多少密文，都无法得到足够的信息来唯一地决定明文。香农证明只有一次一密才能达到理论安全，不实用。<br>实际安全（计算安全）：在有限的资源内，攻击者都不能通过系统的分析方法来破解系统。</p><h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><h4 id="对称密码体制与非对称密码体制"><a href="#对称密码体制与非对称密码体制" class="headerlink" title="对称密码体制与非对称密码体制"></a>对称密码体制与非对称密码体制</h4><p>对称密码：加密密钥和解密密钥相同，或者一个密钥可以从另一个导出，能加密就能解密，加密能力和解密能力是结合在一起的，开放性差。<br>非对称密码：加密密钥和解密密钥不相同，从一个密钥导出另一个密钥是计算上不可行的，加密能力和解密能力是分开的，开放性好。</p><h4 id="序列密码体制和分组密码体制"><a href="#序列密码体制和分组密码体制" class="headerlink" title="序列密码体制和分组密码体制"></a>序列密码体制和分组密码体制</h4><p>序列密码：密文不仅与最初给定的算法和密钥有关，同时也与明文位置有关(是所处位置的函数)。<br>分组密码：经过加密所得到的密文仅与给定的密码算法和密钥有关，与被处理的明文数据在整个明文中的位置无关。</p><h4 id="确定型密码体制和概率型密码体制"><a href="#确定型密码体制和概率型密码体制" class="headerlink" title="确定型密码体制和概率型密码体制"></a>确定型密码体制和概率型密码体制</h4><p>确定型密码:当明文和密钥确定后，密文也就唯一地确定了。<br>概率密码：当明文和密钥确定后，密文通过客观随机因素从一个密文集合中产生，密文形式不确定。</p><h4 id="单向函数型密码体制和双向变换型密码体制"><a href="#单向函数型密码体制和双向变换型密码体制" class="headerlink" title="单向函数型密码体制和双向变换型密码体制"></a>单向函数型密码体制和双向变换型密码体制</h4><p>单向函数型密码体制：适用于不需要解密的场合，容易将明文加密成密文，如哈希函数。<br>双向变换型密码体制：可以进行可逆的加密、解密变换。</p><h3 id="现代密码学的基本原则"><a href="#现代密码学的基本原则" class="headerlink" title="现代密码学的基本原则"></a>现代密码学的基本原则</h3><p>设计加密系统时，总是假定密码算法是可以公开的，需要保密的是密钥。一个密码系统的安全性不在算法的保密，而在于密钥，即Kerckhoff原则。</p><h3 id="对加密系统的要求"><a href="#对加密系统的要求" class="headerlink" title="对加密系统的要求"></a>对加密系统的要求</h3><p>系统应该是实际安全的(practical secure)，截获密文或已知明文－密文对时，要决定密钥或任意明文在计算上是不可行的。<br>加密解密算法适用于密钥空间中的所有元素。<br>系统易于实现，使用方便。<br>系统的安全性不依赖于对加密体制或加密算法的保密，而依赖于密钥。<br>系统的使用不应使通信网络的效率过分降低。</p><h3 id="对加密信息的攻击类型"><a href="#对加密信息的攻击类型" class="headerlink" title="对加密信息的攻击类型"></a>对加密信息的攻击类型</h3><div class="table-container"><table><thead><tr><th>攻击类型</th><th>攻击者持有的信息 </th></tr></thead><tbody><tr><td> 唯密文攻击</td><td>加密算法、待解密密文</td></tr><tr><td> 已知明文攻击</td><td>加密算法 、待解密密文、与待解密密文（同一密钥加密）的明密文对</td></tr><tr><td> 选择明文攻击</td><td>加密算法 、待解密密文、攻击者选择的明文及对应的（同一密钥加密）密文</td></tr><tr><td> 选择密文攻击</td><td>加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文</td></tr><tr><td> 选择文本攻击</td><td>加密算法 、待解密密文、攻击者选择的（同一密钥加密）密文及对应的明文、攻击者选择的明文及对应的（同一密钥加密）密文</td></tr></tbody></table></div><h3 id="代换与置换"><a href="#代换与置换" class="headerlink" title="代换与置换"></a>代换与置换</h3><p>代换法是将明文字母替换成其他字母、数字或符号的加密方法。如果把明文看成是二进制序列的话，代换就是用密文位串来代换明文位串。代换法改变明文内容的表示形式，保持内容元素之间相对位置不变。由于语言的冗余性（即字母单词使用频率的统计特性），单表代换虽然密钥空间很大，但并不安全。<br>置换法是改变明文内容元素的相对位置，保持内容的表现形式不变。通过重新安排消息字母的位置来隐藏明文信息，而不是用其他字母来代换明文字母。这种方法是很容易破译的，因为密文拥有与明文一样的字母频率统计特性。</p><h3 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h3><p>隐写术不是加密技术。比如将信息通过改变像素内容隐藏到图片中，不可见的墨水等。</p><h3 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h3><p>两个限制：产生大规模随机密钥有实际困难、密钥的分配和保护无法保证</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="流密码与分组密码"><a href="#流密码与分组密码" class="headerlink" title="流密码与分组密码"></a>流密码与分组密码</h3><p>流密码：每次加密数据流的一位或一个字节。<br>分组密码：将一个明文分组作为一个整体进行加密，并且一般得到等长的密文。</p><h3 id="扩散和混淆"><a href="#扩散和混淆" class="headerlink" title="扩散和混淆"></a>扩散和混淆</h3><p>扩散：明文统计特征消散在密文中。可以通过让多个明文数字影响一个密文数字，或者每个明文数字可以影响多个密文数字。<br>混淆：使密文和加密密钥之间的统计关系尽量复杂。</p><blockquote><p>Confusion means that each binary digit (bit) of the ciphertext should depend on several parts of the key, obscuring the connections between the two.<br>Diffusion means that if we change a single bit of the plaintext, then (statistically) half of the bits in the ciphertext should change, and similarly, if we change one bit of the ciphertext, then approximately one half of the plaintext bits should change. Since a bit can have only two states, when they are all re-evaluated and changed from one seemingly random position to another, half of the bits will have changed state.<br>In Shannon’s original definitions, confusion refers to making the relationship between the ciphertext and the symmetric key as complex and involved as possible; diffusion refers to dissipating the statistical structure of plaintext over the bulk of ciphertext. This complexity is generally implemented through a well-defined and repeatable series of substitutions and permutations. Substitution refers to the replacement of certain components (usually bits) with other components, following certain rules. Permutation refers to manipulation of the order of bits according to some algorithm. To be effective, any non-uniformity of plaintext bits needs to be redistributed across much larger structures in the ciphertext, making that non-uniformity much harder to detect.</p></blockquote><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>给定整数$a, b$及$n≠0$, 当且仅当$a-b=kn$时，$a$与$b$在模$n$时同余，记为$a≡b\ mod\ n$ 或 $a≡nb$。<br>如果$n|(a-b)$, 则$a≡b\ mod\ n$。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>$(a1\ op\ a2)\ mod\ n =[(a1\ mod\ n )]\ op\ (a2\ mod\ n)]\ mod\ n$</p><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>如果一个整数与$n$互素，那么它在$Z_n$中存在一个乘法逆元。<br>对于任何一般的模数$n$，如果$a$与$n$互素，那么用乘数$a$作用到$Z_n$(即0,1,2,…,n-1)然后模$n$会得到完整的$Z_n$(元素顺序可能不同，也可以叫做$Z_n$的一个置换)。</p><div class="table-container"><table><thead><tr><th>Z8</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td> 乘以5</td><td>0</td><td>5</td><td>10</td><td>15</td><td>20</td><td>25</td><td>30</td><td>35</td></tr><tr><td> 剩余类</td><td>0</td><td>5</td><td>2</td><td>7</td><td>4</td><td>1</td><td>6</td><td>3</td></tr></tbody></table></div><h3 id="欧几里得算法与拓展欧几里得算法"><a href="#欧几里得算法与拓展欧几里得算法" class="headerlink" title="欧几里得算法与拓展欧几里得算法"></a>欧几里得算法与拓展欧几里得算法</h3><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>又称辗转相除法。欧几里德定理：$ gcd(a, b) = gcd(b , a\%b)$</p><h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>对于不完全为$0$的非负整数 $a，b，gcd（a，b$表示$a，b$的最大公约数，必然存在整数对$x，y$，使得$gcd（a，b）=ax+by$。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h3><p>因为对单重DES进行<strong>穷举攻击</strong>是可行的（密钥长度仅有56位）。<br>双重DES存在着<strong>中间相遇攻击</strong>。<br>$C = E_{K2}(E_{K1}(P))， P = D_{K1}(D_{K2}(C))$，因为$X = E_{K1}(P) = D_{K2}(C)$，用所有可能的密钥加密明文P并把结果存储起来，然后用所有可能的密钥解密密文C，寻找匹配的X值，因此复杂度只有O($2^{56}$)。攻击单重DES复杂度为O($2^{55}$)。</p><h3 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h3><h4 id="使用两个密钥的三重DES"><a href="#使用两个密钥的三重DES" class="headerlink" title="使用两个密钥的三重DES"></a>使用两个密钥的三重DES</h4><p>$C=E_{K1}[D_{K2}[E_{K1}[P]]$<br>如果$K1=K2$，那么就变成了单重DES，从而实现对单重DES的兼容。</p><h4 id="使用三个密钥的三重DES"><a href="#使用三个密钥的三重DES" class="headerlink" title="使用三个密钥的三重DES"></a>使用三个密钥的三重DES</h4><p>$C = E_{K3}[D_{K2}[E_{K1}[P]]]$<br>如果$K1=K2$或者是$K2=K3$，那么就变成了单重DES，从而实现对单重DES的兼容。</p><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><p>分组密码的安全不仅和秘钥长度有关还和分组长度有关。</p><h4 id="电子密码本模式ECB"><a href="#电子密码本模式ECB" class="headerlink" title="电子密码本模式ECB"></a>电子密码本模式ECB</h4><p>明文分成64的分组进行加密，必要时填充，每个分组用同一密钥加密，相同明文分组加密得相同密文。<br>ECB模式特别适合数据较少的情况，如安全传输DES密钥。<br>一段明文消息中若有几个相同的明文组，则密文也将出现几个相同的片段。<br>对于很长的消息，ECB是不安全的，如果消息是非常结构化的，密码分析可能利用其结构特征来破解。<br>ECB的弱点来源于其加密过的密文分组是互相独立的。<br><img src="https://wx2.sinaimg.cn/large/006xwwY9ly1g0ucsapm9ej30jh0evt9g.jpg" alt="ECB"><br>优点：操作简单，易于实现；分组独立，可以并行加密；传输错误不会传播。<br>缺点：掩盖不了明文结构信息，可以进行统计分析攻击。</p><h4 id="密文分组链接模式CBC"><a href="#密文分组链接模式CBC" class="headerlink" title="密文分组链接模式CBC"></a>密文分组链接模式CBC</h4><p>加密输入是当前明文分组和前一密文分组的异或，形成一条链，使用相同的密钥， 这样每个明文分组的加密函数输入与明文分组之间不再有固定的关系。<br>每个密文分组依赖于所有明文分组。<br>发送方和接收方需要共享初始向量Initial Value(IV)。如果IV被明文传送，则攻击者可以预先改变IV中的某些位，则接收者收到的P1也就相应改变了。因此，IV必须是一个固定的值或者使用伪随机数、计数器IV用<strong>ECB方式</strong>在消息之前加密传送。<br>在消息的最后，还要处理不够长度的分组进行填充。<br>明文消息中的任何一点变化都会影响所有的密文分组。<br><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0ucskqkd4j30jc0elq3r.jpg" alt="CBC"><br>优点：能掩盖明文结构信息，保证相同密文可得不同明文，安全性好于ECB；适合传输长度较长的报文。<br>缺点：不可并行；传递错误，即一个分组错误导致后续分组均错误；初始向量IV的选取比较复杂。</p><h4 id="密文反馈模式CFB"><a href="#密文反馈模式CFB" class="headerlink" title="密文反馈模式CFB"></a>密文反馈模式CFB</h4><p>可以视为流密码，不再要求报文被填充成整个分组，可以实时运行，如果要传输一个字符流，每个字符都可以使用面向字符的流密码加密后立即传输。<br>加密：加密函数的输入是一个64位的移位寄存器，产生初始向量IV。加密函数高端s位与明文P1的第一单元异或，产生s位密文C1进入移位寄存器低端，继续加密，与P2输入异或，如此重复直到所有明文单元都完成加密。<br>解密：采用相同方案，但是<strong>使用加密函数</strong>而非解密函数。<br>设$MSB_s(X)$表示X的最左边s位。则<br>$C1=P1 \bigoplus MSB_s[E(K,IV)]$<br>从而有$P1=C1 \bigoplus MSB_s[E(K,IV)]$<br>如果在传输过程中某一个分组的密文发生改变，则会影响到这个分组及其后的分组的明文正确性。<br><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0ucsw9ex0j30zh0sqtca.jpg" alt="CFB"><br>优点：可以实时运行，及时加密小于分组大小的数据；隐藏了明文结构。<br>缺点：不可并行；传输错误会扩散。</p><h4 id="输出反馈模式OFB"><a href="#输出反馈模式OFB" class="headerlink" title="输出反馈模式OFB"></a>输出反馈模式OFB</h4><p>结构上类似CFB，但是OFB中加密函数输出被反馈回移位寄存器，CFB中是密文单元被反馈回移位寄存器（对比两个图，可以看到反馈位置是不同的）。优点是传输中的比特差错不会传播，缺点是比CFB更容易受报文流篡改攻击。OFB的IV必须是时变值。<br>OFB的一个优点是，传输过程中在某位上发生的错误不会影响到其他位。比如，C1中有1位发生了错误，只会影响到P1的恢复，后续的明文单元不受影响。<br>OFB的缺点是，抗消息流篡改攻击的能力不如CFB。即密文中的某位取反，恢复出的明文相应位也取反。<br><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0uct77qsoj30zc0sx0w9.jpg" alt="OFB"><br>优点：可以实时运行，及时加密小于分组大小的数据；隐藏了明文结构；传输过程中在某位上发生的错误不会影响到其他位。<br>缺点：不可以并行；比CFB更容易受报文流篡改攻击。</p><h4 id="计数器模式CTR"><a href="#计数器模式CTR" class="headerlink" title="计数器模式CTR"></a>计数器模式CTR</h4><p>与OFB很像，但是加密的是计数器的值而不是任何反馈回来的值。每一个明文分组都必须使用一个不同的密钥和计数器值，决不要重复使用。<br>高效、可以做<strong>并行</strong>加密<br>对高速链路的突发数据加密尤其有效<br>可以对被加密的分组进行随机存取<br>安全、简洁<br>不需要填充<br><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0uctmuyz9j30zh0qmmz1.jpg" alt="CTR"></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h3><p>若$p$是素数, $a$是正整数且不能被$p$整除, 则$a^{p-1}\ mod\ p=1$<br>证明：<br>$对于X=\{ a\ mod\ p,2a\ mod\ p,…, (p-1)a\ mod\ p\}$<br>$\because a是正整数且不能被p整除$<br>$\therefore X内的元素均大于零$<br>$假设ja≡ka(modp)，其中1\leqslant j&lt;k\leqslant p-1$<br>$\because a与p互素$<br>$\therefore 两边可以把a消去，则推出j ≡ k(mod p)，与假设矛盾$<br>$也就是说，X内的元素均为正整数且互不相等$<br>$\because \{ a\ mod\ p, 2a\ mod\ p, …, (p-1)a\ mod\ p\} 是\{ 1, 2, …, (p-1)\} 的置换形$<br>$\therefore (aｘ2aｘ … ｘ (p-1)a)≡(1ｘ2ｘ … ｘ(p-1))\ (mod\ p)≡ (p-1)!\ (mod\ p)$<br>$\because aｘ2aｘ…ｘ(p-1)a=(p-1)!a^{p-1}，即 (p-1)!a^{p-1}≡(p-1)!\ (mod\ p)$<br>$两边去掉(p-1)!，即得 a^{p-1}\mod\ p = 1$</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>$\varphi (n)$是比n小且与n互素的正整数的个数，定义$\varphi (1)=1$。<br><img src="https://wx1.sinaimg.cn/large/006xwwY9ly1g0ucu7v7vpj30fl0a3my4.jpg" alt="欧拉函数"></p><h4 id="欧拉函数定理"><a href="#欧拉函数定理" class="headerlink" title="欧拉函数定理"></a>欧拉函数定理</h4><p>$p和q是素数, n=p\times q, \varphi (n)= \varphi (p)\varphi (q)=(p-1)(q-1)$<br>证明：<br>$考虑余数集合\{ 0, 1, …, (pq-1)\} 中不与n互素的余数集合是\{ p, 2p, …, (q-1)p\} , \{ q, 2q, …, (p-1)q\}, $<br>$所以\varphi (n)= (pq-1)-[(q-1)+(p-1)]=pq-(p+q)+1= (p-1)(q-1)=\varphi (p)\varphi (q)$</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>对任意互素的$a$与$n$，$a^{\varphi (n)} \equiv 1\ (mod\ n)$<br>证明：<br>$若n为素数，则根据\varphi (n)=n-1和a^{p-1}\ mod\ p=1可知成立。但这是不完全的证明。$<br>$考虑集合R=${$x_1,x_2,…,x_{\varphi (n)}$},$每一个元素都有gcd(x_i,n)=1。$<br>$令S=\{ (ax_1\ mod\ n),(ax_2\ mod\ n),…,(ax_{\varphi (n)}\ mod\ n)\}$<br>$S是R的一个置换，因为$<br>$(1) a与n互素，且x_i与n互素，所以ax_i必与n互素，这样S中所有元素均小于n且与n互素。$<br>$(2) S中没有重复元素，因为如果ax_i\equiv ax_j(modn)，则x_i=x_j，显然不成立。$<br>$\prod_{i=1}^{\varphi (n)}(ax_imodn)=\prod_{i=1}^{\varphi (n)}x_i$<br>$\prod_{i=1}^{\varphi (n)}ax_i\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$<br>$a^{\varphi (n)}\times [\prod_{i=1}^{\varphi (n)}x_i]\equiv \prod_{i=1}^{\varphi (n)}x_i(modn)$<br>$两边同时消去，得到a^{\varphi (n)} \equiv 1(modn)$</p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>中国余数定理CRT说明某一范围内的整数可通过它对两两互素的整数取模所得的余数来重构。<br>例如：$Z_{10}(0,1,…,9)$中的10个整数可通过它们对2和5(10的素因子)取模所得的两个余数来重构. 假设数$x$的余数$r_2=0$ 且$r_5=3$, 即$x\ mod\ 2=0$, $x\ mod\ 5=3$, 则$x$是$Z_{10}$中的偶数且被5除余3, 唯一解$x=8$。</p><h4 id="一种CRT的表示形式"><a href="#一种CRT的表示形式" class="headerlink" title="一种CRT的表示形式"></a>一种CRT的表示形式</h4><p>$令M=\prod_{i=1}^{k}m_i,  其中m_i两两互素, 1\leqslant i, j\leqslant k, i≠j, gcd(m_i, m_j)=1。将Z_M中的任一整数对应一个k元组,$<br>$该k元组的元素均在Z_{m_i}中, 对应关系为A\leftrightarrow (a_1,a_2,…,a_k), 其中A∈Z_M,  对1\leqslant i\leqslant k, a_i∈Z_{m_i},$<br>$且a_i = A\ mod\ m_i。$</p><h4 id="计算例子"><a href="#计算例子" class="headerlink" title="计算例子"></a>计算例子</h4><p>今有物不知其数, 三三数之剩二, 五五数之剩三, 七七数之剩二, 问物几何。<br>(1) 计算$n=3\times 5\times 7$，记$d_1=3,d_2=5,d_3=7$; $r_1=2,r_2=3,r_3=2$<br>(2) 根据$(\frac{n}{d_i})y_i\ mod\ d_i=1$，计算$y_i$<br>$(\frac{105}{3})y_i\ mod\ 3=1 $，得$y_1=2$<br>$(\frac{105}{5})y_i\ mod\ 5=1 $，得$y_2=1$<br>$(\frac{105}{7})y_i\ mod\ 7=1 $，得$y_3=1$<br>(3) $x=[\prod (\frac{n}{d_i})y_ir_i]\ mod\ n$<br>$x=(35\times 2\times 2+21\times 1\times 3+15\times 1\times 2)\ mod\ 105=23$</p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="对称密码与非对称密码"><a href="#对称密码与非对称密码" class="headerlink" title="对称密码与非对称密码"></a>对称密码与非对称密码</h3><h4 id="对称密码体制的问题"><a href="#对称密码体制的问题" class="headerlink" title="对称密码体制的问题"></a>对称密码体制的问题</h4><p>加密能力与解密能力是捆绑在一起的。<br>密钥更换、传递和交换需要可靠信道，密钥分发困难。<br>如有N用户，则需要$C=\frac {N\times (N-1)}{2}$个密钥，n=1000时，C(1000, 2)≈500000, 密钥管理困难。<br>无法满足不相识的人之间通信的保密要求。<br>不能实现数字签名。</p><h4 id="非对称密码体制的基本特点"><a href="#非对称密码体制的基本特点" class="headerlink" title="非对称密码体制的基本特点"></a>非对称密码体制的基本特点</h4><p>加密能力与解密能力是分开的。<br>密钥分发简单。<br>需要保存的密钥量大大减少，N个用户只需要N个密钥。<br>可满足不相识的人之间保密通信。<br>可以实现数字签名。</p><h3 id="公钥密码体制的应用"><a href="#公钥密码体制的应用" class="headerlink" title="公钥密码体制的应用"></a>公钥密码体制的应用</h3><p>加密/解密：发送方用接收方的公钥对消息加密。<br>数字签名：发送方用其私钥对消息签名，可以对整体消息签名或对消息的摘要签名。<br>密钥交换：通信双方交换会话密钥。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>随机选择两个秘密大素数$p$和$q$<br>计算公开模数$n=p\times q$<br>计算秘密的欧拉指数函数$\varphi (n)=(p-1)(q-1)$<br>选择一个与$\varphi (n)$互素的数，作为$e$或$d$<br>用<em>Euclid</em>算法计算模$\varphi (n)$的乘法逆元素，即根据$ed\ mod\ φ(n)=1$, 求$d$或$e$<br>加密：$C=M^e\ mod\ n$<br>解密：$M=C^d\ mod\ n = (M^e\ mod\ n)^d\ mod\ n=M^{ed}\ mod\ n=M$<br>公钥：$PU=\{ e,n\}$ 私钥：$PR=\{ d,n\}$</p><h4 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h4><p>有可能找到e, d, n的值, 使得对所有$M&lt;n$有$M^{ed}\ mod\ n = M$。<br>对于所有$M&lt;n$的值, 要计算$M^e$和$C^d$是相对容易的。<br>在给定e和n时, 计算d是不可行的。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>已知：$ed\ mod\  \varphi (n)=1，M&lt;n，p和q是素数$<br>求证：$M^{ed}\ mod\ n=M$<br><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0ucvgl84lj313q0yhjxj.jpg" alt="RSA"></p><h4 id="可能的攻击方式"><a href="#可能的攻击方式" class="headerlink" title="可能的攻击方式"></a>可能的攻击方式</h4><p>穷举攻击：尝试所有可能的密钥<br>数学攻击：对两个素数乘积的因子分解(FAC问题)<br>计时攻击：依赖于解密算法的运行时间<br>RSA的安全性问题依赖于大合数的素因子分解。</p><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="几种公钥分配方法"><a href="#几种公钥分配方法" class="headerlink" title="几种公钥分配方法"></a>几种公钥分配方法</h3><p>公开发布、公开可访问的目录、公钥授权、公钥证书</p><h4 id="公开发布"><a href="#公开发布" class="headerlink" title="公开发布"></a>公开发布</h4><p><img src="https://wx1.sinaimg.cn/large/006xwwY9ly1g0ucwf65iuj30m50c53yn.jpg" alt=""></p><h4 id="公开可访问的目录"><a href="#公开可访问的目录" class="headerlink" title="公开可访问的目录"></a>公开可访问的目录</h4><p><img src="https://wx3.sinaimg.cn/large/006xwwY9ly1g0ucwrkfxaj30kq0d5t9o.jpg" alt=""><br>一个可信实体或组织负责这个公开目录的维护和分配。</p><ul><li>目录包含{name, public-key}等项。</li><li>每一通信方通过目录管理员以安全的方式注册一个公钥。</li><li>通信方在任何时刻可以用新的密钥替代当前的密钥。</li></ul><p>目录定期更新。<br>目录可通过电子方式访问。<br>安全问题：一旦攻击者获得目录管理员私钥，则可传递伪造的公钥，可以假冒任何通信方以窃取消息，或者修改已有的记录。</p><h4 id="公钥授权"><a href="#公钥授权" class="headerlink" title="公钥授权"></a>公钥授权</h4><p><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0ucx46rkmj30k60f8gnz.jpg" alt=""><br>(1) A发送带有时间戳的消息给公钥管理员, 请求B的当前公钥。<br>(2) 管理员给A发送用其私钥$KR_{auth}$加密的消息, A用管理员的公钥解密，可以确信该消息来自管理员。</p><p><font color="red" ><br>B的公钥$KU_b$，用来加密；<br>原始请求$Request$，A可以验证其请求未被修改；<br>原始时间戳$Time_1$, A可以确定收到的不是来自管理员的旧消息。</font><br>(3) A保存B的公钥, 并用它对包含A的标识$ID_A$和$N_1$的消息加密, 然后发送给B。<br>(45) B以同样方式从管理员处得到A的公钥。<br>(6) B用$KUa$对A的$N_1$和B的$N_2$加密, 发送给A。<br>(7) A用B的公钥对$N_2$加密并发送给B, 使B相信其通信伙伴是A。</p><h4 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h4><p><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0ucxidxihj30kz0eqac4.jpg" alt=""><br>有了公钥证书使得不通过实时访问公钥授权部门而实现公钥交换成为可能。<br>公钥证书将一个通信方的身份与他的公开密钥绑定在一起，通常还包括有效期和使用方法等。<br>证书的所有内容必须经由可信公钥授权方或者证书授权方签名后方可生效。<br>知道公钥授权当局公开密钥的任何人都可以验证一个用户的公开密钥证书的有效性。</p><p>对于申请者A，管理员提供的证书为：<br>$C_A = E_{KR_{auth}} [Time_1, ID_A, KU_a]$<br>其他人读取并验证：<br>$D_{KU_{auth}}[C_A]=D_{KU_{auth}} [E_{KR_{auth}} [Time_1, ID_A, KU_a]]=(Time_1, ID_A, KU_a)$</p><h3 id="公钥密码分配传统密码体制密码"><a href="#公钥密码分配传统密码体制密码" class="headerlink" title="公钥密码分配传统密码体制密码"></a>公钥密码分配传统密码体制密码</h3><p>公钥密码算法速度较慢，因此更适合作为传统密码中实现秘密密钥分配的一种手段。<br>下图是一个利用公钥密码体制分配（传输）对称式密码（会话密钥$K_s$）的例子：<br><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0ucy1xa1xj30nb0bodhn.jpg" alt="传统密钥分配"><br>(1) A用$KU_b$加密消息$N_1$和$ID_A$发送给B。<br>(2) 只有B拥有B的私钥，即$N_1$只有B可见，B产生随机值$N_2$，和$N_1$一起加密后发送给A，A看到$N_1$后即可确定消息是B发来的。<br>(3) 同理，$N_2$只有A可见，B可以确定消息是A发来的。<br>(4) A产生本次会话的密钥，先用自己的私钥加密再用B的公钥加密发送给B。<br>上述过程中存在的安全问题：消息(4)可以进行重放攻击。在下次会话时上次的会话密钥可能已经泄露，攻击者可以重放上次的消息(4)进行攻击。解决方案是将消息(3)和消息(4)合并发送，即(3)$E_{KU_b}[N_2 || E_{KR_a}[K_s]]$。</p><h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换算法是一种公钥分发机制。它不是用来加密消息的，所生成的是通信双方共享的会话密钥，必须保密，其值取决于通信双方的私钥和公钥信息。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>通信双方约定一个大素数(或多项式)p, 和模p的一个素根α（p与α是公开的）<br>双方分别选择一个秘密钥(整数值)，如$x_A&lt; p， x_B&lt; p$<br>计算公钥, 如$y_A = α^{x_A}\ mod\ p, y_B = α^{x_B}\ mod\ p$, 并相互交换<br>双方共享的会话密钥$K_{AB}$可以如下算出<br>$K_{AB} = α^{x_Ax_B}\ mod\ p= y_A^{x_B}\ mod\ p  (which\ B\ can\ compute) = y_B^{x_A}\ mod\ p  (which\ A\ can\ compute) $<br>$K_{AB}$是双方用对称密码通信时共享的密钥<br>如果双方继续通信，可以继续使用这个密钥，除非他们要选择新的密钥</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>攻击者如果想要获得x, 则必须解决DLP(离散对数)问题。$X_B=dlog_{α,p}Y_B$，即求$Y_B$的以$α$为底的模$p$的离散对数。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p><img src="https://wx1.sinaimg.cn/large/006xwwY9ly1g0ucz1kprij30k00ba41n.jpg" alt=""><br><img src="https://wx4.sinaimg.cn/large/006xwwY9ly1g0uczpwbdfj30e20azdh0.jpg" alt=""></p><h3 id="ELGamal概率密码系统"><a href="#ELGamal概率密码系统" class="headerlink" title="ELGamal概率密码系统"></a>ELGamal概率密码系统</h3><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>假设A和B互相通信，共享大素数$p$，本原元素$α，1≤m≤p-1$<br>加密：<br>A选择$k∈[1, p-1]$, $k$的作用其实即为$x_A$, A访问公共区域找到B的公开密钥$Y_B = α^{x_B}\ mod\ p$, 计算：$K = (Y_B)^k\ mod\ p, 即K = α^{x_Bk}\ mod\ p$<br>$c1 = α^k\ mod\ p$<br>$c2 = mK\ mod\ p$<br>密文即为 $(c1, c2)$<br>解密：<br>B首先恢复K：K $= c1^{x_B}\ mod\ p = α^{kx_B}\ mod\ p$<br>然后恢复m：m $=c2K^{-1}\ mod\ p$。这里的$K^{-1}$指$KK^{-1}\ mod\ p=1$</p><h4 id="效率及安全性"><a href="#效率及安全性" class="headerlink" title="效率及安全性"></a>效率及安全性</h4><p>ElGamal密码体制加密效率是50%，因为密文大小是明文的两倍。<br>ElGamal密码体制是概率密码体制，同样的明文每次加密得到不同的密文, 因为每次随机选择k。<br>ElGamal密码体制的破译难度同Diffie-Hellman的方法,即基于DLP，离散对数问题，最快的算法需要T=exp((ln(p)lnln(p)1/2)次运算。</p><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h3><p>消息认证就是验证接受的消息确实来自真正的发送方，且是未经修改过的消息，并且可以认证消息的顺序和及时性。</p><h3 id="消息认证函数"><a href="#消息认证函数" class="headerlink" title="消息认证函数"></a>消息认证函数</h3><h4 id="消息加密"><a href="#消息加密" class="headerlink" title="消息加密"></a>消息加密</h4><p>消息加密本身提供了一种认证手段。</p><p><strong>对称加密</strong><br><img src="https://wx1.sinaimg.cn/large/006xwwY9ly1g0ud00sqdoj30fw04nwei.jpg" alt=""></p><ul><li>保密性：如果除了源和宿没有其他人知道密码，那么就保证了保密性。</li><li>认证：宿可以确信消息是由源产生的，因为除了宿以外只有源拥有加密密钥，产生出用此密钥可以解密的密文。因此宿如果可以恢复出明文，则可以认为每一位都没有被修改过，建立在明文具有可读性的基础上。</li></ul><p>如果消息可以是任意的位模式，接收方无法确定收到的消息是合法明文的密文（不具有可读性）。因此要求明文具有某种易于识别的结构，如在加密前对每个消息附加一个帧校验序列FCS。<br><img src="https://ws2.sinaimg.cn/large/006xwwY9ly1g0ud0wjp0jj30kd0axq42.jpg" alt="fcs"><br>FCS和加密函数E执行的顺序很重要。图中(a)为内部错误控制，攻击者很难产生密文使得控制码仍为正确，所以可以提供认证。图中(b)为外部错误控制，攻击者可以构造出具有正确控制码的消息，虽然不知道解密后的消息是什么，但是可以混淆破坏通信。<br><strong>公钥加密</strong><br><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0ud1ztv4ij30fw0dpjru.jpg" alt=""><br>(b) 保密性：只有接受方具有私钥可以解密消息，因此具有保密性；但公钥是公开的，任何人都可以假冒发送方给接收方发送消息，不能保证消息的真实性，因此没有认证。<br>(c) 认证和签名：接收方接收到密文并可以解密出明文（如果明文是具有某种结构的，即具有可读性以区分真实的明文和随机串）就可以确定发送方是真实的。只有发送方有自己的私钥，加密后就相当于是一个签名。<br>(d) 保密性、认证和签名：发送方先用自己的私钥加密以作为签名，再用接收方的公钥加密实现保密性，同时明文具有某种结构的情况下实现了认证。缺点是一次通信执行四次公钥算法（两次加密两次解密）。</p><h4 id="消息认证码MAC"><a href="#消息认证码MAC" class="headerlink" title="消息认证码MAC"></a>消息认证码MAC</h4><p>利用密钥产生一个固定长度的短数据块。假如通信双方共享密钥K，则MAC=C(K,M)。如果接收方通过密钥和消息计算的MAC与收到的一致，那么可以确信(1)消息未被修改过(2)消息来自真正的发送方(3)如果消息中含有序列号，那么可以确定消息顺序是正确的。<br>因为MAC是定长的，而消息数远大于MAC的取值范围，因此MAC是一个多对一的函数。<br>因为K是通信双方所共有的，所以MAC不是数字签名。同时MAC不需要解密，因此不需要具有可逆性，使得MAC比加密更加难以破解。<br><img src="https://wx3.sinaimg.cn/large/006xwwY9ly1g0ud2fimhhj30og0hsju6.jpg" alt=""><br>(a) 消息认证：整个消息以明文发送，没有保密性，但有消息认证。<br>(b) 与明文捆绑的消息认证和保密性：对明文做MAC然后与明文一起加密。<br>(c) 与密文捆绑的消息认证和保密性：对明文加密，然后对密文做MAC，与密文一起发送。<br><strong>MAC函数应具有满足以下需求：</strong></p><ol><li>若攻击者已知$M$和$C(K,M)$，则构造满足$C(K,M’)=C(K,M)$的消息$M’$在计算上是不可行的</li><li>$C(K,M)$应该是均匀分布的，即对任何随机选择的消息$M$和$M’$，$C(K,M’)=C(K,M)$的概率是$2^{-n}$，其中n是MAC的位数</li><li>设M’是M的某个已知的变换，即M’=f(M)，如f可能表示逆转M的一位或多位，那么$C(K,M)=C(K,M’)$的概率是$2^{-n}$</li></ol><h4 id="散列函数HASH"><a href="#散列函数HASH" class="headerlink" title="散列函数HASH"></a>散列函数HASH</h4><p>一个散列函数以变长的报文M作为输入，产生定长的散列码H(M)作为输出，亦称作报文摘要。 散列码是报文所有比特的函数值，具有差错检测能力，报文任意一比特的改变都将引起散列码的改变。<br><strong>Hash函数的安全性需求</strong></p><div class="table-container"><table><thead><tr><th>需求</th><th>描述 </th></tr></thead><tbody><tr><td> 输入长度可变</td><td>H可以应用于任意大小的数据块 </td></tr><tr><td> 输出长度固定</td><td>H产生固定长度的输出 </td></tr><tr><td> 效率</td><td>对任意给定的明文x，计算H(x)容易，可由硬件或软件实现 </td></tr><tr><td> 抗原像攻击（单向性）</td><td>对任意给定的散列码h，找到满足H(x)=h的x，在计算上不可行</td></tr><tr><td> 抗第二原像攻击（抗弱碰撞性）</td><td>对任何给定的分组x，找到满足y≠x且H(x)=H(y)的y，在计算上不可行</td></tr><tr><td> 抗强碰撞性</td><td>找到任何满足H(x)=H(y)的偶对(x, y)，在计算上不可行</td></tr><tr><td> 伪随机性</td><td>H的输出满足伪随机性测试标准</td></tr></tbody></table></div><p>满足前五条的称为弱哈希函数，如果第六条也满足则称为强哈希函数。<br>应用在数字签名上的Hash函数必须是强哈希函数。<br><strong>三个安全特性之间的关系</strong><br>抗强碰撞那么一定抗弱碰撞，反之不成立。<br>抗强碰撞不一定抗原像，反之亦然。<br>抗弱碰撞不一定抗原像，反之亦然。<br>抗强碰撞可以看作是在人群中寻找两个名字相同的人，抗弱碰撞性可以看作是给定一个名字，然后在人群中找一个和这个名字相同的人。</p><h4 id="Hash函数提供的消息认证方式"><a href="#Hash函数提供的消息认证方式" class="headerlink" title="Hash函数提供的消息认证方式"></a>Hash函数提供的消息认证方式</h4><p><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0ud36ynofj30mb0ilq6n.jpg" alt=""><br>(a) 使用对称密码加密消息和Hash码。对称式密钥保证了保密性，并且可以确定发送方的真实性；Hash码提供了消息认证的功能。<br>(b) 使用对称式密码仅加密Hash码。对于无需保密性的应用，减少了加解密的负担。实现了消息认证。<br>(c) 不使用加密算法，双方共享秘密值s，并且s不在信道上传输，仅实现了消息认证。<br>(d) 在(c)的基础上提供保密性。</p><h4 id="Hash函数提供的数字签名方式"><a href="#Hash函数提供的数字签名方式" class="headerlink" title="Hash函数提供的数字签名方式"></a>Hash函数提供的数字签名方式</h4><p><img src="https://wx2.sinaimg.cn/large/006xwwY9ly1g0ud36ynofj30mb0ilq6n.jpg" alt="数字签名"><br>(a) 使用发送方的私钥，仅对Hash码进行加密。实现了消息认证和数字签名。<br>(b) 在(a)的基础上使用对称式密码加密，同时实现保密性。</p><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><h3 id="数字签名概述"><a href="#数字签名概述" class="headerlink" title="数字签名概述"></a>数字签名概述</h3><h4 id="数字签名实现方法"><a href="#数字签名实现方法" class="headerlink" title="数字签名实现方法"></a>数字签名实现方法</h4><p>数字签名是一种<strong>认证</strong>机制，它使得消息的产生者可以添加一个起签名作用的码字。通过<strong>计算消息的散列值并用产生者的私钥加密</strong>散列值来生成签名。签名保证了消息的来源和完整性。<br>数字签名标准(DSS)是NIST标准，它使用安全散列算法(SHA)。</p><h4 id="数字签名的要求"><a href="#数字签名的要求" class="headerlink" title="数字签名的要求"></a>数字签名的要求</h4><p>在收发双方不能完全信任的情况下，需要除认证之外的其他方法来解决假冒和否认的问题，数字签名则是解决办法；<br>签名接收者能容易地验证签字者对消息所做的数字签名，包括日期和时间；<br>任何人，包括签名接收者，都不能伪造签名者的签字；<br>发生争议时，可由第三方解决。</p><h4 id="数字签名与消息认证的区别"><a href="#数字签名与消息认证的区别" class="headerlink" title="数字签名与消息认证的区别"></a>数字签名与消息认证的区别</h4><p>消息认证使收方能验证消息发送者及所发消息内容是否被窜改过。当收发者之间没有利害冲突时，这对于防止第三者的破坏来说是足够了。但当收者和发者之间有利害冲突时，就无法解决他们之间的纠纷，此时须借助满足前述要求的数字签名技术。</p><h3 id="直接数字签名"><a href="#直接数字签名" class="headerlink" title="直接数字签名"></a>直接数字签名</h3><p>用共享的密钥（对称密钥）对明文及签名一起加密。注意先进行签名，然后执行外层的加密，这样在发生争执时，第三方可以查看消息及其签名。若先加密再签名，则第三方必须知道解密密钥才能查看消息。先签名再加密，接收方可以保留消息及其签名留作争执时使用。<br>直接数字签名的有效性依赖于发送方私钥的安全性。发送方如果想要否认一条消息，他可以声称自己的私钥丢失或被盗用。可以使用加入时间戳的方式减少这种威胁。另一种威胁是，攻击者在T时刻盗用了发送方的私钥，并发送了一条签名的消息加盖T时刻之前的时间戳。解决上述问题的方法是使用数字证书的证书管理中心。</p><h3 id="ELGamal数字签名方案"><a href="#ELGamal数字签名方案" class="headerlink" title="ELGamal数字签名方案"></a>ELGamal数字签名方案</h3><p>首先，基本元素是素数p和原根α<br>A用户生成随机整数$X_A\in (1,p-1)$，计算$Y_A=α^{X_A}\ mod\ p$<br>计算消息的Hash码，m=H(M)<br><strong>产生签名</strong><br>选择整数$K\in [1,p-1]$，并且K与p-1互素<br>计算$S_1 = \alpha ^K\ mod\ p$<br>计算K模p-1的逆，即$K^{-1}\ mod\ (p-1)$<br>计算$S_2=K^{-1}(m-X_AS_1)\ mod\ (p-1)$<br>签名即为$(S_1,S_2)$<br><strong>验证签名</strong><br>计算$V_1=\alpha ^m\ mod\ p$<br>计算$V_2=(Y_A)^{S_1}(S_1)^{S_2}\ mod\ p$<br>如果$V_1=V_2$，那么签名合法。</p><hr />]]></content>
    
    
    <summary type="html">网络与信息安全复习笔记</summary>
    
    
    
    
    <category term="网络信息安全" scheme="https://wheliosc.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>【Python learning】词法结构</title>
    <link href="https://wheliosc.github.io/Pyhton-Lexical-Structure"/>
    <id>https://wheliosc.github.io/Pyhton-Lexical-Structure</id>
    <published>2018-10-17T07:05:28.324Z</published>
    <updated>2021-08-30T07:28:40.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>通常，Python的源代码必须完全由ASCII码组成。若想在程序中的注释和字符串常量中使用非ASCII字符，需在源代码的第一行添加注释<code># -*- coding: &lt;encoding-name&gt; -*-</code></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>通常Python的风格是类名称以大写字母开始，其他的标识符都是小写字母。以单个下划线开始的标识符是私有的，以两个下划线开始的标识符是非常强的私有标识符；如果标识符还以两个下划线结尾，则表示该标志符是Python语言定义的特殊名称。</p><h3 id="关键字-3-7-1版本"><a href="#关键字-3-7-1版本" class="headerlink" title="关键字(3.7.1版本)"></a>关键字(3.7.1版本)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">False      await      else       import     pass</span><br><span class="line">None       break      except     in         raise</span><br><span class="line">True       class      finally    is         return</span><br><span class="line">and        continue   for        lambda     try</span><br><span class="line">as         def        from       nonlocal   while</span><br><span class="line">assert     del        global     not        with</span><br><span class="line">async      elif       if         or         yield</span><br></pre></td></tr></table></figure><h3 id="逻辑行与物理行"><a href="#逻辑行与物理行" class="headerlink" title="逻辑行与物理行"></a>逻辑行与物理行</h3><p>逻辑行由一个或多个物理行组成。</p><ul><li>当某一物理行以backslash(\)结束，并且后面没有注释，就会连接到下一个物理行作为一个逻辑行。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1900</span> &lt; year &lt; <span class="number">2100</span> <span class="keyword">and</span> <span class="number">1</span> &lt;= month &lt;= <span class="number">12</span> \</span><br><span class="line">        <span class="keyword">and</span> <span class="number">1</span> &lt;= day &lt;= <span class="number">31</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= hour &lt; <span class="number">24</span> \</span><br><span class="line">        <span class="keyword">and</span> <span class="number">0</span> &lt;= minute &lt; <span class="number">60</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= second &lt; <span class="number">60</span>:  <span class="comment"># Looks like a valid date</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a valid date.&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>如果一个左边的圆括号、方括号、花括号还没有对应的右括号，则Python会自动把多个物理行连接成一个逻辑行。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">month_names = [<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>,      <span class="comment"># These are the</span></span><br><span class="line">               <span class="string">&#x27;April&#x27;</span>,   <span class="string">&#x27;May&#x27;</span>,      <span class="string">&#x27;June&#x27;</span>,       <span class="comment"># Dutch names</span></span><br><span class="line">               <span class="string">&#x27;July&#x27;</span>,    <span class="string">&#x27;August&#x27;</span>, <span class="string">&#x27;September&#x27;</span>,  <span class="comment"># for the months</span></span><br><span class="line">               <span class="string">&#x27;October&#x27;</span>, <span class="string">&#x27;November&#x27;</span>, <span class="string">&#x27;December&#x27;</span>]   <span class="comment"># of the year</span></span><br></pre></td></tr></table></figure><p><br/></p>]]></content>
    
    
    <summary type="html">主要学习Python词法结构</summary>
    
    
    
    
    <category term="Python" scheme="https://wheliosc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>僕が死のうと思ったのは</title>
    <link href="https://wheliosc.github.io/posts/55212/"/>
    <id>https://wheliosc.github.io/posts/55212/</id>
    <published>2018-10-12T13:04:24.154Z</published>
    <updated>2019-06-21T04:21:24.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://pg60us30v.bkt.clouddn.com//vedio/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp4","pic":"http://pg60us30v.bkt.clouddn.com//image/image-video/%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    
    <summary type="html">一味考虑着死的事 一定是因为太过认真地活</summary>
    
    
    
    
    <category term="music" scheme="https://wheliosc.github.io/tags/music/"/>
    
    <category term="video" scheme="https://wheliosc.github.io/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记】全系列内容提要篇</title>
    <link href="https://wheliosc.github.io/java-learning-content"/>
    <id>https://wheliosc.github.io/java-learning-content</id>
    <published>2018-10-06T13:58:03.611Z</published>
    <updated>2021-08-30T07:27:11.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h2 id="【java学习笔记1】"><a href="#【java学习笔记1】" class="headerlink" title="【java学习笔记1】"></a>【java学习笔记1】</h2><p>基本数据类型<br>对象和类<br>数据声明<br>函数声明<br>参数传递 </p><h2 id="【java学习笔记2】"><a href="#【java学习笔记2】" class="headerlink" title="【java学习笔记2】"></a>【java学习笔记2】</h2><p>数组<br>运算符<br>包<br>访问权限<br>修饰符</p><h2 id="【java学习笔记3】"><a href="#【java学习笔记3】" class="headerlink" title="【java学习笔记3】"></a>【java学习笔记3】</h2><p>继承<br>多态</p><h2 id="【java学习笔记4】"><a href="#【java学习笔记4】" class="headerlink" title="【java学习笔记4】"></a>【java学习笔记4】</h2><p>异常处理</p><h2 id="【java学习笔记5】"><a href="#【java学习笔记5】" class="headerlink" title="【java学习笔记5】"></a>【java学习笔记5】</h2><p>抽象类、抽象函数<br>接口</p><h2 id="【java学习笔记6】"><a href="#【java学习笔记6】" class="headerlink" title="【java学习笔记6】"></a>【java学习笔记6】</h2><p>Object类<br>Class类<br>String类<br>System类<br>包装类</p><h2 id="【java学习笔记7】"><a href="#【java学习笔记7】" class="headerlink" title="【java学习笔记7】"></a>【java学习笔记7】</h2><p>泛型</p><h2 id="【java学习笔记8】"><a href="#【java学习笔记8】" class="headerlink" title="【java学习笔记8】"></a>【java学习笔记8】</h2><p>集合类，集合接口<br>Collection类<br>List LinkedList ArrayList<br>Map HashMap TreeMap<br>Set HashSet TreeSet</p><h2 id="【java学习笔记9】"><a href="#【java学习笔记9】" class="headerlink" title="【java学习笔记9】"></a>【java学习笔记9】</h2><p>File<br>RandomAccessFile<br>文本流<br>Preoperties  // 配置文件的使用<br>多线程</p><h2 id="【java学习笔记10】"><a href="#【java学习笔记10】" class="headerlink" title="【java学习笔记10】"></a>【java学习笔记10】</h2><p>线程同步、锁</p><h2 id="【java学习笔记11】"><a href="#【java学习笔记11】" class="headerlink" title="【java学习笔记11】"></a>【java学习笔记11】</h2><p>网络编程</p><h2 id="【java学习笔记12】"><a href="#【java学习笔记12】" class="headerlink" title="【java学习笔记12】"></a>【java学习笔记12】</h2><p>数据库编程</p><p><br/></p>]]></content>
    
    
    <summary type="html">这是【java学习笔记】这个系列的一个内容提要，相当于是一个目录吧，方便更快找到要找的知识点</summary>
    
    
    
    
    <category term="JAVA" scheme="https://wheliosc.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>双系统安装Ubuntu18.04</title>
    <link href="https://wheliosc.github.io/Dual-System-Installation"/>
    <id>https://wheliosc.github.io/Dual-System-Installation</id>
    <published>2018-10-01T06:24:25.819Z</published>
    <updated>2021-08-30T07:30:15.657Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>以<a href="https://www.ubuntu.com/download/desktop">Ubuntu18.04</a>为例</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>工具为<a href="https://cn.ultraiso.net/xiazai.html">软碟通UltraISO</a>。</p><ul><li>准备一个U盘，格式化。</li><li>以管理员身份运行软碟通，菜单栏里选择“启动-&gt;写入硬盘映像”，写入方式选择“usb-HDD+”，“便捷启动-&gt;写入新的驱动程序引导扇区-&gt;Syslinux”。</li></ul><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>工具为<a href="http://rufus.akeo.ie/">rufus</a>。</p><ul><li>这是一个Ubuntu官方推荐的工具，用起来还是很方便的。唯一需要注意的就是选择Partition schema为MBR还是GPT。</li><li>查看硬盘分区表类型可以使用windows下的磁盘管理。点击要查看的硬盘，右键，“属性-&gt;卷”就能看到了。<br>还有很多其他的工具可用，不一一赘述了。</li></ul><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ul><li>首先，重启电脑进入BIOS，关闭安全启动(如果之前装过双系统的话应该关掉了)，设置第一启动项为U盘启动，设置完成后保存退出。</li><li>这时候电脑应该会自动重启，重启之后应该就是Ubuntu的安装引导了，选择Install Ubuntu。</li><li>选择语言和键盘布局。</li><li>在联网这一项上，选择暂不连接网络，这样可以加快安装的进度，一些东西可以安好系统后自己选择安装。</li><li>选择最小安装，其他的不用选。</li><li>如果要装双系统，选择与Windows共存就好了，Ubuntu可以自己选择你未分配的空间作为安装空间(前提是你有未分配的空间)。网上的一些教程都交了如何自己分区，非老手且没有什么特殊需求建议不要尝试了，没什么用。如果只保留Ubuntu，选择只保留Ubuntu就好了。</li><li>接下来就是一些时区，用户名的设置了。</li><li>设置完后，安装就开始了，大约需要30分钟左右吧(当然这要视电脑情况而定😝)。</li></ul><h3 id="系统升级"><a href="#系统升级" class="headerlink" title="系统升级"></a>系统升级</h3><p>如果之前你是16.04或者17.10等其他的版本，也可以升级到18.04版本。(注意提前做好备份，万一装崩了呢🙊)</p><ul><li>首先，更新升级已安装的软件包。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt dist-upgrade</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure></li><li>在软件更新器里选择更新版本为长期支持版本。</li><li>安装update-manager-core <code>sudo apt-get install update-manager-core</code></li><li>执行<code>sudo do-release-upgrade -d</code>等待完成就ok了，我大概用了100分钟的时间。</li></ul><h3 id="安装Gnome插件"><a href="#安装Gnome插件" class="headerlink" title="安装Gnome插件"></a>安装Gnome插件</h3><p>Ubuntu18.04回归了gnome桌面，意味着我们可以使用很多有用的插件来使它更加的高效和炫酷。<br>如何安装gnome插件呢？<br>网上说了很多方法，在官网下载后解压到对应路径下的最多，但是这样就很麻烦。之后我发现在Ubuntu的软件中心有一个附加组件项，点进去，卧槽，这不就是现成的嘛…<br>推荐几个插件吧：<br>Simple net speed    顶栏实时网速显示<br>Openweather            顶栏显示天气<br>EasyScreenCast        录屏<br>Coverflow alt-tab    效果超赞的 alt-tab 切换效果<br>……<br>更多有趣的插件自己探索吧~</p><p><br/></p>]]></content>
    
    
    <summary type="html">十一假期，想要卸载掉deepin，Ubuntu18.04已经发布半年了，bug应该改的差不多了，想要尝试一下，而且18.04的桌面看起来有点好看的感觉欸~</summary>
    
    
    
    
    <category term="操作系统" scheme="https://wheliosc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>词法分析器</title>
    <link href="https://wheliosc.github.io/lexical-analysis"/>
    <id>https://wheliosc.github.io/lexical-analysis</id>
    <published>2018-10-01T06:18:20.686Z</published>
    <updated>2021-08-30T07:28:53.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><blockquote><p>In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning).<br>在计算机科学中，词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。</p></blockquote><h2 id="编码目标"><a href="#编码目标" class="headerlink" title="编码目标"></a>编码目标</h2><p>给定一个源代码文件，能够将其转化为词法记号流。<br>比如规定int的词法记号为30，输出就是(30,  int)；数字的词法记号为11，则输入123，输出为(11, 123)。</p><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>把程序中的词法单元分为四类：标识符（分为关键字和一般标识符）、数字、特殊字符、空白（空格、Tab、回车换行等）</p><h2 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h2><p><img src="https://ws4.sinaimg.cn/large/006xwwY9ly1g0ubmnvdzbj30m80ci756.jpg" alt="程序流程图"><br>对于运算符等符号，这里只考虑两个字符的组合情况，不考虑三个字符组成的运算符。之所以要在读到特殊字符之后在往后读一个字符是因为有可能在表中存在类似<code>&gt;=</code>和<code>&gt;</code>的运算符，要保证最长字符匹配。</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="首字符类型判断"><a href="#首字符类型判断" class="headerlink" title="首字符类型判断"></a>首字符类型判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCharType</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String regex_Letter = <span class="string">&quot;[a-zA-Z]&quot;</span>;</span><br><span class="line">        String regex_Number = <span class="string">&quot;[0-9]&quot;</span>;</span><br><span class="line">        String regex_Blank = <span class="string">&quot;\\s&quot;</span>;</span><br><span class="line">        Pattern pattern;</span><br><span class="line"></span><br><span class="line">        pattern = Pattern.compile(regex_Letter);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;LETTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">        pattern = Pattern.compile(regex_Number);</span><br><span class="line">        matcher = pattern.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;NUMBER&quot;</span>;</span><br><span class="line"></span><br><span class="line">        pattern = Pattern.compile(regex_Blank);</span><br><span class="line">        matcher = pattern.matcher(str);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;BLANK&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SPECIAL&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="如果首字符为字母"><a href="#如果首字符为字母" class="headerlink" title="如果首字符为字母"></a>如果首字符为字母</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;LETTER&quot;</span>:</span><br><span class="line">pattern = Pattern.compile(regex_ID);</span><br><span class="line">matcher = pattern.matcher(srcCode);</span><br><span class="line"><span class="keyword">if</span> (matcher.lookingAt()) &#123;</span><br><span class="line">String result = matcher.group();</span><br><span class="line"><span class="keyword">if</span> (LexicalToken.isKeyWord(result)) &#123;</span><br><span class="line"><span class="keyword">int</span> token = lextok.getToken(result);</span><br><span class="line">System.out.printf(<span class="string">&quot;&lt;%d,%s&gt;  &quot;</span>, token, result);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> token = lextok.getToken(<span class="string">&quot;ID&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;&lt;%d,%s&gt;  &quot;</span>, token, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">srcCode = srcCode.substring(matcher.end());</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="如果首字符是数字"><a href="#如果首字符是数字" class="headerlink" title="如果首字符是数字"></a>如果首字符是数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;NUMBER&quot;</span>:</span><br><span class="line">pattern = Pattern.compile(regex_NUM);</span><br><span class="line">    matcher = pattern.matcher(srcCode);</span><br><span class="line">    <span class="keyword">if</span> (matcher.lookingAt()) &#123;</span><br><span class="line">    String result = matcher.group();</span><br><span class="line">        <span class="keyword">int</span> token = lextok.getToken(<span class="string">&quot;NUM&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;&lt;%d,%s&gt;  &quot;</span>, token, result);</span><br><span class="line">     &#125;</span><br><span class="line">     srcCode = srcCode.substring(matcher.end());</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="如果首字符是空格"><a href="#如果首字符是空格" class="headerlink" title="如果首字符是空格"></a>如果首字符是空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;BLANK&quot;</span>:</span><br><span class="line">srcCode = srcCode.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="如果首字符是特殊符号"><a href="#如果首字符是特殊符号" class="headerlink" title="如果首字符是特殊符号"></a>如果首字符是特殊符号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;SPECIAL&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> (srcCode.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    String secondChar = srcCode.substring(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        String result;</span><br><span class="line">        LinkedHashMap tokenMap = lextok.getLexicalTokenMap();</span><br><span class="line">        Set set = tokenMap.keySet();</span><br><span class="line">        result = firstChar + secondChar;</span><br><span class="line">        <span class="keyword">if</span> (getCharType(secondChar).equals(<span class="string">&quot;SPECIAL&quot;</span>) &amp;&amp; set.contains(result)) &#123;</span><br><span class="line">            <span class="keyword">int</span> token = lextok.getToken(result);</span><br><span class="line">            System.out.printf(<span class="string">&quot;&lt;%d,%s&gt;  &quot;</span>, token, result);</span><br><span class="line">            srcCode = srcCode.substring(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = firstChar;</span><br><span class="line">            <span class="keyword">int</span> token = lextok.getToken(result);</span><br><span class="line">            System.out.printf(<span class="string">&quot;&lt;%d,%s&gt;  &quot;</span>, token, result);</span><br><span class="line">            srcCode = srcCode.substring(<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 字符串中只有一个字符时</span></span><br><span class="line">           <span class="keyword">int</span> token = lextok.getToken(srcCode);</span><br><span class="line">           System.out.printf(<span class="string">&quot;&lt;%d,%s&gt;  &quot;</span>, token, srcCode);</span><br><span class="line">           srcCode = srcCode.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>源码地址：<a href="https://github.com/Liyzy/Lexer">https://github.com/Liyzy/Lexer</a><br>开发环境：jetbrains idea 2018.2</p><p><br/></p>]]></content>
    
    
    <summary type="html">词法分析，lexing或标记化是将一系列字符（例如在计算机程序或网页中）转换成一系列标记（具有指定且因此标识的含义的字符串）的过程。</summary>
    
    
    
    
    <category term="编译原理" scheme="https://wheliosc.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="JAVA" scheme="https://wheliosc.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>双系统卸载</title>
    <link href="https://wheliosc.github.io/Dual-system-unloading"/>
    <id>https://wheliosc.github.io/Dual-system-unloading</id>
    <published>2018-09-23T12:38:58.017Z</published>
    <updated>2021-08-30T07:30:20.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><p>本文主要针对windows+Linux双系统卸载Linux/Unix系统(Ubuntu\Deepin...)。</p><h2 id="删除系统"><a href="#删除系统" class="headerlink" title="删除系统"></a>删除系统</h2><p>在windows上，右键开始打开磁盘管理(或者直接搜索“磁盘管理”)，看到装有Linux系统的硬盘分区，右键删除卷，删除后分区变为“未分配”。如果不安装新的系统，可以“新建简单卷”；如果还要安装别的系统，就暂不处理。</p><p>如果之前Linux/Unix系统是第一启动项，那么这时候你重启计算机的话是会出现错误的，因为引导找不到这个系统了。而且，在BIOS的启动项里还存在着这个系统。这时我们就要修复引导。</p><h2 id="修复引导"><a href="#修复引导" class="headerlink" title="修复引导"></a>修复引导</h2><p>我们用到一个工具：<a href="https://www.easyuefi.com/index-us.html">EasyUEFI</a> 下个试用版就OK。<br>运行EasyUEFI，选择“管理EFI启动项”，可以看到你要卸载的系统的启动项，选中，选择“删除选中项”。<br>之后在进入BIOS查看启动项，发现只剩下一个windows的启动项了，成功！</p><p><br/></p>]]></content>
    
    
    <summary type="html">双系统，只留一个或者想换另一种系统玩一下，第一步都要先卸载不要的系统，只格式化所在分区就行了麽？</summary>
    
    
    
    
    <category term="操作系统" scheme="https://wheliosc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【Python学习笔记1】数据结构篇</title>
    <link href="https://wheliosc.github.io/python-data-structure"/>
    <id>https://wheliosc.github.io/python-data-structure</id>
    <published>2018-09-22T01:53:58.495Z</published>
    <updated>2021-08-30T07:28:49.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h2 id="Python简单介绍"><a href="#Python简单介绍" class="headerlink" title="Python简单介绍"></a>Python简单介绍</h2><blockquote><p>作为一种<em>解释型语言</em>，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。<br>与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有<em>动态类型</em>系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。<br>Python是完全物件导向的语言。函数、模组、数字、字串都是物件。并且完全支持继承、重载、派生、多重继承，有益于增强原始码的复用性。Python支持重载运算符，因此Python也支持泛型设计。<br>Python编译器本身也可以被集成到其它需要脚本语言的程式内。因此，有很多人把Python作为一种<em>“胶水语言”</em>使用。使用Python将其他语言编写的程式进行集成和封装。<br>Python属于<em>动态类型语言</em>，动态类型语言是在运行期间检查数据的类型，不得不保持描述变量值的实际类型标记，程序在每次操作变量时，需要执行数据依赖分支，而静态类型语言相对于动态类型语言，在声明变量时已经指定了数据类型和表示方法，根据这一原理导致Python相对于C、Visual Basic等静态类型语言来说<em>运行速度较慢</em>。</p><p>摘录自Wikipedia</p></blockquote><h2 id="Python数据类型"><a href="#Python数据类型" class="headerlink" title="Python数据类型"></a>Python数据类型</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Python中没有关键字表示常量，用大写来代表这是一个常量。例如NUM=5，NUM就是一个常量。因此，在编写Python代码时，要严格区分大小写。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Python中变量声明不需要声明变量类型。<br>但是，Python是一种强类型语言，不能因此而判断Python是弱类型的。<br><strong>Python是动态的、强类型的语言。</strong><br><a href="https://wiki.Python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language">Why is Python a dynamic language and also a strongly typed language？</a></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="分为两大类：内置数据类型、自定义数据类型"><a href="#分为两大类：内置数据类型、自定义数据类型" class="headerlink" title="分为两大类：内置数据类型、自定义数据类型"></a>分为两大类：内置数据类型、自定义数据类型</h4><p>内置数据类型分为：数值、序列、集合、字典、特殊、其他<br>数值数据类型：整数、浮点数、布尔、复数<br>序列数据类型：字符串、元组、字节序列、列表、字节数组<br>集合数据类型：集、不可变集</p><h4 id="内置的type-函数可以用来查询变量所指的对象类型"><a href="#内置的type-函数可以用来查询变量所指的对象类型" class="headerlink" title="内置的type()函数可以用来查询变量所指的对象类型"></a>内置的type()函数可以用来查询变量所指的对象类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt; &lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt; &lt;<span class="built_in">type</span> <span class="string">&#x27;bool&#x27;</span>&gt; &lt;<span class="built_in">type</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myInt = <span class="number">5</span> </span><br><span class="line">myInt = <span class="built_in">int</span>(<span class="number">5</span>) <span class="comment">#int对象方式</span></span><br><span class="line"><span class="built_in">int</span>(<span class="number">5.4</span>) <span class="comment">#自动类型转换</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>) <span class="comment">#自动类型转换</span></span><br><span class="line"><span class="comment">#二进制以0b开头，八进制以0开头，十六进制以0x开头</span></span><br></pre></td></tr></table></figure><h4 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFloat = <span class="built_in">float</span>(<span class="number">3.14</span>)</span><br><span class="line">myFloat = <span class="built_in">float</span>(<span class="number">4</span>) <span class="comment">#自动类型转换，输出结果4.0</span></span><br></pre></td></tr></table></figure><h4 id="复数数据类型-虚部必须用j"><a href="#复数数据类型-虚部必须用j" class="headerlink" title="复数数据类型 虚部必须用j"></a>复数数据类型 虚部必须用j</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">1j</span> <span class="comment">#不可写成1+j</span></span><br><span class="line"><span class="number">0</span>+<span class="number">0j</span> <span class="comment">#0不能省略</span></span><br><span class="line"><span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#其中1为实部，2为虚部</span></span><br><span class="line">c1=<span class="built_in">complex</span>(<span class="number">6</span>) <span class="comment">#输出c1为6+0j,等同于complex(6,0) complex(6,)</span></span><br><span class="line">c2=<span class="built_in">complex</span>(<span class="number">2.1</span>,<span class="number">3.2</span>) <span class="comment">#实部与虚部可以为浮点数</span></span><br><span class="line"><span class="comment">#real:复数的实部 imag:复数的虚部  c2.real输出结果2.1,c2.imag输出结果3.2</span></span><br></pre></td></tr></table></figure><h4 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">True False开头首字母必须大写</span></span><br><span class="line"><span class="string">bool对象 bool(False)</span></span><br><span class="line"><span class="string">bool(0),bool(0.0) 结果为False,任何非零均为True例如   bool(&#x27;0&#x27;),bool(5),bool(2.3),bool(&quot;abc&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><h5 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h5><p><code>&quot;abc&quot;</code>  <code>&#39;abc&#39;</code>  <code>&#39;&#39;&#39;abc&#39;&#39;&#39;</code>  <code>&quot;&quot;&quot;abc&quot;&quot;&quot;</code>  前两个表示一行，后两个表示可以跨行</p><h5 id="字符串拼接与重复"><a href="#字符串拼接与重复" class="headerlink" title="字符串拼接与重复"></a>字符串拼接与重复</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;abc&quot;</span>+<span class="string">&#x27;def&#x27;</span>  <span class="comment">#使用+进行字符串连接</span></span><br><span class="line"><span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;abc&quot;</span> <span class="string">&#x27;def&#x27;</span>  <span class="comment">#默认自动连接</span></span><br><span class="line"><span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;abc&quot;</span>*<span class="number">2</span>  <span class="comment"># *表示重复，*后的整数表示重复次数</span></span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><div class="table-container"><table><thead><tr><th style="text-align:center">转义字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">\n</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">水平制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">垂直制表符</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">退格</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">换页</td></tr></tbody></table></div><p>使用r或R为开头的字符串成为原始字符串，其中包含的任何字符都不可进行转义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myStr = <span class="string">r&quot;abc\n&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(myStr)</span><br><span class="line"><span class="string">&#x27;abc\n&#x27;</span></span><br></pre></td></tr></table></figure></p><h5 id="str对象"><a href="#str对象" class="headerlink" title="str对象"></a>str对象</h5><p>str()<br>str(.14) 输出结果为 ‘0.14’ ，浮点数前导0可省略,隐式类型转换。</p><h5 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h5><p>Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。<br><strong>注意，没有单独的字符类型，一个字符就是长度为1的字符串。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure></p><h5 id="字符串截取子串"><a href="#字符串截取子串" class="headerlink" title="字符串截取子串"></a>字符串截取子串</h5><p>用冒号分隔两个索引，形式为变量[头下标:尾下标]。<br>截取的范围是前闭后开的，并且两个索引都可以省略：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;ilovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;love&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:]</span><br><span class="line"><span class="string">&#x27;ilovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>:]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">10</span>:-<span class="number">6</span>]</span><br><span class="line"><span class="string">&#x27;love&#x27;</span></span><br></pre></td></tr></table></figure><br>Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="列表的创建方式"><a href="#列表的创建方式" class="headerlink" title="列表的创建方式"></a>列表的创建方式</h5><h6 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h6><p>[x1,x2,x3,x4,…,xn]<br>列表中元素类型可以不同，如[1, 2, 3, ‘q’, True]<br>列表中的元素可以是表达式，如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">temp = [x + x, x * x, <span class="number">11</span>]</span><br><span class="line"><span class="built_in">list</span> = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],<span class="number">8</span>]</span><br></pre></td></tr></table></figure></p><h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = <span class="built_in">list</span>()  <span class="comment">#空列表</span></span><br><span class="line">list2 = <span class="built_in">list</span>(<span class="string">&quot;abcd&quot;</span>)  <span class="comment">#结果[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line">list3 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>))  <span class="comment">#结果[0, 1, 2]</span></span><br></pre></td></tr></table></figure><h6 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h6><p>使用非常简单的表达式满足特定的列表<br><code>表达式　for 变量　in 序列</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list4 = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(list4)   <span class="comment">#结果[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line">list5 = [i <span class="keyword">for</span> i <span class="keyword">in</span> list4 <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]  <span class="comment">#结果[4, 16, 36, 64]</span></span><br></pre></td></tr></table></figure></p><h5 id="列表的操作"><a href="#列表的操作" class="headerlink" title="列表的操作"></a>列表的操作</h5><p>列表的操作包括：索引、切片、连接、重复、成员关系、比较、求长度、最大值、最小值等</p><h6 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list6 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(list6[<span class="number">0</span>], list6[-<span class="number">1</span>])  <span class="comment">#结果１　３</span></span><br><span class="line">list6[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment">#list中的值可以改变，此时list6为[10, 2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="删除列表中的元素"><a href="#删除列表中的元素" class="headerlink" title="删除列表中的元素"></a>删除列表中的元素</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list7 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">#[1,2,3,4,5]</span></span><br><span class="line"><span class="keyword">del</span> list7[<span class="number">1</span>]  <span class="comment">#[1,3,4,5]</span></span><br></pre></td></tr></table></figure><h6 id="求长度、最大值、最小值、和"><a href="#求长度、最大值、最小值、和" class="headerlink" title="求长度、最大值、最小值、和"></a>求长度、最大值、最小值、和</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>８ = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  <span class="comment">#[1,2,3,4,5,6]</span></span><br><span class="line"><span class="built_in">len</span>(list8)  <span class="comment">#6</span></span><br><span class="line"><span class="built_in">min</span>(list8)  <span class="comment">#1</span></span><br><span class="line"><span class="built_in">max</span>(list8)  <span class="comment">#6</span></span><br><span class="line"><span class="built_in">sum</span>(list8)  <span class="comment">#21</span></span><br><span class="line">list9 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">len</span>(list9)  <span class="comment">#6</span></span><br><span class="line"><span class="built_in">max</span>(list9)  <span class="comment">#TypeError: unorderable types: str() &gt; int(), min和sum同样错误。</span></span><br><span class="line">list10 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]  <span class="comment">#可以算len,max,min，但不能求和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 2.7.15中测试结果如下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(list1)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(list1)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(list1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h6 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h6><p>s[i:j]    从索引i开始，到j结束，左闭右开。省略i从0开始，省略j到结尾结束<br>s[i:j:k]　k表示步长<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">temp = list1[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(temp)  <span class="comment"># 结果[2, 4, 6]</span></span><br><span class="line">list1[:<span class="number">1</span>] = []  <span class="comment"># list1变为[2,3,4,5,6,7]</span></span><br></pre></td></tr></table></figure></p><h6 id="连接与重复"><a href="#连接与重复" class="headerlink" title="连接与重复"></a>连接与重复</h6><p>连接<code>+</code>　重复<code>*</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list3 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(list2+list3)  <span class="comment"># 结果[1, 2, 3, 3, 4, 5],只连接不去重</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>*list2)  <span class="comment"># 结果[1, 2, 3, 1, 2, 3]</span></span><br><span class="line">list2 += list3  <span class="comment"># 结果[1, 2, 3, 3, 4, 5],等价于list2 = list2 + list3</span></span><br></pre></td></tr></table></figure></p><h6 id="成员关系操作"><a href="#成员关系操作" class="headerlink" title="成员关系操作"></a>成员关系操作</h6><p>判断一个元素是否在列表中<br><code>in</code> 和<code>not in</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span> <span class="keyword">in</span> list1)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> list1)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(list1.count(<span class="number">3</span>))  <span class="comment"># 3  计算某一个元素在列表中出现的次数</span></span><br><span class="line"><span class="built_in">print</span>(list1.index(<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>))  <span class="comment"># 2 查找某个元素在给定范围内第一次出现的索引,例子中范围为[2,6)</span></span><br></pre></td></tr></table></figure></p><h6 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">list3 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list1 == list2)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(list3 &gt; list2)   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(list3 &gt; list4)   <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 从第一个元素开始比较</span></span><br></pre></td></tr></table></figure><h6 id="列表的排序"><a href="#列表的排序" class="headerlink" title="列表的排序"></a>列表的排序</h6><p><code>sorted(list1))</code></p><h6 id="any-和all"><a href="#any-和all" class="headerlink" title="any()和all()"></a>any()和all()</h6><p>any() 列表中是否有元素为True<br>all() 列表中的元素是否都为True</p><h6 id="列表的拆分"><a href="#列表的拆分" class="headerlink" title="列表的拆分"></a>列表的拆分</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a,b,c,d = list1</span><br><span class="line"><span class="built_in">print</span>(a,b,c,d)  <span class="comment"># 结果１　２　３　４</span></span><br><span class="line"><span class="comment">#　应保证前面的变量数与列表的长度相同</span></span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><h5 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h5><p>定值表，用来存储不变值表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>         <span class="comment"># 表示元组</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)       <span class="comment"># 表示元组</span></span><br><span class="line">t = ()              <span class="comment"># 表示空元组</span></span><br><span class="line">t = <span class="number">1</span>,              <span class="comment"># 表示只有一个元素的元组，必须有逗号</span></span><br><span class="line">t = <span class="built_in">tuple</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 错误写法，只能有一个参数</span></span><br><span class="line">t = <span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])<span class="comment"># 正确写法</span></span><br><span class="line">t = <span class="built_in">tuple</span>(<span class="string">&quot;abcd&quot;</span>)   <span class="comment"># 结果为（&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;）</span></span><br><span class="line">t = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">8</span>)) </span><br><span class="line">t = <span class="built_in">tuple</span>(<span class="number">2</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)) <span class="comment"># 结果为(2,4,6,8)</span></span><br></pre></td></tr></table></figure></p><h5 id="元组的操作"><a href="#元组的操作" class="headerlink" title="元组的操作"></a>元组的操作</h5><p>索引访问、切片、连接、重复、成员关系、最大值、最小值、和、长度、排序等<br>与列表的操作类似，可以进行对比。一些内容不作赘述。</p><h6 id="元组的排序"><a href="#元组的排序" class="headerlink" title="元组的排序"></a>元组的排序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = <span class="built_in">tuple</span>([<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(tuple1))</span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]  <span class="comment"># 输出的是列表</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>)  <span class="comment"># 原元组没有变化</span></span><br></pre></td></tr></table></figure><h6 id="元组的拆分"><a href="#元组的拆分" class="headerlink" title="元组的拆分"></a>元组的拆分</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a, *s, d, f = tuple1 </span><br><span class="line"><span class="built_in">print</span>(a, d, f)      <span class="comment"># 结果为 2 4 6</span></span><br><span class="line">a, s, d, *f = tuple1</span><br><span class="line"><span class="built_in">print</span>(a, s, d)      <span class="comment"># 结果为 2 1 9</span></span><br><span class="line"><span class="comment"># 元组的拆分前面变量的个数必须与元组元素个数相等。如果元组元素个数过多，可以使用*代表多个变量</span></span><br><span class="line"></span><br><span class="line">_, a, b, _, *_ = tuple1</span><br><span class="line"><span class="built_in">print</span>(a, b, _)      <span class="comment"># 结果为 1 9 [4, 6]</span></span><br><span class="line"><span class="comment"># 没有意义的命名可以使用临时变量下划线(_)表示。输出临时变量，只会保留最后一个。</span></span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="字面量-1"><a href="#字面量-1" class="headerlink" title="字面量"></a>字面量</h5><p><code>&#123;键:值,键:值,键:值,键:值,&#125;</code></p><h5 id="字典对象"><a href="#字典对象" class="headerlink" title="字典对象"></a>字典对象</h5><p><code>dict()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>([[<span class="string">&#x27;优&#x27;</span>,<span class="number">90</span>],[<span class="string">&#x27;良&#x27;</span>,<span class="number">80</span>]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(((<span class="string">&#x27;优&#x27;</span>,<span class="number">90</span>),(<span class="string">&#x27;良&#x27;</span>,<span class="number">80</span>))))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;优&#x27;</span>,<span class="string">&#x27;良&#x27;</span>],[<span class="number">90</span>,<span class="number">80</span>])))</span><br><span class="line"><span class="comment"># 结果均为 &#123;&#x27;优&#x27;: 90, &#x27;良&#x27;: 80&#125;</span></span><br><span class="line">dict1 = <span class="built_in">dict</span>(a=<span class="string">&quot;apple&quot;</span>, b=<span class="string">&quot;banane&quot;</span>)  <span class="comment"># &#123;&#x27;a&#x27;:&#x27;apple&#x27;, &#x27;b&#x27;:&#x27;banane&#x27;&#125;</span></span><br></pre></td></tr></table></figure></p><h5 id="fromkeys"><a href="#fromkeys" class="headerlink" title="fromkeys()"></a>fromkeys()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict2 = &#123;&#125;.fromkeys([<span class="string">&#x27;优&#x27;</span>,<span class="string">&#x27;良&#x27;</span>],<span class="string">&quot;大于70分&quot;</span>)  <span class="comment"># &#123;&#x27;优&#x27;: &#x27;大于70分&#x27;, &#x27;良&#x27;: &#x27;大于70分&#x27;&#125;</span></span><br><span class="line">dict3 = &#123;&#125;.fromkeys([<span class="string">&#x27;优&#x27;</span>,<span class="string">&#x27;良&#x27;</span>])  <span class="comment"># &#123;&#x27;优&#x27;: None, &#x27;良&#x27;: None&#125;</span></span><br><span class="line">dict4 = &#123;&#125;.fromkeys([<span class="string">&#x27;优&#x27;</span>,<span class="string">&#x27;良&#x27;</span>],<span class="literal">None</span>)  <span class="comment"># &#123;&#x27;优&#x27;: None, &#x27;良&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure><h5 id="推导式-1"><a href="#推导式-1" class="headerlink" title="推导式"></a>推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict5 = &#123;n:n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)&#125; <span class="comment"># &#123;1:1,2:4,3:9,4:16&#125;</span></span><br></pre></td></tr></table></figure><h5 id="得到键对应的值"><a href="#得到键对应的值" class="headerlink" title="得到键对应的值"></a>得到键对应的值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dict2[<span class="string">&#x27;优&#x27;</span>]  <span class="comment"># 大于70分</span></span><br><span class="line">dict2.get(<span class="string">&#x27;优&#x27;</span>)  <span class="comment"># 大于70分</span></span><br><span class="line">dict2.get(<span class="string">&#x27;秀&#x27;</span>)  <span class="comment"># 没有反应，也没有报错</span></span><br><span class="line">dict2.get(<span class="string">&#x27;秀&#x27;</span>,<span class="string">&#x27;自定义错误提示&#x27;</span>)  <span class="comment"># 如果有“秀”对应的值，则输出对应的值；否则输出后面的提示信息</span></span><br><span class="line">dict2.get(<span class="string">&#x27;优&#x27;</span>, <span class="string">&#x27;自定义错误提示&#x27;</span>)  <span class="comment"># 大于70分</span></span><br><span class="line">dict2.items()  <span class="comment"># 获取所有的键值对</span></span><br><span class="line">dict2.keys()  <span class="comment"># 返回所有的键值</span></span><br><span class="line">dict2.values()  <span class="comment">#返回所有的值</span></span><br></pre></td></tr></table></figure><h5 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1[<span class="string">&#x27;c&#x27;</span>] = cat  <span class="comment"># &#123;&#x27;a&#x27;:&#x27;apple&#x27;, &#x27;b&#x27;:&#x27;banane&#x27;, &#x27;c&#x27;:&#x27;cat&#x27;&#125; 没有则添加</span></span><br><span class="line">dict1[<span class="string">&#x27;a&#x27;</span>] = allen  <span class="comment"># &#123;&#x27;a&#x27;:&#x27;allen&#x27;, &#x27;b&#x27;:&#x27;banane&#x27;&#125; 有则修改</span></span><br></pre></td></tr></table></figure><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict6 = &#123;<span class="string">&#x27;No1&#x27;</span>:<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;No2&#x27;</span>:<span class="string">&#x27;Python&#x27;</span>&#125;</span><br><span class="line">dict7 = &#123;<span class="string">&#x27;No3&#x27;</span>:<span class="string">&#x27;C++&#x27;</span>&#125;</span><br><span class="line">dict8 = &#123;<span class="string">&#x27;No2&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line">dict6.update(dict7)  <span class="comment"># dict6为&#123;&#x27;No1&#x27;: &#x27;java&#x27;, &#x27;No2&#x27;: &#x27;Python&#x27;, &#x27;No3&#x27;: &#x27;C++&#x27;&#125;</span></span><br><span class="line">dict6.update(dict8)  <span class="comment"># dict6为&#123;&#x27;No1&#x27;:&#x27;java&#x27;,&#x27;No2&#x27;:&#x27;C&#x27;， &#x27;No3&#x27;: &#x27;C++&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span>(dict6[<span class="string">&#x27;No2&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(dict6)  <span class="comment"># &#123;&#x27;No1&#x27;: &#x27;java&#x27;， &#x27;No3&#x27;: &#x27;C++&#x27;&#125;</span></span><br><span class="line"><span class="keyword">del</span> dict6</span><br><span class="line"><span class="built_in">print</span>(dict6)  <span class="comment"># 报错，未定义dict1</span></span><br><span class="line"></span><br><span class="line">dict6.pop(<span class="string">&#x27;No2&#x27;</span>,<span class="string">&#x27;自定义错误提示&#x27;</span>)  <span class="comment"># 存在则删除；不存在输出自定义错误提示，即参数二</span></span><br><span class="line">dict9 = &#123;<span class="string">&#x27;No1&#x27;</span>:<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;No2&#x27;</span>:<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;No3&#x27;</span>:<span class="string">&#x27;C++&#x27;</span>&#125;</span><br><span class="line">dict9.popitem()  <span class="comment"># 从后往前删除，每次删除一个。先删除No3,再删除No2...</span></span><br><span class="line">dict9.clear()  <span class="comment"># dict9为 &#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>可变集合(set) 不可变集合(frozenset)<br>没有顺序，没有重复元素</p><h5 id="字面量-2"><a href="#字面量-2" class="headerlink" title="字面量"></a>字面量</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>&#125;)  <span class="comment"># &#123;1, 2, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="literal">True</span>&#125;)   <span class="comment"># &#123;1&#125;</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="literal">False</span>&#125;)  <span class="comment"># &#123;False, 1&#125;</span></span><br></pre></td></tr></table></figure><h5 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>(<span class="string">&#x27;hello&#x27;</span>)    <span class="comment"># &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;</span></span><br><span class="line">set2 = <span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">set3 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">set4 = <span class="built_in">set</span>((<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))<span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><h5 id="推导式-2"><a href="#推导式-2" class="headerlink" title="推导式"></a>推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)&#125;  <span class="comment"># &#123;16, 1, 4, 9&#125;</span></span><br></pre></td></tr></table></figure><h5 id="交并差集"><a href="#交并差集" class="headerlink" title="交并差集"></a>交并差集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set5 = <span class="built_in">set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">set6 = <span class="built_in">set</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">set5 | set6  <span class="comment"># 并集 &#123;1, 2, 3, 4, 5, 6&#125; </span></span><br><span class="line">set5 &amp; set6  <span class="comment"># 交集 &#123;3, 4&#125; </span></span><br><span class="line">set5 - set6  <span class="comment"># 差集 &#123;1, 2&#125; </span></span><br><span class="line">set5 ^ set6  <span class="comment"># 对称差集 &#123;1, 2, 5, 6&#125;</span></span><br></pre></td></tr></table></figure><h5 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set5.update(set6)  <span class="comment"># &#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set7 = set6.copy()</span><br></pre></td></tr></table></figure><p><br/></p>]]></content>
    
    
    <summary type="html">这是Python学习的课上笔记第一篇，主要内容有数据结构</summary>
    
    
    
    
    <category term="Python" scheme="https://wheliosc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>利用ZXing工具生成二维码以及解析二维码</title>
    <link href="https://wheliosc.github.io/QRcode"/>
    <id>https://wheliosc.github.io/QRcode</id>
    <published>2018-09-06T10:40:52.971Z</published>
    <updated>2021-08-30T07:29:03.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="二维码生成原理（即工作原理）"><a href="#二维码生成原理（即工作原理）" class="headerlink" title="二维码生成原理（即工作原理）"></a>二维码生成原理（即工作原理）</h3><p>二维码官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)<em>4 + 21（V是版本号） 最高Version 40，(40-1)</em>4+21 = 177，所以最高是177 x 177 的正方形。</p><p>下面是一个二维码的样例：<br><img src="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=caf539606b224f4a57cc7b1539c7bc6a/024f78f0f736afc3013f7023b519ebc4b7451240.jpg" alt=""></p><p>1、定位图案</p><p>Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。</p><p>Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。</p><p>Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。</p><p>2、功能性数据</p><p>Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。</p><p>Version Information 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。</p><p>数据码和纠错码</p><p>除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。</p><p>3、数据编码</p><p>QR码支持如下的编码：</p><p>Numeric mode 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）</p><p>Alphanumeric mode 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和 字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）<br><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=d8c7c96a8101a18bf0be1a49ae1f2b30/8694a4c27d1ed21b5de761a3ab6eddc451da3f4d.jpg" alt=""></p><p>Byte mode, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。</p><p>Kanji mode 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个 值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把前两位拿出来乘以0XC0，然后再加上后两位，最 后转成13bit的编码。如下图示例：<br><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=e06f4364b51bb0518f71bb2e064af68c/738b4710b912c8fc8ad6b98bfa039245d688214a.jpg" alt=""></p><p>Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。</p><p>Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。</p><p>FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。</p><p>简单起见，后面三种不会在本文 中讨论。</p><p>下面两张表中，</p><p>Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101</p><p>Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）</p><p><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=8ab6ed5dd20735fa91a546bfae61238b/8cb1cb1349540923fcfa2c389458d109b2de49e0.jpg" alt=""></p><p>示例一：数字编码</p><p>在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567</p><p> 把上述数字分成三组: 012 345 67</p><p> 把他们转成二进制:  012 转成 0000001100；  345 转成 0101011001；  67 转成 1000011。</p><p> 把这三个二进制串起来: 0000001100 0101011001 1000011</p><p> 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000</p><p> 把数字编码的标志0001和第4步的编码加到前面:  0001 0000001000 0000001100 0101011001 1000011</p><p>示例二：字符编码</p><p>在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42</p><ol><li><p>从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)</p></li><li><p>两两分组: (10,12) (41,4) (2)</p></li></ol><p>3.把每一组转成11bits的二进制:</p><p>(10,12) 10*45+12 等于 462 转成 00111001110</p><p>(41,4) 41*45+4 等于 1849 转成 11100111001</p><p>(2) 等于 2 转成 000010</p><ol><li><p>把这些二进制连接起来：00111001110 11100111001 000010</p></li><li><p>把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101</p></li><li><p>在头上加上编码标识 0010 和第5步的个数编码:  0010 000000101 00111001110 11100111001 000010</p></li></ol><p>结束符和补齐符</p><p>假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，</p><p>编码</p><p>字符数</p><p>HELLO WORLD的编码</p><p>0010    000001011    01100001011 01111000110 10001011100 10110111000 10011010100 001101    </p><p>我们还要加上结束符：</p><p>编码</p><p>字符数</p><p>HELLO WORLD的编码</p><p>结束</p><p>0010    000001011    01100001011 01111000110 10001011100 10110111000 10011010100 001101    0000    </p><p>按8bits重排</p><p>如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：</p><p>00100000   01011011   00001011   01111000   11010001   01110010   11011100   01001101   01000011   01000000</p><p>补齐码（Padding Bytes）</p><p>最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限 制，可以参看QR Code Spec的第28页到32页的Table-7一表。</p><p>假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：</p><p>00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100</p><p>纠错码</p><p>上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。</p><p>错误修正容量</p><p>L水平    7%的字码可被修正    </p><p>M水平    15%的字码可被修正    </p><p>Q水平    25%的字码可被修正    </p><p>H水平    30%的字码可被修正    </p><p>那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看QR Code Spec的第33页到44页的Table-13到Table-22的定义表。注意最后两列：</p><p>Number of Error Code Correction Blocks ：需要分多少个块。</p><p>Error Correction Code Per Blocks：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。</p><p><img src="https://gss0.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=3ba9738196529822056631c5e7fa57f3/0b55b319ebc4b7453e23f850c9fc1e178b8215c4.jpg" alt=""></p><p>举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半）</p><p>对每个块的纠错码</p><p>1    1    67 85 70 134 87 38 85 194 119 50 6 18 6 103 38    213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39    </p><p>2    246 246 66 7 118 134 242 7 38 86 22 198 199 146 6    87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133    </p><p>2    1    182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7    148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141    </p><p>2    70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236    235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236    </p><p>注：二维码的纠错码主要是通过Reed-Solomon error correction（里 德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，最终编码。</p><p>穿插放置</p><p>二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下：</p><p>对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下：</p><p>块 1    67    85    70    134    87    38    85    194    119    50    6    18    6    103    38         </p><p>块 2    246    246    66    7    118    134    242    7    38    86    22    198    199    146    6         </p><p>块 3    182    230    247    119    50    7    118    134    87    38    82    6    134    151    50    7    </p><p>块 4    70    247    118    86    194    6    151    50    16    236    17    236    17    236    17    236    </p><p>我们先取第一列的：67， 246， 182， 70</p><p>然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247</p><p>如此类推：67， 246， 182， 70， 85，246，230 ，247 ………  ……… ，38，6，50，17，7，236</p><p>对于纠错码，也是一样：</p><p>块 1    213    199    11    45    115    247    241    223    229    248    154    117    154    111    86    161    111    39    </p><p>块 2    87    204    96    60    202    182    124    157    200    134    27    129    209    17    163    163    120    133    </p><p>块 3    148    116    177    212    76    133    75    242    238    76    195    230    189    10    108    240    192    141    </p><p>块 4    235    159    5    173    24    147    59    33    106    40    255    172    82    2    131    32    178    236    </p><p>和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236</p><p>然后，再把这两组放在一起（纠错码放在数据码之后）得到：</p><p>67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236</p><p>Remainder Bits</p><p>最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看QR Code Spec的第15页的Table-1的定义表。</p><p>4、画二维码图</p><p>Position Detection Pattern</p><p>首先，先把Position Detection图案画在三个角上。<br><img src="https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=02a423f4b4b7d0a27b9c0c9bfbdf5a31/63d0f703918fa0eca76a2b4b209759ee3c6ddbc3.jpg" alt=""></p><p>Alignment Pattern</p><p>然后，再把Alignment图案画上<br><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=fc08826f8018367aaddc77db1e43a7ec/c9fcc3cec3fdfc03de1cacfed23f8794a4c2260b.jpg" alt=""></p><p>关于Alignment的位置，可以查看QR Code Spec的第81页的Table-E.1的定义表（下表是不完全表格）<br><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=c27ff065652762d0806bacb990dc24c2/43a7d933c895d143c6d8ab6575f082025baf07cd.jpg" alt=""></p><p>下图是根据上述表格中的Version8的一个例子（6，24，42）<br><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=a44d40f1ef50352ab1342d0e6373d7ca/e824b899a9014c08f0b867e30c7b02087af4f4f1.jpg" alt=""></p><p>Timing Pattern</p><p>接下来是Timing Pattern的线（这个不用多说了）</p><p><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=a2c4794d5db5c9ea62a60be5e5099a38/8601a18b87d6277f08707d7e2e381f30e924fc12.jpg" alt=""></p><p>Format Information</p><p>再接下来是Formation Information，下图中的蓝色部分。</p><p><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=55f2d2a5fb1f4134e0620d78152fb9f2/d1a20cf431adcbef85e53140aaaf2edda2cc9fa7.jpg" alt=""></p><p>Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的）</p><p><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=94882b79dff9d72a1731181be41a040c/f9198618367adab4c42954058dd4b31c8601e4ff.jpg" alt=""></p><p>这15个bits中包括：</p><p>5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask</p><p>10个纠错bits。主要通过BCH Code来计算</p><p>然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别，以及000的Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。</p><p>下面是一个示例：</p><p>关于Error Correction Level如下表所示：</p><p>关于Mask图案如后面的Table 23所示。</p><p>Version Information</p><p>再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。</p><p>Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例：</p><p>而其填充位置如下：</p><p>数据和数据纠错码</p><p>然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。</p><p>5、掩码图案</p><p>这样下来，图就填好了，但是，也许那些点并不均衡，所以还要做Masking操作QR的Spec中说了，QR有8个 Mask可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进 行XOR，不会影响功能区。</p><p>其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y）</p><p><img src="https://gss0.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=600,800/sign=7ccde12649c2d562f25dd8ebd721bcd7/7acb0a46f21fbe09ae968c526d600c338644ada8.jpg" alt=""></p><p>Mask过后的二维码就成最终的图了。</p><p>（以上内容来源于网络）</p><h3 id="二、-编码实现"><a href="#二、-编码实现" class="headerlink" title="二、 编码实现"></a>二、 编码实现</h3><p>首先，我们需要下载Google的ZXing库。<br>下载地址：<a href="https://github.com/zxing/zxing">https://github.com/zxing/zxing</a></p><p>根据内容创建二维码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TODO 根据给定的内容生成二维码</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> content        二维码内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logoImagePath  logo图标的路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> needCompressed 是否需要压缩logo</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 生成的二维码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> WriterException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BufferedImage <span class="title">createImage</span><span class="params">(String content, String logoImagePath, <span class="keyword">boolean</span> needCompressed)</span> </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException, WriterException </span>&#123;</span><br><span class="line">       HashMap hints = <span class="keyword">new</span> HashMap&lt;EncodeHintType, Object&gt;();</span><br><span class="line">       hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);  <span class="comment">// 纠错等级</span></span><br><span class="line">       hints.put(EncodeHintType.CHARACTER_SET, CHARSET);</span><br><span class="line">       hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);  <span class="comment">// 二维码两边空白区域大小</span></span><br><span class="line">       BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints);</span><br><span class="line">       <span class="keyword">int</span> height = bitMatrix.getHeight();</span><br><span class="line">       <span class="keyword">int</span> width = bitMatrix.getWidth();</span><br><span class="line">       BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">               image.setRGB(x, y, bitMatrix.get(x, y) ? <span class="number">0xFF000000</span> : <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (logoImagePath == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(logoImagePath))</span><br><span class="line">           <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果有logo，则插入logo图片</span></span><br><span class="line">       QRCode.InsertImage(image, logoImagePath, needCompressed);</span><br><span class="line">       <span class="keyword">return</span> image;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>如果有logo则将logo插入到二维码中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TODO 插入logo图片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sourceImage 原图片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logoImagePath logo图片所在的路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> needCompressed 是否需要压缩</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertImage</span><span class="params">(BufferedImage sourceImage, String logoImagePath, <span class="keyword">boolean</span> needCompressed)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       File file = <span class="keyword">new</span> File(logoImagePath);</span><br><span class="line">       <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;logo文件不存在！\n&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Image src = ImageIO.read(file);</span><br><span class="line">       <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 压缩二维码图片</span></span><br><span class="line">       <span class="keyword">if</span> (needCompressed) &#123;</span><br><span class="line">           <span class="keyword">if</span> (width &gt; LOGO_WIDTH)</span><br><span class="line">               width = LOGO_WIDTH;</span><br><span class="line">           <span class="keyword">if</span> (height &gt; LOGO_HEIGHT)</span><br><span class="line">               height = LOGO_HEIGHT;</span><br><span class="line"></span><br><span class="line">           Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH);</span><br><span class="line">           BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">           Graphics g = tag.getGraphics();</span><br><span class="line">           g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">           g.dispose();  <span class="comment">// 释放占有的资源</span></span><br><span class="line">           src = image;</span><br><span class="line">           <span class="comment">// 直观的理解：Graphics2D 就相当于画笔，而BufferedImage 就是画笔绘制的结果。</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 插入logo</span></span><br><span class="line">       Graphics2D graph = sourceImage.createGraphics();</span><br><span class="line">       <span class="keyword">int</span> x = (QRCODE_SIZE - width) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> y = (QRCODE_SIZE - height) / <span class="number">2</span>;</span><br><span class="line">       graph.drawImage(src, x, y, width, height, <span class="keyword">null</span>);</span><br><span class="line">       Shape shape = <span class="keyword">new</span> RoundRectangle2D.Float(x, y, width, width, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">       graph.setStroke(<span class="keyword">new</span> BasicStroke(<span class="number">3f</span>));</span><br><span class="line">       graph.draw(shape);</span><br><span class="line">       graph.dispose();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>解码过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TODO 解析二维码内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 二维码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 二维码包含的信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       BufferedImage image;</span><br><span class="line">       image = ImageIO.read(file);</span><br><span class="line">       <span class="keyword">if</span> (image == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       BufferedImageLuminanceSource source = <span class="keyword">new</span> BufferedImageLuminanceSource(image);</span><br><span class="line">       BinaryBitmap bitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(source));</span><br><span class="line">       HashMap hints = <span class="keyword">new</span> HashMap&lt;DecodeHintType, Object&gt;();</span><br><span class="line">       hints.put(DecodeHintType.CHARACTER_SET, CHARSET);</span><br><span class="line">       Result result = <span class="keyword">new</span> MultiFormatReader().decode(bitmap, hints);</span><br><span class="line">       String resultStr = result.getText();</span><br><span class="line">       <span class="keyword">return</span> resultStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>测试结果<br><img src="https://upload-images.jianshu.io/upload_images/12649311-374caaf35a8835dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""><br>源码地址：<a href="https://github.com/Liyzy/ZXing-QRCode">https://github.com/Liyzy/ZXing-QRCode</a><br>开发环境：idea 2018.2</p><p><br/></p>]]></content>
    
    
    <summary type="html">今天突然想到二维码是如何存储信息的，手画二维码是否可行呢。于是就开始各种搜索，最终自己也利用Google的ZXing工具完成了一个生成二维码和解析二维码的简单程序。</summary>
    
    
    
    
    <category term="JAVA" scheme="https://wheliosc.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记3】继承&amp;多态篇</title>
    <link href="https://wheliosc.github.io/java-learning-3"/>
    <id>https://wheliosc.github.io/java-learning-3</id>
    <published>2018-08-06T05:36:10.024Z</published>
    <updated>2021-08-30T07:27:29.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol><li>关键字<code>extends</code>表示继承，继承是一个<code>is-a</code>关系，java中只有公有继承</li></ol><ol><li><p>覆盖方法（override）<br>将父类中的方法在子类中重新定义，以Employee类和Manager类为例，Manager继承Employee类，Employee有方法getSalary(); Manager类需要重写这个方法，加上经理所特有的奖金。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//return salary + bonus;  // 错误，不能访问超类的私有域</span></span><br><span class="line"><span class="comment">//return getSalary() + bonus;  // 错误，调用自身直至崩溃</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getSalary() + bonus;  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//super关键字表示调用父类的方法</span></span><br></pre></td></tr></table></figure></li><li><p>子类构造器<br>必须调用父类的构造器，并且应将这一过程放在程序的第一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, id, salary);  <span class="comment">// 置于第一句，如果没有这句，系统自动调用父类的默认构造函数；如果没有默认构造函数有没有显式调用其他构造器就会产生错误</span></span><br><span class="line">bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>java不支持多继承，即每一个类都只能继承最多一个类。但每一个类可以实现多个接口，这也是引入接口的一个考虑。</p></li></ol><ol><li>多态<br>java实现多态的两种方式：重载(overloading)和覆盖(override)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* override */</span></span><br><span class="line">Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;lihui&quot;</span>, <span class="number">201822</span>, <span class="number">50000</span>);</span><br><span class="line">boss.setBonus(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">Empolyee[] staff = <span class="keyword">new</span> Empolyee[<span class="number">2</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;chengle&quot;</span>, <span class="number">201833</span>, <span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">20000</span>);  <span class="comment">// 错误，staff声明为Employee类型，Employee没有setBonus方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">0</span>] <span class="keyword">instanceof</span> Manager)</span><br><span class="line">((Manager)staff[<span class="number">0</span>]).setBonus(<span class="number">20000</span>);  <span class="comment">// 正确，将staff[0]强制转换为Manager类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Employee aEmpolyee: staff)</span><br><span class="line">System.out.println(aEmpolyee.getName() + <span class="string">&quot; &quot;</span> + aEmpolyee.getSalary());</span><br><span class="line"><span class="comment">// aEmpolyee定义为Empolyee类型，但在执行的时候，aEmpolyee引用的Empolyee和Manager调用不同的getSalary函数</span></span><br><span class="line"><span class="comment">// 一个对象变量可以指示多种实际类型的现象称为多态。</span></span><br><span class="line"><span class="comment">// 在运行的时候自动选择调用哪个方法称为动态绑定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* overloading */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">(String name)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSalary</span><span class="params">(String name)</span></span>&#123;...&#125;  <span class="comment">//错误，已经存在getSalary(String name)方法,即签名相同，说明重载与返回值无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">(String name, String id)</span></span>&#123;...&#125;  <span class="comment">//正确的重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>方法的签名：方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。</p></blockquote><p>override的规则：</p><ul><li>子类覆盖父类中具有相同签名的方法。</li><li>返回类型是被重写方法的返回类型的子类型。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static、private、final的方法不能被重写。(private的方法本身就被定义成了final的)</li><li>构造器不能被重写。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li></ul><p>overloading的规则：<br>方法名相同，参数列表必须不同，返回值可同可不同，修饰符可同可不同。</p><ol><li><p>方法调用的过程<br>1）假设调用x.f(param), 编译器一一列举x所属类中的名为f的方法以及其父类中访问属性为public的名为f的方法（超类的私有方法不可访问）。<br>2）查看调用方法提供的参数类型。如果第一步中列举出的方法中有一个方法的参数列表与提供的参数类型完全匹配，就选择这个方法。如果没有找到与参数类型匹配的方法或者经过类型转换后有多个方法与之匹配，就会产生错误。<br>3）如果是static、private、final方法或者构造器，编译器可以准确的知道应该调用哪个方法，静态绑定。<br>4）动态绑定时，先查看子类中是否定义了这个方法，是则调用，否则调用父类的这个方法。</p></li><li><p>final修饰符<br>定义类的时候加上final修饰符表示类不允许被继承，其中的方法自动的成为final，但是域不会变成final。一个方法或者一个域也可以加上final表示不可被覆盖或者不可改变域的值。</p></li><li><p>抽象类<br>关键字<code>abstract</code>表示抽象类，包含有一个或多个抽象函数的类需要声明为抽象类（为了代码清晰），抽象类里的抽象方法不需要实现，在子类中对其进行实现。</p></li></ol><p><br/></p>]]></content>
    
    
    <summary type="html">java学习笔记的第三篇，内容主要有继承和多态</summary>
    
    
    
    
    <category term="JAVA" scheme="https://wheliosc.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记2】数组&amp;运算符&amp;权限篇</title>
    <link href="https://wheliosc.github.io/java-learning-2"/>
    <id>https://wheliosc.github.io/java-learning-2</id>
    <published>2018-07-08T09:53:51.036Z</published>
    <updated>2021-08-30T07:27:21.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><ol><li>数组</li><li>运算符</li><li>包</li><li>访问权限</li><li>修饰符</li></ol><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-数组的声明："><a href="#1-数组的声明：" class="headerlink" title="1. 数组的声明："></a>1. 数组的声明：</h4><p><code>int[] a;</code></p><h4 id="2-数组的创建"><a href="#2-数组的创建" class="headerlink" title="2. 数组的创建"></a>2. 数组的创建</h4><p>使用new运算符数组的创建<code>int[] a = new int[100]</code> 数组的长度不要求是常量：<code>new int[n]</code>会创建一个长度为n的数组</p><h4 id="3-数组的初始化"><a href="#3-数组的初始化" class="headerlink" title="3. 数组的初始化"></a>3. 数组的初始化</h4><p>可以使用for循环进行赋值，或者直接<code>int[] a = &#123;1, 2, 3&#125;</code>进行赋值；数组创建时，数字数组所有元素初始化为0，Boolean数组所有元素初始化为false，对象数组则初始化为null值。</p><h4 id="4-数组长度"><a href="#4-数组长度" class="headerlink" title="4. 数组长度"></a>4. 数组长度</h4><p>每一个数组都有成员属性length，使用<code>a.length</code>获得数组a的长度</p><h4 id="5-数组的遍历输出"><a href="#5-数组的遍历输出" class="headerlink" title="5. 数组的遍历输出"></a>5. 数组的遍历输出</h4><p> a. 传统for循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">    System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><br>b. for each循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.print(element + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//对于在for循环语句中需要使用元素下标的程序来说不合适</span></span><br></pre></td></tr></table></figure><br>c. 利用Arrays类的toString方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line"><span class="comment">//a为数值型的数组或Boolean数组</span></span><br></pre></td></tr></table></figure></p><h4 id="6-数组拷贝"><a href="#6-数组拷贝" class="headerlink" title="6. 数组拷贝"></a>6. 数组拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = a;  <span class="comment">//b和a引用同一个数组</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">7</span>;  <span class="comment">//此时访问a[1]也是7</span></span><br></pre></td></tr></table></figure><p>如果希望把一个数组的所有值拷贝到一个新的数组,使用Arrays类的copyOf方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = Arrays.copyOf(a, a.length);</span><br></pre></td></tr></table></figure><br>第二个参数表示新数组的长度，比原数组长，则多余的元素被赋值为0或者false或者null，比原数组短，则只复制前面的对应长度的元素。<br>方法<code>Arrays.copyOfRange(type[] a, int start, int end)</code><br>type为int, short, byte, long, double, float, Boolean 类型</p><h4 id="7-数组排序"><a href="#7-数组排序" class="headerlink" title="7. 数组排序"></a>7. 数组排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);  <span class="comment">//使用优化的快速排序</span></span><br></pre></td></tr></table></figure><h4 id="8-多维数组"><a href="#8-多维数组" class="headerlink" title="8. 多维数组"></a>8. 多维数组</h4><p>多维数组创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">//正确, 第二维的长度可以动态申请，可以不同</span></span><br><span class="line"><span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[][<span class="number">3</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><br>多维数组遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">    b[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].length; j++)</span><br><span class="line">    b[i][j] = i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length)</span><br><span class="line">System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : b)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : row)</span><br><span class="line">        System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line">System.out.println(Arrays.deepToString(b));</span><br></pre></td></tr></table></figure><br>多维数组的每一行是可以通过引用进行交换的。</p><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">12.3f</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a / <span class="number">0</span>;  <span class="comment">//得到Infinity或者NaN</span></span><br><span class="line">b = b / <span class="number">0</span>;  <span class="comment">//除零异常</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><h4 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">5</span>;</span><br><span class="line">a = a % <span class="number">3</span>;</span><br><span class="line">b = b % <span class="number">3</span>;</span><br><span class="line">System.out.println(a + <span class="string">&quot;,&quot;</span> + b);  <span class="comment">//2,-2</span></span><br><span class="line">a = a % -<span class="number">3</span>;</span><br><span class="line">b = b % -<span class="number">3</span>;</span><br><span class="line">System.out.print(a + <span class="string">&quot;,&quot;</span> + b);  <span class="comment">//2,-2</span></span><br><span class="line"><span class="comment">/*求模运算的结果与左操作数符号相同，与右操作数符号无关*/</span></span><br></pre></td></tr></table></figure><h4 id="算术运算的结果不低于int型"><a href="#算术运算的结果不低于int型" class="headerlink" title="算术运算的结果不低于int型"></a>算术运算的结果不低于int型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">b = a + b;  <span class="comment">//错误，a+b返回int型，int不能赋值给byte</span></span><br><span class="line">b = (<span class="keyword">byte</span>)(a + b);  <span class="comment">//正确，强制转换</span></span><br><span class="line">b += a; <span class="comment">//正确，b += a等价于b = (byte)(b + a)</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">7</span>;</span><br><span class="line">c = c + <span class="number">5.2</span>; <span class="comment">//错误</span></span><br><span class="line">c += <span class="number">5.2</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006xwwY9ly1g0u9mixwtmj32mh1lpk4u.jpg" alt=""><br>虚箭头表示可能有精度损失的转换，实箭头表示无信息丢失的转换。</p><p>基本数据类型的数组之间不能相互赋值，因为java中数组是类。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p><strong>&lt;&lt;</strong>左移，低位补0，移位中可能会出现符号变换<br><strong>&gt;&gt;</strong>右移，高位补符号位<br><strong>&gt;&gt;&gt;</strong>无符号右移，高位补0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// a &gt;&gt; 33等价于a &gt;&gt; 1，移的位数和数值类型的位数取模</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// b &gt;&gt; 33等价于b &gt;&gt; 1,在b &gt;&gt; 33操作中，b自动提升为int型</span></span><br></pre></td></tr></table></figure><br><strong>~</strong>位反运算，每一位取反</p><h4 id="位逻辑运算"><a href="#位逻辑运算" class="headerlink" title="位逻辑运算"></a>位逻辑运算</h4><p>位逻辑运算优先级  <strong>&amp; ^  |</strong></p><h4 id="三目运算符？：的第二第三操作数必须是可以赋值的"><a href="#三目运算符？：的第二第三操作数必须是可以赋值的" class="headerlink" title="三目运算符？：的第二第三操作数必须是可以赋值的"></a>三目运算符？：的第二第三操作数必须是可以赋值的</h4><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>一个类可以使用所属包中所有的类，以及其他包中的公有类。<br>访问其他包中公有类的两种方式：在每个类前添加完整的包名；使用import语句(放在源文件的顶部，package语句的后面)。<br>package语句对整个源文件有效，即同一个源文件里的所有类都属于这个包。</p><hr><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//public</span><br><span class="line">//private</span><br><span class="line">//protected</span><br><span class="line">//没有指定则为同包可访问</span><br></pre></td></tr></table></figure><hr><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>static 静态修饰符<br>final 常量修饰符，也可以表示一个类不允许继承<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">i = <span class="number">3</span>; <span class="comment">//错误，i只有在new了一个对象后才会存在</span></span><br><span class="line">j = <span class="number">7</span>; <span class="comment">//正确，j是静态的，不需要创建对象就存在</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.i = <span class="number">3</span>; <span class="comment">//正确</span></span><br><span class="line">A.i = <span class="number">3</span>; <span class="comment">//错误</span></span><br><span class="line">A.j = <span class="number">4</span>; <span class="comment">//正确，j是所有的A类对象所共有的，所以可以通过类名来访问</span></span><br><span class="line">a.j = <span class="number">4</span>; <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br/></p>]]></content>
    
    
    <summary type="html">java学习笔记的第二篇，内容主要有数组、运算符、权限、修饰符等</summary>
    
    
    
    
    <category term="JAVA" scheme="https://wheliosc.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Gitee(码云)、Github同时配置ssh key</title>
    <link href="https://wheliosc.github.io/github-gitee-ssh-key"/>
    <id>https://wheliosc.github.io/github-gitee-ssh-key</id>
    <published>2018-07-06T13:25:17.666Z</published>
    <updated>2021-08-30T07:52:12.917Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h4 id="一、到-ssh文件夹下"><a href="#一、到-ssh文件夹下" class="headerlink" title="一、到.ssh文件夹下"></a>一、到.ssh文件夹下</h4><p><code>cd ~/.ssh</code></p><h4 id="二、通过下面的命令，依次生成两个平台的key"><a href="#二、通过下面的命令，依次生成两个平台的key" class="headerlink" title="二、通过下面的命令，依次生成两个平台的key"></a>二、通过下面的命令，依次生成两个平台的key</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot;</span><br></pre></td></tr></table></figure><p>完成后，.ssh文件夹生成以下文件<br><img src="https://wx3.sinaimg.cn/large/006xwwY9ly1g0ualq3nxuj30kg033jr8.jpg" alt=""></p><h4 id="三、把public-key复制到gitee和github"><a href="#三、把public-key复制到gitee和github" class="headerlink" title="三、把public key复制到gitee和github"></a>三、把public key复制到gitee和github</h4><p>执行命令<code>cat github_id_rsa.pub</code>把第二行到结尾的内容复制到github的ssh中保存<br><img src="https://wx2.sinaimg.cn/large/006xwwY9ly1g0uan4yjx4j30k102yq2x.jpg" alt=""></p><p>同样的操作，添加gitee的ssh</p><h4 id="四、创建config文件解决ssh冲突"><a href="#四、创建config文件解决ssh冲突" class="headerlink" title="四、创建config文件解决ssh冲突"></a>四、创建config文件解决ssh冲突</h4><p>在.ssh文件夹下执行命令<code>vi config</code><br>文件中添加以下内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></p><h4 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h4><p>执行<br><code>ssh -T git@github.com</code><br>成功则返回<br><code>Welcome to Gitee.com ,yourname!</code><br>执行<br><code>ssh -T git@gitee.com</code><br>成功则返回<br><code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><p><br/></p>]]></content>
    
    
    <summary type="html">最先接触的是GitHub，后来接触了中文的Gitee(码云)。那么怎么在同一个电脑上同时配置ssh key，将项目同时上传到两个平台上呢？</summary>
    
    
    
    
    <category term="SSH" scheme="https://wheliosc.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>【java学习笔记1】数据类型&amp;函数篇</title>
    <link href="https://wheliosc.github.io/java-learning-1"/>
    <id>https://wheliosc.github.io/java-learning-1</id>
    <published>2018-07-03T11:30:01.284Z</published>
    <updated>2021-08-30T07:27:16.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><p></p><br><span id="more"></span></p><ol><li>Java简单介绍</li><li>第一个程序Hello World</li><li>基本数据类型</li><li>对象和类</li><li>数据声明</li><li>函数声明</li><li>参数传递</li></ol><hr><h3 id="Java简单介绍"><a href="#Java简单介绍" class="headerlink" title="Java简单介绍"></a>Java简单介绍</h3><ol><li>Java的优点：简单、可移植性</li><li>JDK (Java Development Kit)  Java开发工具包</li><li>JRE (Java Runtime Environment) Java运行环境<br> 只要具有JRE，就可以运行Java代码，而与操作系统的类别无关</li><li>安装完JDK后，在电脑“编辑系统环境变量”—-“环境变量”选项下，系统变量新建 变量名 JAVA_HONE 变量值 D:\Program Files\java\jdk-10.0.1(这是我的JDK位置)      系统变量找到Path变量，编辑新建D:\Program Files\java\jdk-10.0.1\bin<br>之后在cmd 中测试命令 Java 和 Javac ，有东西输出之后就可以用Javac在cmd里编译Java程序了(生成.class文件)，用Java [option] [主类名]就可以运行程序了(java HelloWorld  而不是 java HelloWorld.class)。</li></ol><h3 id="第一个程序-Hello-World"><a href="#第一个程序-Hello-World" class="headerlink" title="第一个程序 Hello World"></a>第一个程序 Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Java区分大小写，参数中的String的S必须大写。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>char<br>boolean<br>byte, short, int, long, float, double</p><h4 id="char-字符型"><a href="#char-字符型" class="headerlink" title="char(字符型)"></a>char(字符型)</h4><blockquote><p>首先补充编码的知识<br><strong><em>ASCII码</em></strong>(美国信息交换标准代码，7-bits ASCII码) 七位码，共128个字符，它主要用于显示现代英语和其他西欧语言。<br><strong><em>GB2312</em></strong>，是中国国家标准的简体中文字符集，双字节字符集。<br><strong><em>GBK</em></strong>，GBK字符集主要扩展了繁体中文字的支持，双字节字符集。<br><strong><em>GB18030</em></strong>,GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。<br>单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。<br>双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。<br>四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。<br>按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集(DBCS)。<br><strong><em>Unicode</em></strong>(万国码、统一码、单一码)，16位，也就是两个字节代表一个字符。<br><strong><em>UTF-8</em></strong>是一种8位的unicode字符集，编码长度是可变的，并且是ASCII字符集的严格超集，也就是说ASCII中每个字符的编码在UTF-8中是完全一样的。UTF-8字符集中，一个字符可能是1个字节，2个字节，3个字节或者4个字节长。一般来说，欧洲的字母字符长度为1到2个字节，而亚洲的大部分字符则是3个字节，附加字符为4个字节长。<br>更多关于编码参考文章<a href="http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html">http://blog.sina.com.cn/s/blog_4b4409c30100vw9t.html</a></p></blockquote><p>在Java中采用Unicode编码，所以<br><code>char a = &#39;a&#39;;</code> 和 <code>char b = &#39;中&#39;</code>一样都占两个字节(区别于C和C++)<br><code>char c = &#39;\u21fa&#39;</code>表示转义字符，格式为\u加上4位16进制数</p><h4 id="boolean-布尔型"><a href="#boolean-布尔型" class="headerlink" title="boolean(布尔型)"></a>boolean(布尔型)</h4><p>只有true 和 false 两个值，区别于C和C++。<br>在C和C++中，bool类型可以用数字赋值，非零即为真，零为假。但在Java中只有<code>boolean flag = true;</code> 和 <code>boolean flag = false;</code></p><h4 id="byte-short-int-long-float-double-数值型"><a href="#byte-short-int-long-float-double-数值型" class="headerlink" title="byte, short, int, long, float, double(数值型)"></a>byte, short, int, long, float, double(数值型)</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">存储要求</th><th style="text-align:left">取值范围</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">1字节</td><td style="text-align:left">-128~127</td><td></td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">2字节</td><td style="text-align:left">-32768~32767</td><td></td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">4字节</td><td style="text-align:left">超过21亿</td><td></td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">8字节</td><td style="text-align:left">很大很大</td><td>需要在数值后加后缀L</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">4字节</td><td style="text-align:left">大约为±3.402E+38</td><td>需要在数值后加后缀F，有效位6~7位</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">8字节</td><td style="text-align:left">大约为±1.797E+308</td><td>需要在数值后加后缀D，有效位15位</td></tr></tbody></table></div><p>float和double类型表示的的数值是离散的，可能有一些小数就是无法表示，只能为近似值。不加F后缀的浮点数值默认为double类型。<br>float和double不能做移位运算。整形移位运算相当于除或乘2的移的位数的次幂。-1在计算机中存储形式为全一，无论移多少位都不变。</p><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>对象(哎)是现实世界中的一个实体。<br>类是具有相同特征的对象的属性的集合。</p><h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>][修饰符<span class="number">2</span>][修饰符...]<span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">//类内的变量可以不用定义时赋值，数值变量系统默认赋值为零；逻辑变量boolean默认为false</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">float</span>[] f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//函数内的变量随手赋值是个好习惯，不赋值的话，在内存中是暂时没有这个变量的</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类实例化为对象"><a href="#类实例化为对象" class="headerlink" title="类实例化为对象"></a>类实例化为对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s1;</span><br><span class="line"><span class="comment">//一个对象变量没有实际包含一个对象，而仅仅是引用一个对象。</span></span><br><span class="line"><span class="comment">//new操作符返回的也是一个引用，即这个对象的存储地址。</span></span><br><span class="line"><span class="comment">//上面代码中的s2 = s1;仅仅是把s1保存的引用复制一份给s2，并没有复制这个对象</span></span><br><span class="line"><span class="comment">//可以将一个对象变量赋值为null，表明这个对象变量目前没有引用任何的对象</span></span><br><span class="line"><span class="comment">//如果一个对象没有任何的对象变量引用它，那么这个对象就成为垃圾对象，会被系统自动清理</span></span><br><span class="line"><span class="comment">//例如上面代码，如果添加s1 = null;那么这个对象不是垃圾对象，因为还有s2引用(指向)它。</span></span><br></pre></td></tr></table></figure><h3 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h3><p>没什么好说的。<code>[变量类型] [变量名] = [初始值];</code><br>说一些命名的规则和习惯吧(提高代码可读性)。    </p><blockquote><p>a. 必须是字母开头的由字母、数字、下划线组成的序列，区分大小写。虽然在命名可以使用$，但是不要使用。<br> b. 类名使用 UpperCamelCase(大驼峰) 风格，即每个单词首字母都要大写。<br> c. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase(小驼峰) 风格，即从第二个单词开始首字母大写。如：studentName<br> d. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br> e. 杜绝完全不规范的缩写， 避免望文不知义。<br> …</p></blockquote><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>][修饰符<span class="number">2</span>][修饰符..] [函数返回值] [函数名](参数<span class="number">1</span>，参数<span class="number">2</span>，参数..) &#123;函数体&#125;</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong><em>Java的函数参数传递只有一种方法：传值(call by value)</em></strong><br>java 成员变量(成员变量就是方法外部，类的内部定义的变量)存储在堆中的对象里面;局部变量就是方法或语句块内部定义的变量,局部变量必须初始化,局部变量的数据存在于栈内存中,栈内存中的局部变量随着方法的结束而出栈。</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rank;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap1</span><span class="params">(Card c1,Card c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Card temp = c1;</span><br><span class="line">c1 = c2;</span><br><span class="line">c2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap2</span><span class="params">(Card c1,Card c2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = c1.rank;</span><br><span class="line">c1.rank = c2.rank;</span><br><span class="line">c2.rank = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Card c1 = <span class="keyword">new</span> Card();</span><br><span class="line">    c1.rank = <span class="number">5</span>;</span><br><span class="line">    Card c2 = <span class="keyword">new</span> Card();</span><br><span class="line">    c2.rank = <span class="number">6</span>;</span><br><span class="line">    swap1(c1,c2);</span><br><span class="line">    swap2(c1,c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果是swap1并没有实现数值交换；swap2实现了数值的变换。<br>分析：在main函数中，首先生成两个对象存储在堆中，并有引用变量c1,c2分别指向两个对象。在调用swap1，main函数的栈空间里<strong><em>复制</em></strong>c1,c2传递给函数，在函数中一波操作猛如虎，两个复制品的指向对象互换，然后函数结束，两个复制品出栈，然而原c1和c2的指向并没有改变。在swap2里，改的直接是存储在堆里的对象的变量，指向没有变化，但是内部的数值已经交换了。</p><p><br/></p>]]></content>
    
    
    <summary type="html">java学习笔记的第一篇，内容主要有数据结构、函数等</summary>
    
    
    
    
    <category term="JAVA" scheme="https://wheliosc.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计范式</title>
    <link href="https://wheliosc.github.io/database-design-paradigm"/>
    <id>https://wheliosc.github.io/database-design-paradigm</id>
    <published>2018-06-27T06:40:33.845Z</published>
    <updated>2021-08-30T07:30:11.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1.第一范式(1NF)"></a>1.第一范式(1NF)</h3><blockquote><p>定义：如果关系模式R的所有属性的域都是原子的，那么称关系模式R属于第一范式。</p></blockquote><p>通俗的讲，第一范式就是属性不可再分。比如地址属性，可以再分为省、市、县等属性，所以在这种情况下，地址属性所在的关系模式就不符合第一范式。</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2.第二范式(2NF)"></a>2.第二范式(2NF)</h3><blockquote><p>定义：若R满足第一范式，且每一个非主属性完全函数依赖于主码，则R满足第二范式。</p></blockquote><p>这里首先补充函数依赖的知识</p><h4 id="平凡依赖和非平凡依赖"><a href="#平凡依赖和非平凡依赖" class="headerlink" title="平凡依赖和非平凡依赖"></a>平凡依赖和非平凡依赖</h4><p>如果A-&gt;B，A是B的超集，则称此函数依赖为平凡的。<br>🌰：A-&gt;A   AB-&gt;A    ABC-&gt;AB都是平凡依赖（此处的A、B、C为原子属性）<br>非平凡依赖就是不包含自己或包含自己的集决定自己的函数依赖。</p><h4 id="完全依赖和部分依赖"><a href="#完全依赖和部分依赖" class="headerlink" title="完全依赖和部分依赖"></a>完全依赖和部分依赖</h4><p>函数依赖A-&gt;B称为部分依赖的条件是存在A的真子集C使得C-&gt;B。即A中的一部分就可以决定B，不需要所有的属性来决定B。<br>反之，需要A中所有的属性才能来决定B，缺一不可，那么A-&gt;B就是一个完全依赖。</p><h4 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a>传递依赖</h4><p>如果A、B是两个属性集，存在A-&gt;B，如果c是一个属性，并且c不属于A或B，并且存在B-&gt;c，那么c就传递依赖于A。</p><p>根据2NF的定义，我们可以知道，单属性主键的关系模式一定符合第二范式。</p><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3.第三范式(3NF)"></a>3.第三范式(3NF)</h3><blockquote><p>定义：对于F*(F的闭包)中所有形如A-&gt;B的函数依赖（其中A、B都包含于R），以下至少一项成立：<br>    · A-&gt;B是一个平凡的函数依赖<br>    · A是R的一个超码<br>    · B-A中的每个属性c都包含于R的一个候选码中</p></blockquote><p>简单的说，若R满足第二范式，且每一个非主属性都不传递函数依赖于主码，则R满足第三范式。<br>即不存在如下依赖关系：<br>　　 关键字段 → 非关键字段x → 非关键字段y<br>🌰假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字”学号”，因为存在如下决定关系：<br>　　 (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)<br>　　 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：<br>　　 (学号) → (所在学院) → (学院地点, 学院电话)<br>　　 即存在非关键字段”学院地点”、”学院电话”对关键字段”学号”的传递函数依赖。</p><h3 id="4-BC范式-BCNF"><a href="#4-BC范式-BCNF" class="headerlink" title="4.BC范式(BCNF)"></a>4.BC范式(BCNF)</h3><blockquote><p>定义：若R满足第三范式，且每一个主属性都不部分函数依赖或传递函数依赖于主码，则R满足第三范式。<br>· 每一个决定属性集（因素）都包含（候选）码<br>· R中的所有属性（主，非主属性）都完全函数依赖于码</p></blockquote><p>🌰假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：<br>　　 (仓库ID, 存储物品ID) →(管理员ID, 数量)<br>　　 (管理员ID, 存储物品ID) → (仓库ID, 数量)<br>　　 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：<br>　　 (仓库ID) → (管理员ID)<br>　　 (管理员ID) → (仓库ID)  即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。</p><p>3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。</p><h3 id="BCNF分解算法"><a href="#BCNF分解算法" class="headerlink" title="BCNF分解算法"></a>BCNF分解算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(有违反BCNF的函数依赖)</span><br><span class="line">&#123;</span><br><span class="line">    找出违反BCNF的函数依赖A-&gt;B；</span><br><span class="line">    先计算A的闭包，且用A的闭包(除去A)替换B，并将其分解为&#123;A+&#125;和&#123;<span class="built_in">AU</span>(R-(A+)&#125;;   <span class="comment">//比如A-&gt;B ，而&#123;A&#125;+=&#123;A,B,C&#125;，则用A-&gt;BC替换A-&gt;B;</span></span><br><span class="line">    求出分解后的关系满足的投影FD集合；</span><br><span class="line">    再看分解后的关系的FD集合是否满足BCNF，如果不满足，则继续分解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🌰<br><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/BCNF%E8%8C%83%E5%BC%8F.jpg" alt=""></p><h3 id="3NF分解算法"><a href="#3NF分解算法" class="headerlink" title="3NF分解算法"></a>3NF分解算法</h3><p><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/3NF-1.jpg" alt=""></p><p><img src="https://liyzy.oss-cn-hangzhou.aliyuncs.com/image/3NF-2.GIF" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/xiazdong/article/details/7517438">分解算法参考博客</a></p><p><br/></p>]]></content>
    
    
    <summary type="html">学习数据库，个人感觉设计范式是比较重要也是比较难的一部分，于是自己做了一些总结</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库练习题(基础)</title>
    <link href="https://wheliosc.github.io/database-prictise"/>
    <id>https://wheliosc.github.io/database-prictise</id>
    <published>2018-06-13T03:32:31.969Z</published>
    <updated>2021-08-30T07:29:49.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><h4 id="一、基本表的定义与删除"><a href="#一、基本表的定义与删除" class="headerlink" title="一、基本表的定义与删除"></a>一、基本表的定义与删除</h4><p>T1.<br>用SQL语句创建如下三张表：学生（Student）,课程表（Course）,和学生选课表（SC）,这三张表的结构如表1-1到表1-3所示。<br>表1-1 Student表结构</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th><th>数据类型</th><th style="text-align:left">约束</th></tr></thead><tbody><tr><td style="text-align:left">Sno</td><td style="text-align:left">学号</td><td>字符串</td><td style="text-align:left">长度为7，主码</td></tr><tr><td style="text-align:left">Sname</td><td style="text-align:left">姓名</td><td>字符串</td><td style="text-align:left">长度为10，非空</td></tr><tr><td style="text-align:left">Ssex</td><td style="text-align:left">性别</td><td>字符串</td><td style="text-align:left">长度为2，取‘男’或‘女’</td></tr><tr><td style="text-align:left">Sage</td><td style="text-align:left">年龄</td><td>整数</td><td style="text-align:left">取值15~45</td></tr><tr><td style="text-align:left">Sdept</td><td style="text-align:left">所在系</td><td>字符串</td><td style="text-align:left">长度为20    默认为‘计算机系’</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">Sno <span class="type">varchar</span>(<span class="number">7</span>) <span class="keyword">primary</span> key,</span><br><span class="line">Sname <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Ssex <span class="type">varchar</span>(<span class="number">2</span>) <span class="keyword">check</span>(Ssex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">or</span> Ssex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">Sage <span class="type">int</span> <span class="keyword">check</span>(Sage<span class="operator">&gt;=</span><span class="number">15</span> <span class="keyword">and</span> Sage <span class="operator">&lt;=</span><span class="number">45</span>),</span><br><span class="line">Sdept <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span>(<span class="string">&#x27;计算机系&#x27;</span>));</span><br></pre></td></tr></table></figure><p>表1-2Course表结构</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th><th>数据类型</th><th style="text-align:left">约束</th></tr></thead><tbody><tr><td style="text-align:left">Cno</td><td style="text-align:left">课程号</td><td>字符串</td><td style="text-align:left">长度为10，主码</td></tr><tr><td style="text-align:left">Cname</td><td style="text-align:left">课程名</td><td>字符串</td><td style="text-align:left">长度为20，非空</td></tr><tr><td style="text-align:left">Ccredit</td><td style="text-align:left">学分</td><td>整数</td><td style="text-align:left">取值大于0</td></tr><tr><td style="text-align:left">Semster</td><td style="text-align:left">学期</td><td>整数</td><td style="text-align:left">取值大于0</td></tr><tr><td style="text-align:left">Cperiod</td><td style="text-align:left">学时</td><td>整数</td><td style="text-align:left">取值大于0</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(</span><br><span class="line">Cno <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">Cname <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Ccredit <span class="type">int</span> <span class="keyword">check</span>(Ccredit<span class="operator">&gt;</span><span class="number">0</span>),</span><br><span class="line">Semster <span class="type">int</span> <span class="keyword">check</span>(Semster <span class="operator">&gt;</span><span class="number">0</span>),</span><br><span class="line">Cperiodint <span class="keyword">check</span>(Cperiod<span class="operator">&gt;</span><span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表1-3 SC表结构<br>表1-2Course表结构</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th><th>数据类型</th><th style="text-align:left">约束</th></tr></thead><tbody><tr><td style="text-align:left">Sno</td><td style="text-align:left">学号</td><td>字符串</td><td style="text-align:left">长度为7，主码，参照Student的外码</td></tr><tr><td style="text-align:left">Cno</td><td style="text-align:left">课程名</td><td>字符串</td><td style="text-align:left">长度为10，主码，参照Course</td></tr><tr><td style="text-align:left">Grade</td><td style="text-align:left">成绩</td><td>整数</td><td style="text-align:left">取值0~100</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">Sno <span class="type">varchar</span>(<span class="number">7</span>),</span><br><span class="line">Cno <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">Grade <span class="type">int</span> <span class="keyword">check</span>(Grade <span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">and</span> Grade <span class="operator">&lt;=</span><span class="number">100</span>),</span><br><span class="line"><span class="keyword">primary</span> key(Sno,Cno),</span><br><span class="line"><span class="keyword">foreign</span> key (Sno) <span class="keyword">references</span> Student(Sno),</span><br><span class="line"><span class="keyword">foreign</span> key (Cno) <span class="keyword">references</span> Course(Cno));</span><br></pre></td></tr></table></figure><p>PS:<br>外码(键): 一个关系模式(r1)可能在它的属性中包含另一个关系模式(r2)的主码,这个属性在r1上称作参照r2的外码。关系r1称为外码依赖的参照关系，关系r2称为外码的被参照关系。FK一定来自另一个表的PK，FK是PK的子集。</p><p>如果外键或者主键要求命名，请使用以下语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> pk_Student_Sno <span class="keyword">primary</span> key (Sno)</span><br><span class="line"><span class="keyword">constraint</span> fk_Student_Sno <span class="keyword">foreign</span> key (Sno) <span class="keyword">references</span> Student(Sno)<span class="operator">/</span><span class="operator">/</span>SC表，参照表后边的属性可以省略</span><br></pre></td></tr></table></figure><br>已有表，添加外键</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SC</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_Student_Sno </span><br><span class="line"><span class="keyword">foreign</span> key (Sno) </span><br><span class="line"><span class="keyword">references</span> Student(Sno);</span><br></pre></td></tr></table></figure></h2><h4 id="二、修改表结构"><a href="#二、修改表结构" class="headerlink" title="二、修改表结构"></a>二、修改表结构</h4><p>T2.<br>为SC表添加“选课类别”列，此列的定义为XKLB char(4)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table SC add XKLB char(4);</span><br></pre></td></tr></table></figure><p>T3.<br>将新添加的XKLB的类型修改为char(6)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table SC alter column XKLB char(6);</span><br></pre></td></tr></table></figure><br>T4.<br>删除Course表的Cperiod列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Course <span class="keyword">drop</span> <span class="keyword">column</span> Cperiod;</span><br></pre></td></tr></table></figure><br>T5.<br>重命名Student表的Ssex列为sex</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_rename <span class="string">&#x27;Student.Ssex&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>;</span><br></pre></td></tr></table></figure></h2><h4 id="三、数据查询功能"><a href="#三、数据查询功能" class="headerlink" title="三、数据查询功能"></a>三、数据查询功能</h4><p>表3-1 Student表数据</p><div class="table-container"><table><thead><tr><th style="text-align:left">Sno</th><th style="text-align:left">Sname</th><th style="text-align:left">Ssex</th><th style="text-align:left">Sage</th><th style="text-align:left">Sdept</th></tr></thead><tbody><tr><td style="text-align:left">9512101</td><td style="text-align:left">李勇</td><td style="text-align:left">男</td><td style="text-align:left">19</td><td style="text-align:left">计算机系</td></tr><tr><td style="text-align:left">9512102</td><td style="text-align:left">刘晨</td><td style="text-align:left">男</td><td style="text-align:left">20</td><td style="text-align:left">计算机系</td></tr><tr><td style="text-align:left">9512103</td><td style="text-align:left">王敏</td><td style="text-align:left">女</td><td style="text-align:left">20</td><td style="text-align:left">计算机系</td></tr><tr><td style="text-align:left">9521101</td><td style="text-align:left">张立</td><td style="text-align:left">男</td><td style="text-align:left">22</td><td style="text-align:left">信息系</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">吴宾</td><td style="text-align:left">女</td><td style="text-align:left">21</td><td style="text-align:left">信息系</td></tr><tr><td style="text-align:left">9521103</td><td style="text-align:left">张海</td><td style="text-align:left">男</td><td style="text-align:left">20</td><td style="text-align:left">信息系</td></tr><tr><td style="text-align:left">9531101</td><td style="text-align:left">钱小平</td><td style="text-align:left">女</td><td style="text-align:left">18</td><td style="text-align:left">数学系</td></tr><tr><td style="text-align:left">9531102</td><td style="text-align:left">王大力</td><td style="text-align:left">男</td><td style="text-align:left">19</td><td style="text-align:left">数学系</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;9512101&#x27;</span>,<span class="string">&#x27;李勇&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;计算机系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9512102&#x27;</span>,<span class="string">&#x27;刘晨&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;计算机系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9512103&#x27;</span>,<span class="string">&#x27;王敏&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;计算机系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521101&#x27;</span>,<span class="string">&#x27;张立&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;信息系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521102&#x27;</span>,<span class="string">&#x27;吴宾&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;信息系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521103&#x27;</span>,<span class="string">&#x27;张海&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;信息系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9531101&#x27;</span>,<span class="string">&#x27;钱小平&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;数学系&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9531102&#x27;</span>,<span class="string">&#x27;王大力&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;数学系&#x27;</span>);</span><br></pre></td></tr></table></figure><p>表3-2 Course表数据</p><div class="table-container"><table><thead><tr><th style="text-align:left">Cno</th><th style="text-align:left">Cname</th><th style="text-align:left">Ccredit</th><th style="text-align:left">Semster</th></tr></thead><tbody><tr><td style="text-align:left">C01</td><td style="text-align:left">计算机文化学</td><td style="text-align:left">3</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">C02</td><td style="text-align:left">VB</td><td style="text-align:left">2</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">C03</td><td style="text-align:left">计算机网络</td><td style="text-align:left">4</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">C04</td><td style="text-align:left">数据库基础</td><td style="text-align:left">6</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">C05</td><td style="text-align:left">高等数学</td><td style="text-align:left">8</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">C06</td><td style="text-align:left">数据结构</td><td style="text-align:left">5</td><td style="text-align:left">4</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course(Cno,Cname,Ccredit,Semster)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;C01&#x27;</span>,<span class="string">&#x27;计算机文化学&#x27;</span>,<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;C02&#x27;</span>,<span class="string">&#x27;VB&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;C03&#x27;</span>,<span class="string">&#x27;计算机网络&#x27;</span>,<span class="number">4</span>,<span class="number">7</span>),</span><br><span class="line">(<span class="string">&#x27;C04&#x27;</span>,<span class="string">&#x27;数据库基础&#x27;</span>,<span class="number">6</span>,<span class="number">6</span>),</span><br><span class="line">(<span class="string">&#x27;C05&#x27;</span>,<span class="string">&#x27;高等数学&#x27;</span>,<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;C06&#x27;</span>,<span class="string">&#x27;数据结构&#x27;</span>,<span class="number">5</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>表 3-3 SC表数据</p><div class="table-container"><table><thead><tr><th style="text-align:left">Sno</th><th style="text-align:left">Cno</th><th style="text-align:left">Grade</th><th style="text-align:left">XKLB</th></tr></thead><tbody><tr><td style="text-align:left">9512101</td><td style="text-align:left">c01</td><td style="text-align:left">90</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9512101</td><td style="text-align:left">c02</td><td style="text-align:left">86</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9512101</td><td style="text-align:left">c06</td><td style="text-align:left"><NULL></td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9512102</td><td style="text-align:left">c02</td><td style="text-align:left">78</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9512102</td><td style="text-align:left">c04</td><td style="text-align:left">66</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c01</td><td style="text-align:left">82</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c02</td><td style="text-align:left">75</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c04</td><td style="text-align:left">92</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9521102</td><td style="text-align:left">c05</td><td style="text-align:left">50</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9521103</td><td style="text-align:left">c02</td><td style="text-align:left">68</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9521103</td><td style="text-align:left">c06</td><td style="text-align:left"><NULL></td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9531101</td><td style="text-align:left">c01</td><td style="text-align:left">80</td><td style="text-align:left">选修</td></tr><tr><td style="text-align:left">9531101</td><td style="text-align:left">c05</td><td style="text-align:left">95</td><td style="text-align:left">必修</td></tr><tr><td style="text-align:left">9531102</td><td style="text-align:left">c05</td><td style="text-align:left">85</td><td style="text-align:left">必修</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC </span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;9512101&#x27;</span>,<span class="string">&#x27;c01&#x27;</span>,<span class="number">90</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9512101&#x27;</span>,<span class="string">&#x27;c02&#x27;</span>,<span class="number">86</span>,<span class="string">&#x27;选修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9512101&#x27;</span>,<span class="string">&#x27;c06&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9512102&#x27;</span>,<span class="string">&#x27;c02&#x27;</span>,<span class="number">78</span>,<span class="string">&#x27;选修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9512102&#x27;</span>,<span class="string">&#x27;c04&#x27;</span>,<span class="number">66</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521102&#x27;</span>,<span class="string">&#x27;c01&#x27;</span>,<span class="number">82</span>,<span class="string">&#x27;选修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521102&#x27;</span>,<span class="string">&#x27;c02&#x27;</span>,<span class="number">75</span>,<span class="string">&#x27;选修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521102&#x27;</span>,<span class="string">&#x27;c04&#x27;</span>,<span class="number">92</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521102&#x27;</span>,<span class="string">&#x27;c05&#x27;</span>,<span class="number">50</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521103&#x27;</span>,<span class="string">&#x27;c02&#x27;</span>,<span class="number">68</span>,<span class="string">&#x27;选修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9521103&#x27;</span>,<span class="string">&#x27;c06&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9531101&#x27;</span>,<span class="string">&#x27;c01&#x27;</span>,<span class="number">80</span>,<span class="string">&#x27;选修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9531101&#x27;</span>,<span class="string">&#x27;c05&#x27;</span>,<span class="number">95</span>,<span class="string">&#x27;必修&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;9531102&#x27;</span>,<span class="string">&#x27;c05&#x27;</span>,<span class="number">85</span>,<span class="string">&#x27;必修&#x27;</span>);</span><br></pre></td></tr></table></figure><p>T6.<br>查询全体学生的学号与姓名<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname </span><br><span class="line">from Student;</span><br></pre></td></tr></table></figure></p><p>T7.<br>查询全体学生的姓名，学号和所在系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname,Sdept </span><br><span class="line">from Student;</span><br></pre></td></tr></table></figure><br>T8.<br>查询全体学生的所有信息（三张表以上的关联查询）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from Student left join SC on Student.Sno=SC.Sno left join Course on SC.Cno=Course.Cno</span><br></pre></td></tr></table></figure><br>T9.<br>查询全体学生的姓名及其出生年份<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,<span class="number">2018</span><span class="operator">-</span>Sage <span class="keyword">as</span> <span class="string">&#x27;出生年份&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure><br>T10.<br>查询全体学生的姓名和出生年份，并在出生年份列前加入一个列，此列的每行数据均为“Year of Birth”常量值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,<span class="string">&#x27;Year of Birth&#x27;</span>,<span class="number">2018</span><span class="operator">-</span>Sage <span class="keyword">as</span> <span class="string">&#x27;出生年份&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure><br>T11.<br>在选课表（SC）中查询有哪些学生选修了课程，并列出学生的学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure><br>T12.<br>查询计算机系全体学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span></span><br></pre></td></tr></table></figure><br>T13.<br>查询所有年龄在20岁以下的学生的姓名及年龄<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sage</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sage<span class="operator">&lt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure><br>T14.<br>查询考试成绩不及格的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student,SC </span><br><span class="line"><span class="keyword">where</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">and</span> SC.Grade<span class="operator">&lt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><br>T15.<br>查询年龄在20~23岁之间的学生的姓名，所在系和年龄<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sage <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br></pre></td></tr></table></figure><br>T16.<br>查询年龄不在20~23之间的学生的姓名，所在系和年龄<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sage <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br></pre></td></tr></table></figure><br>T17.<br>查询信息系，数学系和计算机系学生的姓名和性别<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">in</span> (<span class="string">&#x27;信息系&#x27;</span>,<span class="string">&#x27;数学系&#x27;</span>,<span class="string">&#x27;计算机系&#x27;</span>)</span><br></pre></td></tr></table></figure><br>T18.<br>查询既不属于信息系，数学系，也不属于计算机系的学生的姓名和性别<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;信息系&#x27;</span>,<span class="string">&#x27;数学系&#x27;</span>,<span class="string">&#x27;计算机系&#x27;</span>)</span><br></pre></td></tr></table></figure><br>T19.<br>查询学生表中姓“张”的学生的详细信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br></pre></td></tr></table></figure><br>T20.<br>查询学生表中姓“张”，姓“李”和姓“刘”的学生的情况<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">or</span> Sname <span class="keyword">like</span> <span class="string">&#x27;李%&#x27;</span> <span class="keyword">or</span> Sname <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span></span><br></pre></td></tr></table></figure><br>使用下边的这种写法更加简便<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;[张李刘]%&#x27;</span> </span><br></pre></td></tr></table></figure><br>T21.<br>查询名字中第2个字为“小”或“大”字的学生的姓名和学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sno</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;_[小大]%&#x27;</span> </span><br></pre></td></tr></table></figure><br>T22.<br>查询所有不姓“刘”的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span> </span><br></pre></td></tr></table></figure><br>T23.<br>从学生表中查询学号的最后一位不是2，3，5的学生的情况<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%[235]&#x27;</span> </span><br></pre></td></tr></table></figure><br>T24.<br>查询无考试成绩的学生的学号和相应的课程号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Cno</span><br><span class="line"><span class="keyword">from</span> SC </span><br><span class="line"><span class="keyword">where</span> Grade <span class="keyword">is</span> <span class="keyword">null</span> </span><br></pre></td></tr></table></figure><br>T25.<br>查询所有有考试成绩的学生的学号和课程号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Cno</span><br><span class="line"><span class="keyword">from</span> SC </span><br><span class="line"><span class="keyword">where</span> Grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> </span><br></pre></td></tr></table></figure><br>T26.<br>查询计算机系年龄在20岁以下的学生的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span> <span class="keyword">and</span> Sage<span class="operator">&lt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure><br>T27.<br>将学生按年龄升序排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Sage <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><br>T28.<br>查询选修了课程“c02”的学生的学号及其成绩，查询结果按成绩降序排列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Grade</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;C02&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Grade <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><br>T29.<br>查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Sdept,Sage <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><br>T30.<br>统计学生总人数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure><br>T31.<br>统计选修了选修课程的学生的人数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> Sno)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> XKLB<span class="operator">=</span><span class="string">&#x27;选修&#x27;</span></span><br></pre></td></tr></table></figure><br>T32.<br>计算学号为9512101的学生的考试总成绩之和<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;9512101&#x27;</span></span><br></pre></td></tr></table></figure><br>T33.<br>计算课程“c01”的学生的考试平均成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;C01&#x27;</span></span><br></pre></td></tr></table></figure><br>T34.<br>查询选修了课程“c01”的学生的最高分和最低分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(Grade),<span class="built_in">min</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;C01&#x27;</span></span><br></pre></td></tr></table></figure><br>T35.<br>统计每门课程的选课人数，列出课程号和人数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Cno,<span class="built_in">count</span>(Sno) <span class="keyword">as</span> <span class="string">&#x27;选课人数&#x27;</span></span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Cno</span><br></pre></td></tr></table></figure><br>T36.<br>查询每名学生的选课门数和平均成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,<span class="built_in">count</span>(Cno) <span class="keyword">as</span> <span class="string">&#x27;选课门数&#x27;</span>,<span class="built_in">avg</span>(Grade) <span class="keyword">as</span> <span class="string">&#x27;平均成绩&#x27;</span></span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br></pre></td></tr></table></figure><br>T37.<br>查询选修了3门以上课程的学生的学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(Cno)<span class="operator">&gt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><br>T38.<br>查询选课门数等于或大于4门的学生的平均成绩和选课门数</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,<span class="built_in">avg</span>(Grade) <span class="keyword">as</span> <span class="string">&#x27;平均成绩&#x27;</span>,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> <span class="string">&#x27;选课门数&#x27;</span></span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">4</span></span><br></pre></td></tr></table></figure></h2><h4 id="四、多表查询"><a href="#四、多表查询" class="headerlink" title="四、多表查询"></a>四、多表查询</h4><p>T39.<br>查询每个学生的情况及其选课的情况<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno</span><br></pre></td></tr></table></figure><br>T40.<br>查询计算机系学生的选课情况，要求列出学生的名字，所修课的课程号和成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Cno,Grade</span><br><span class="line"><span class="keyword">from</span> Student,SC</span><br><span class="line"><span class="keyword">where</span> Student.Sno<span class="operator">=</span>Sc.Sno <span class="keyword">and</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span></span><br></pre></td></tr></table></figure><br>T41.<br>查询信息系选修VB课程的学生的成绩，要求列出学生姓名，课程名和成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Cname,Grade</span><br><span class="line"><span class="keyword">from</span> Student,SC,Course</span><br><span class="line"><span class="keyword">where</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">and</span> SC.Cno<span class="operator">=</span>Course.Cno <span class="keyword">and</span> sdept<span class="operator">=</span><span class="string">&#x27;信息系&#x27;</span> <span class="keyword">and</span> Cname<span class="operator">=</span><span class="string">&#x27;VB&#x27;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Cname,Grade </span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">join</span> Course <span class="keyword">on</span> Course.Cno<span class="operator">=</span>SC.Cno </span><br><span class="line"><span class="keyword">where</span> Sdept <span class="operator">=</span> <span class="string">&#x27;信息系&#x27;</span> <span class="keyword">and</span> Cname <span class="operator">=</span> <span class="string">&#x27;VB&#x27;</span>;</span><br></pre></td></tr></table></figure><br>T42.<br>查询所有选修了VB课程的学生的情况，要求列出学生姓名和所在的系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">join</span> Course <span class="keyword">on</span> Course.Cno<span class="operator">=</span>SC.Cno </span><br><span class="line"><span class="keyword">where</span> Cname<span class="operator">=</span><span class="string">&#x27;VB&#x27;</span></span><br></pre></td></tr></table></figure><br>T43.<br>查询与刘晨在同一个系学习的学生的姓名和所在系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span>(<span class="keyword">select</span> Sdept</span><br><span class="line">             <span class="keyword">from</span> Student</span><br><span class="line">             <span class="keyword">where</span> Sname<span class="operator">=</span><span class="string">&#x27;刘晨&#x27;</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s2.Sname,s2.Sdept</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">as</span> s1,Student <span class="keyword">as</span> s2</span><br><span class="line"><span class="keyword">where</span> s1.Sname<span class="operator">=</span><span class="string">&#x27;刘晨&#x27;</span> <span class="keyword">and</span> s2.Sname <span class="operator">!=</span><span class="string">&#x27;刘晨&#x27;</span> <span class="keyword">and</span> s1.Sdept<span class="operator">=</span>s2.Sdept </span><br></pre></td></tr></table></figure><br>T44.<br>查询学生的选课情况，包括选修课程的学生和没有修课的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">left</span> <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno</span><br></pre></td></tr></table></figure><br>T45.<br>查询数学系成绩在80分以上的学生的学号，姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno</span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;数学系&#x27;</span> <span class="keyword">and</span> Grade<span class="operator">&gt;</span><span class="number">80</span></span><br></pre></td></tr></table></figure><br>T46.<br>查询计算机系考试成绩最高的学生的姓名</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno</span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span> <span class="keyword">and</span> Grade<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(Grade)</span><br><span class="line">                                 <span class="keyword">from</span> Student <span class="keyword">join</span> SC <span class="keyword">on</span> Student.Sno<span class="operator">=</span>SC.Sno</span><br><span class="line"> <span class="keyword">Group</span> <span class="keyword">by</span> Sdept</span><br><span class="line"> <span class="keyword">having</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span>)</span><br></pre></td></tr></table></figure></h2><h4 id="五、嵌套子查询"><a href="#五、嵌套子查询" class="headerlink" title="五、嵌套子查询"></a>五、嵌套子查询</h4><p>(T43)</p><p>T47.<br>查询成绩大于90分的学生的学号和姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Grade<span class="operator">&gt;</span><span class="number">90</span>)</span><br></pre></td></tr></table></figure><br>T48.<br>查询选修了“数据库基础”课程的学生的学号和姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC </span><br><span class="line">              <span class="keyword">where</span> Cno <span class="keyword">in</span> (<span class="keyword">select</span> Cno</span><br><span class="line">                            <span class="keyword">from</span> Course</span><br><span class="line">                            <span class="keyword">where</span> Cname<span class="operator">=</span><span class="string">&#x27;数据库基础&#x27;</span>))</span><br></pre></td></tr></table></figure><br>T49.<br>查询选修了刘晨没有选修的课程的学生的学号和所在系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sdept</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Cno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> Cno</span><br><span class="line">                                <span class="keyword">from</span> SC</span><br><span class="line">                                <span class="keyword">where</span> Sno<span class="operator">=</span>(<span class="keyword">select</span> Sno</span><br><span class="line">                                           <span class="keyword">from</span> Student</span><br><span class="line">                                           <span class="keyword">where</span> Sname<span class="operator">=</span><span class="string">&#x27;刘晨&#x27;</span>)))</span><br></pre></td></tr></table></figure><br>T50.<br>查询选修了课程“c02”且成绩高于此课程的平均成绩的学生的学号和成绩<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Grade</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;C02&#x27;</span> <span class="keyword">and</span> Grade<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="built_in">avg</span>(Grade)</span><br><span class="line">                           <span class="keyword">from</span> SC</span><br><span class="line">                           <span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;C02&#x27;</span>)</span><br></pre></td></tr></table></figure><br>T51.<br>查询选修了课程“c01”的学生姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;C01&#x27;</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">              <span class="keyword">from</span> SC</span><br><span class="line">              <span class="keyword">where</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">and</span> Cno<span class="operator">=</span><span class="string">&#x27;C01&#x27;</span>)</span><br></pre></td></tr></table></figure><br>PS.一般来说，在SQL中in子查询都可以用exists代替。EXISTS子查询可以看成是一个独立的查询系统，只为了获取真假逻辑值，EXISTS子查询与外查询查询的表是两个完全独立的毫无关系的表，当我们在子查询中添加了Sno关联之后，EXISTS子查询与外查询查询的表就统一了，是二者组合组建的虚表，是同一个表（这样当子查询查询到虚表中当前行的Cno为C01时，则将虚表当前行中对应的Sname查询到了）.<br>　　重点在于Sno关联之上，添加Sno关联，数据库会先将两张表通过Sno关联组合成一张虚表，所有的查询操作都在这张虚表上完成。</p><hr><h4 id="六、自查询"><a href="#六、自查询" class="headerlink" title="六、自查询"></a>六、自查询</h4><p>T52.查询所有成绩大于C01课程最高成绩的学生的学号</p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SC2.Sno</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">as</span> SC1,SC <span class="keyword">as</span> SC2</span><br><span class="line"><span class="keyword">where</span> SC1.Sno<span class="operator">=</span>SC2.Sno <span class="keyword">and</span> SC1.Cno<span class="operator">=</span>SC2.Cno <span class="keyword">and</span> SC2.Grade<span class="operator">&gt;</span><span class="keyword">all</span>(<span class="keyword">select</span> Grade</span><br><span class="line">                                                            <span class="keyword">from</span> SC</span><br><span class="line">                                                            <span class="keyword">where</span> SC.Cno<span class="operator">=</span><span class="string">&#x27;C01&#x27;</span>)</span><br></pre></td></tr></table></figure></h2><h4 id="七、更新数据"><a href="#七、更新数据" class="headerlink" title="七、更新数据"></a>七、更新数据</h4><p>T53.<br>将所有学生的年龄加1<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update Student</span><br><span class="line"><span class="keyword">set</span> Sage<span class="operator">=</span>Sage<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure><br>T54.<br>将“9512101”学生的年龄改为21岁<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update Student</span><br><span class="line"><span class="keyword">set</span> Sage<span class="operator">=</span><span class="number">21</span></span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;9512101&#x27;</span></span><br></pre></td></tr></table></figure><br>T55.<br>将计算机系学生的成绩加5分</p><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update SC</span><br><span class="line"><span class="keyword">set</span> Grade<span class="operator">=</span>Grade<span class="operator">+</span><span class="number">5</span></span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">              <span class="keyword">from</span> Student</span><br><span class="line">              <span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span>)</span><br></pre></td></tr></table></figure></h2><h4 id="八、删除数据"><a href="#八、删除数据" class="headerlink" title="八、删除数据"></a>八、删除数据</h4><p>T56.<br>删除所有学生的选课记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure><br>T57.<br>删除所有不及格学生的选课记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Grade<span class="operator">&lt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><br>T58.<br>删除计算机系不及格学生的选课记录</p><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> Grade<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">and</span> Sno <span class="keyword">in</span> (<span class="keyword">select</span> Sno</span><br><span class="line">                           <span class="keyword">from</span> Student</span><br><span class="line">                           <span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;计算机系&#x27;</span>)</span><br></pre></td></tr></table></figure></h2><p>数据来源于网络，整理@lihui<br>测试代码：<br><a href="https://Liyzy.github.io/2018/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98%28%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80%29/create_table.sql">建表代码</a><br><a href="http://Liyzy.github.io/2018/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98%28%E6%AF%94%E8%BE%83%E5%9F%BA%E7%A1%80%29/T.sql">题目代码</a><br>测试环境：SQL Server 2017</p><hr><p>考试结束了，烤糊了😭…附上题目留与后人吧<br><strong>2017-2018学年大连理工大学软件学院数据库考试题目说明</strong></p><p><font color=#0099ff>20分 </font>   10个选择（比较简单，复习注意概念，比如DBS，DB，DBMS都是什么。其中有两个有关事务的题，即第十二章内容，分别是ACID的四个性质内容和结束事务并回滚的语句是什么问题）</p><p><font color=#0099ff>50分 </font>     4个关系代数，6个SQL，一个5分。考了not exists和not in 相互转换, not exists…except结构,  标量子查询，分组聚集的内容（懵的一匹@_@）</p><p><font color=#0099ff>10分 </font>     范式分解 属性闭包和候选码（6分），判断第几范式（2分），BCNF分解（2分）</p><p><font color=#0099ff>20分 </font>     ER图 画ER图（10分），转换成关系模式（10分）。<br>（回忆版）商店记录商品信息和客户信息，商品信息包括商品编号、名称、单价等，客户信息包括客户编号、客户姓名、电话等。一个顾客可以购买多个商品，一件商品可以购买不同数量，一次性的购物记录在一个购物单里，商品销售时价格可以调整。要求商店可以查询一个客户的消费记录和消费总额。根据题意设计ER图，可以自己添加必要属性。</p><p><br/></p>]]></content>
    
    
    <summary type="html">近期要数据库考试了，复习一波，题还是很基础的~</summary>
    
    
    
    
    <category term="数据库" scheme="https://wheliosc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【Python learning 1】从Hello world!开始（print()函数解析）</title>
    <link href="https://wheliosc.github.io/Python-hello-world"/>
    <id>https://wheliosc.github.io/Python-hello-world</id>
    <published>2018-06-06T10:40:37.079Z</published>
    <updated>2021-08-30T07:28:45.261Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p><span id="more"></span><p>老规矩，学习一门语言，肯定要从Hello world开始啦</p><p>Python2<br><code>print &quot;Hello world!&quot;</code></p><p>Python3<br><code>print(&quot;Hello world!&quot;)</code><br>不同的原因是，在Python3中，print只作为一个函数调用，括号中的内容作为函数的参数。</p><p>但是，在Python2中使用括号也没有问题。</p><p>print()函数:</p><p><code>print（*objects,sep=&#39; &#39;,end=&#39;\n&#39;,file=sys.stdout,flush=False）</code></p><p>参数意义</p><ul><li><p>*objects 表示要输出的值，可以是多个，用逗号分隔</p></li><li><p>sep 表示多个输出值之间的间隔，可以自己赋值，默认为一个空格</p></li><li><p>end 表示输出语句最末尾附加的字符串，默认为’\n’，即换行    </p></li><li><p>file 表示输出的对象，可以是文件也可以是数据流，默认是sys.stdout</p></li><li><p>flush 表示是否立刻将输出语句输出的目标对象，默认为False</p></li></ul><p>🔖在Python2中，如果不想换行则在输出语句的末尾加一个逗号，Python3中写成print(“hhh”,end=’’)就好了。</p><p><br/></p>]]></content>
    
    
    <summary type="html">这是Python自学的记录第一篇，主要内容有print函数</summary>
    
    
    
    
    <category term="Python" scheme="https://wheliosc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wheliosc.github.io/hello-world"/>
    <id>https://wheliosc.github.io/hello-world</id>
    <published>2018-06-04T07:44:10.983Z</published>
    <updated>2021-08-30T07:52:18.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <summary type="html">这是我的第一篇blog哦~</summary>
    
    
    
    
  </entry>
  
</feed>
